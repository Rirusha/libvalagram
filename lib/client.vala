/*
 * Copyright (C) 2024 Vladimir Vaskov
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

// THIS FILE WAS GENERATED, DON'T MODIFY IT

public sealed class TDLib.Client : Object {

    public int client_id { get; private set; }

    internal RequestManager request_manager { get; set; }


    /**
     * @param with_loop Create ``MainLoop`` instance or not
     */
    ~Client () {
        if (request_manager != null) {
            request_manager.stop ();
        }
    }

    /**
     * Init client: create request manager and set client_id
     */
    public void init () {
        client_id = TDJsonApi.create_client_id ();
        request_manager = new RequestManager ();
        request_manager.run.begin ();
    }

    /**
     * Returns the current authorization state; this is an offline request.
     * For informational purposes only. Use updateAuthorizationState instead
     * to maintain the current authorization state. Can be called before
     * initialization
     */
    public async AuthorizationState get_authorization_state () throws BadStatusCodeError {
        var obj = new GetAuthorizationState ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_authorization_state.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        AuthorizationState out_obj;
        switch (tdlib_type) {
            case "authorizationStateWaitTdlibParameters":
                out_obj = (AuthorizationStateWaitTdlibParameters) jsoner.deserialize_object (typeof (AuthorizationStateWaitTdlibParameters));
                break;
            case "authorizationStateWaitPhoneNumber":
                out_obj = (AuthorizationStateWaitPhoneNumber) jsoner.deserialize_object (typeof (AuthorizationStateWaitPhoneNumber));
                break;
            case "authorizationStateWaitEmailAddress":
                out_obj = (AuthorizationStateWaitEmailAddress) jsoner.deserialize_object (typeof (AuthorizationStateWaitEmailAddress));
                break;
            case "authorizationStateWaitEmailCode":
                out_obj = (AuthorizationStateWaitEmailCode) jsoner.deserialize_object (typeof (AuthorizationStateWaitEmailCode));
                break;
            case "authorizationStateWaitCode":
                out_obj = (AuthorizationStateWaitCode) jsoner.deserialize_object (typeof (AuthorizationStateWaitCode));
                break;
            case "authorizationStateWaitOtherDeviceConfirmation":
                out_obj = (AuthorizationStateWaitOtherDeviceConfirmation) jsoner.deserialize_object (typeof (AuthorizationStateWaitOtherDeviceConfirmation));
                break;
            case "authorizationStateWaitRegistration":
                out_obj = (AuthorizationStateWaitRegistration) jsoner.deserialize_object (typeof (AuthorizationStateWaitRegistration));
                break;
            case "authorizationStateWaitPassword":
                out_obj = (AuthorizationStateWaitPassword) jsoner.deserialize_object (typeof (AuthorizationStateWaitPassword));
                break;
            case "authorizationStateReady":
                out_obj = (AuthorizationStateReady) jsoner.deserialize_object (typeof (AuthorizationStateReady));
                break;
            case "authorizationStateLoggingOut":
                out_obj = (AuthorizationStateLoggingOut) jsoner.deserialize_object (typeof (AuthorizationStateLoggingOut));
                break;
            case "authorizationStateClosing":
                out_obj = (AuthorizationStateClosing) jsoner.deserialize_object (typeof (AuthorizationStateClosing));
                break;
            case "authorizationStateClosed":
                out_obj = (AuthorizationStateClosed) jsoner.deserialize_object (typeof (AuthorizationStateClosed));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the parameters for TDLib initialization. Works only when the
     * current authorization state is authorizationStateWaitTdlibParameters
     * @param use_test_dc Pass true to use Telegram test environment instead
     * of the production environment
     * @param database_directory The path to the directory for the persistent
     * database; if empty, the current working directory will be used
     * @param files_directory The path to the directory for storing files; if
     * empty, database_directory will be used
     * @param database_encryption_key Encryption key for the database. If the
     * encryption key is invalid, then an error with code 401 will be
     * returned
     * @param use_file_database Pass true to keep information about
     * downloaded and uploaded files between application restarts
     * @param use_chat_info_database Pass true to keep cache of users, basic
     * groups, supergroups, channels and secret chats between restarts.
     * Implies use_file_database
     * @param use_message_database Pass true to keep cache of chats and
     * messages between restarts. Implies use_chat_info_database
     * @param use_secret_chats Pass true to enable support for secret chats
     * @param api_id Application identifier for Telegram API access, which
     * can be obtained at https://my.telegram.org
     * @param api_hash Application identifier hash for Telegram API access,
     * which can be obtained at https://my.telegram.org
     * @param system_language_code IETF language tag of the user's operating
     * system language; must be non-empty
     * @param device_model Model of the device the application is being run
     * on; must be non-empty
     * @param system_version Version of the operating system the application
     * is being run on. If empty, the version is automatically detected by
     * TDLib
     * @param application_version Application version; must be non-empty
     */
    public async Ok set_tdlib_parameters (
        bool use_test_dc,
        string database_directory,
        string files_directory,
        Bytes database_encryption_key,
        bool use_file_database,
        bool use_chat_info_database,
        bool use_message_database,
        bool use_secret_chats,
        int32 api_id,
        string api_hash,
        string system_language_code,
        string device_model,
        string system_version,
        string application_version
    ) throws BadStatusCodeError {
        var obj = new SetTdlibParameters (
            use_test_dc,
            database_directory,
            files_directory,
            database_encryption_key,
            use_file_database,
            use_chat_info_database,
            use_message_database,
            use_secret_chats,
            api_id,
            api_hash,
            system_language_code,
            device_model,
            system_version,
            application_version
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_tdlib_parameters.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the phone number of the user and sends an authentication code to
     * the user. Works only when the current authorization state is
     * authorizationStateWaitPhoneNumber,
     * or if there is no pending authentication query and the current
     * authorization state is authorizationStateWaitEmailAddress,
     * authorizationStateWaitEmailCode, authorizationStateWaitCode,
     * authorizationStateWaitRegistration, or authorizationStateWaitPassword
     * @param phone_number The phone number of the user, in international
     * format
     * @param settings Settings for the authentication of the user's phone
     * number; pass null to use default settings
     */
    public async Ok set_authentication_phone_number (
        string phone_number,
        PhoneNumberAuthenticationSettings settings
    ) throws BadStatusCodeError {
        var obj = new SetAuthenticationPhoneNumber (
            phone_number,
            settings
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_authentication_phone_number.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the email address of the user and sends an authentication code to
     * the email address. Works only when the current authorization state is
     * authorizationStateWaitEmailAddress
     * @param email_address The email address of the user
     */
    public async Ok set_authentication_email_address (
        string email_address
    ) throws BadStatusCodeError {
        var obj = new SetAuthenticationEmailAddress (
            email_address
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_authentication_email_address.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Resends an authentication code to the user. Works only when the
     * current authorization state is authorizationStateWaitCode, the
     * next_code_type of the result is not null
     * and the server-specified timeout has passed, or when the current
     * authorization state is authorizationStateWaitEmailCode
     * @param reason Reason of code resending; pass null if unknown
     */
    public async Ok resend_authentication_code (
        ResendCodeReason reason
    ) throws BadStatusCodeError {
        var obj = new ResendAuthenticationCode (
            reason
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (resend_authentication_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks the authentication of an email address. Works only when the
     * current authorization state is authorizationStateWaitEmailCode
     * @param code Email address authentication to check
     */
    public async Ok check_authentication_email_code (
        EmailAddressAuthentication code
    ) throws BadStatusCodeError {
        var obj = new CheckAuthenticationEmailCode (
            code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_authentication_email_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks the authentication code. Works only when the current
     * authorization state is authorizationStateWaitCode
     * @param code Authentication code to check
     */
    public async Ok check_authentication_code (
        string code
    ) throws BadStatusCodeError {
        var obj = new CheckAuthenticationCode (
            code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_authentication_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Requests QR code authentication by scanning a QR code on another
     * logged in device. Works only when the current authorization state is
     * authorizationStateWaitPhoneNumber,
     * or if there is no pending authentication query and the current
     * authorization state is authorizationStateWaitEmailAddress,
     * authorizationStateWaitEmailCode, authorizationStateWaitCode,
     * authorizationStateWaitRegistration, or authorizationStateWaitPassword
     * @param other_user_ids List of user identifiers of other users
     * currently using the application
     */
    public async Ok request_qr_code_authentication (
        Gee.ArrayList<int64?> other_user_ids
    ) throws BadStatusCodeError {
        var obj = new RequestQrCodeAuthentication (
            other_user_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (request_qr_code_authentication.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Finishes user registration. Works only when the current authorization
     * state is authorizationStateWaitRegistration
     * @param first_name The first name of the user; 1-64 characters
     * @param last_name The last name of the user; 0-64 characters
     * @param disable_notification Pass true to disable notification about
     * the current user joining Telegram for other users that added them to
     * contact list
     */
    public async Ok register_user (
        string first_name,
        string last_name,
        bool disable_notification
    ) throws BadStatusCodeError {
        var obj = new RegisterUser (
            first_name,
            last_name,
            disable_notification
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (register_user.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Resets the login email address. May return an error with a message
     * "TASK_ALREADY_EXISTS" if reset is still pending.
     * Works only when the current authorization state is
     * authorizationStateWaitEmailCode and
     * authorization_state.can_reset_email_address == true
     */
    public async Ok reset_authentication_email_address () throws BadStatusCodeError {
        var obj = new ResetAuthenticationEmailAddress ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reset_authentication_email_address.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks the 2-step verification password for correctness. Works only
     * when the current authorization state is authorizationStateWaitPassword
     * @param password The 2-step verification password to check
     */
    public async Ok check_authentication_password (
        string password
    ) throws BadStatusCodeError {
        var obj = new CheckAuthenticationPassword (
            password
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_authentication_password.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Requests to send a 2-step verification password recovery code to an
     * email address that was previously set up. Works only when the current
     * authorization state is authorizationStateWaitPassword
     */
    public async Ok request_authentication_password_recovery () throws BadStatusCodeError {
        var obj = new RequestAuthenticationPasswordRecovery ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (request_authentication_password_recovery.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks whether a 2-step verification password recovery code sent to an
     * email address is valid. Works only when the current authorization
     * state is authorizationStateWaitPassword
     * @param recovery_code Recovery code to check
     */
    public async Ok check_authentication_password_recovery_code (
        string recovery_code
    ) throws BadStatusCodeError {
        var obj = new CheckAuthenticationPasswordRecoveryCode (
            recovery_code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_authentication_password_recovery_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Recovers the 2-step verification password with a password recovery
     * code sent to an email address that was previously set up. Works only
     * when the current authorization state is authorizationStateWaitPassword
     * @param recovery_code Recovery code to check
     * @param new_password New 2-step verification password of the user; may
     * be empty to remove the password
     * @param new_hint New password hint; may be empty
     */
    public async Ok recover_authentication_password (
        string recovery_code,
        string new_password,
        string new_hint
    ) throws BadStatusCodeError {
        var obj = new RecoverAuthenticationPassword (
            recovery_code,
            new_password,
            new_hint
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (recover_authentication_password.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends Firebase Authentication SMS to the phone number of the user.
     * Works only when the current authorization state is
     * authorizationStateWaitCode and the server returned code of the type
     * authenticationCodeTypeFirebaseAndroid or
     * authenticationCodeTypeFirebaseIos
     * @param token Play Integrity API or SafetyNet Attestation API token for
     * the Android application, or secret from push notification for the iOS
     * application
     */
    public async Ok send_authentication_firebase_sms (
        string token
    ) throws BadStatusCodeError {
        var obj = new SendAuthenticationFirebaseSms (
            token
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_authentication_firebase_sms.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Reports that authentication code wasn't delivered via SMS; for
     * official mobile applications only. Works only when the current
     * authorization state is authorizationStateWaitCode
     * @param mobile_network_code Current mobile network code
     */
    public async Ok report_authentication_code_missing (
        string mobile_network_code
    ) throws BadStatusCodeError {
        var obj = new ReportAuthenticationCodeMissing (
            mobile_network_code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_authentication_code_missing.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks the authentication token of a bot; to log in as a bot. Works
     * only when the current authorization state is
     * authorizationStateWaitPhoneNumber. Can be used instead of
     * setAuthenticationPhoneNumber and checkAuthenticationCode to log in
     * @param token The bot token
     */
    public async Ok check_authentication_bot_token (
        string token
    ) throws BadStatusCodeError {
        var obj = new CheckAuthenticationBotToken (
            token
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_authentication_bot_token.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Closes the TDLib instance after a proper logout. Requires an available
     * network connection. All local data will be destroyed. After the logout
     * completes, updateAuthorizationState with authorizationStateClosed will
     * be sent
     */
    public async Ok log_out () throws BadStatusCodeError {
        var obj = new LogOut ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (log_out.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Closes the TDLib instance. All databases will be flushed to disk and
     * properly closed. After the close completes, updateAuthorizationState
     * with authorizationStateClosed will be sent. Can be called before
     * initialization
     */
    public async Ok close () throws BadStatusCodeError {
        var obj = new Close ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (close.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Closes the TDLib instance, destroying all local data without a proper
     * logout. The current user session will remain in the list of all active
     * sessions. All local data will be destroyed.
     * After the destruction completes updateAuthorizationState with
     * authorizationStateClosed will be sent. Can be called before
     * authorization
     */
    public async Ok destroy () throws BadStatusCodeError {
        var obj = new Destroy ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (destroy.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Confirms QR code authentication on another device. Returns created
     * session on success
     * @param link A link from a QR code. The link must be scanned by the
     * in-app camera
     */
    public async Session confirm_qr_code_authentication (
        string link
    ) throws BadStatusCodeError {
        var obj = new ConfirmQrCodeAuthentication (
            link
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (confirm_qr_code_authentication.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Session out_obj;
        switch (tdlib_type) {
            case "session":
                out_obj = (Session) jsoner.deserialize_object (typeof (Session));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns all updates needed to restore current TDLib state, i.e. all
     * actual updateAuthorizationState/updateUser/updateNewChat and others.
     * This is especially useful if TDLib is run in a separate process. Can
     * be called before initialization
     */
    public async Updates get_current_state () throws BadStatusCodeError {
        var obj = new GetCurrentState ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_current_state.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Updates out_obj;
        switch (tdlib_type) {
            case "updates":
                out_obj = (Updates) jsoner.deserialize_object (typeof (Updates));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the database encryption key. Usually the encryption key is
     * never changed and is stored in some OS keychain
     * @param new_encryption_key New encryption key
     */
    public async Ok set_database_encryption_key (
        Bytes new_encryption_key
    ) throws BadStatusCodeError {
        var obj = new SetDatabaseEncryptionKey (
            new_encryption_key
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_database_encryption_key.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the current state of 2-step verification
     */
    public async PasswordState get_password_state () throws BadStatusCodeError {
        var obj = new GetPasswordState ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_password_state.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PasswordState out_obj;
        switch (tdlib_type) {
            case "passwordState":
                out_obj = (PasswordState) jsoner.deserialize_object (typeof (PasswordState));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the 2-step verification password for the current user. If a
     * new recovery email address is specified, then the change will not be
     * applied until the new recovery email address is confirmed
     * @param old_password Previous 2-step verification password of the user
     * @param new_password New 2-step verification password of the user; may
     * be empty to remove the password
     * @param new_hint New password hint; may be empty
     * @param set_recovery_email_address Pass true to change also the
     * recovery email address
     * @param new_recovery_email_address New recovery email address; may be
     * empty
     */
    public async PasswordState set_password (
        string old_password,
        string new_password,
        string new_hint,
        bool set_recovery_email_address,
        string new_recovery_email_address
    ) throws BadStatusCodeError {
        var obj = new SetPassword (
            old_password,
            new_password,
            new_hint,
            set_recovery_email_address,
            new_recovery_email_address
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_password.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PasswordState out_obj;
        switch (tdlib_type) {
            case "passwordState":
                out_obj = (PasswordState) jsoner.deserialize_object (typeof (PasswordState));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the login email address of the user. The email address can be
     * changed only if the current user already has login email and
     * passwordState.login_email_address_pattern is non-empty.
     * The change will not be applied until the new login email address is
     * confirmed with checkLoginEmailAddressCode. To use Apple ID/Google ID
     * instead of an email address, call checkLoginEmailAddressCode directly
     * @param new_login_email_address New login email address
     */
    public async EmailAddressAuthenticationCodeInfo set_login_email_address (
        string new_login_email_address
    ) throws BadStatusCodeError {
        var obj = new SetLoginEmailAddress (
            new_login_email_address
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_login_email_address.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        EmailAddressAuthenticationCodeInfo out_obj;
        switch (tdlib_type) {
            case "emailAddressAuthenticationCodeInfo":
                out_obj = (EmailAddressAuthenticationCodeInfo) jsoner.deserialize_object (typeof (EmailAddressAuthenticationCodeInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Resends the login email address verification code
     */
    public async EmailAddressAuthenticationCodeInfo resend_login_email_address_code () throws BadStatusCodeError {
        var obj = new ResendLoginEmailAddressCode ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (resend_login_email_address_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        EmailAddressAuthenticationCodeInfo out_obj;
        switch (tdlib_type) {
            case "emailAddressAuthenticationCodeInfo":
                out_obj = (EmailAddressAuthenticationCodeInfo) jsoner.deserialize_object (typeof (EmailAddressAuthenticationCodeInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks the login email address authentication
     * @param code Email address authentication to check
     */
    public async Ok check_login_email_address_code (
        EmailAddressAuthentication code
    ) throws BadStatusCodeError {
        var obj = new CheckLoginEmailAddressCode (
            code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_login_email_address_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a 2-step verification recovery email address that was
     * previously set up. This method can be used to verify a password
     * provided by the user
     * @param password The 2-step verification password for the current user
     */
    public async RecoveryEmailAddress get_recovery_email_address (
        string password
    ) throws BadStatusCodeError {
        var obj = new GetRecoveryEmailAddress (
            password
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_recovery_email_address.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        RecoveryEmailAddress out_obj;
        switch (tdlib_type) {
            case "recoveryEmailAddress":
                out_obj = (RecoveryEmailAddress) jsoner.deserialize_object (typeof (RecoveryEmailAddress));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the 2-step verification recovery email address of the user. If
     * a new recovery email address is specified, then the change will not be
     * applied until the new recovery email address is confirmed.
     * If new_recovery_email_address is the same as the email address that is
     * currently set up, this call succeeds immediately and aborts all other
     * requests waiting for an email confirmation
     * @param password The 2-step verification password of the current user
     * @param new_recovery_email_address New recovery email address
     */
    public async PasswordState set_recovery_email_address (
        string password,
        string new_recovery_email_address
    ) throws BadStatusCodeError {
        var obj = new SetRecoveryEmailAddress (
            password,
            new_recovery_email_address
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_recovery_email_address.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PasswordState out_obj;
        switch (tdlib_type) {
            case "passwordState":
                out_obj = (PasswordState) jsoner.deserialize_object (typeof (PasswordState));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks the 2-step verification recovery email address verification
     * code
     * @param code Verification code to check
     */
    public async PasswordState check_recovery_email_address_code (
        string code
    ) throws BadStatusCodeError {
        var obj = new CheckRecoveryEmailAddressCode (
            code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_recovery_email_address_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PasswordState out_obj;
        switch (tdlib_type) {
            case "passwordState":
                out_obj = (PasswordState) jsoner.deserialize_object (typeof (PasswordState));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Resends the 2-step verification recovery email address verification
     * code
     */
    public async PasswordState resend_recovery_email_address_code () throws BadStatusCodeError {
        var obj = new ResendRecoveryEmailAddressCode ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (resend_recovery_email_address_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PasswordState out_obj;
        switch (tdlib_type) {
            case "passwordState":
                out_obj = (PasswordState) jsoner.deserialize_object (typeof (PasswordState));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Cancels verification of the 2-step verification recovery email address
     */
    public async PasswordState cancel_recovery_email_address_verification () throws BadStatusCodeError {
        var obj = new CancelRecoveryEmailAddressVerification ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (cancel_recovery_email_address_verification.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PasswordState out_obj;
        switch (tdlib_type) {
            case "passwordState":
                out_obj = (PasswordState) jsoner.deserialize_object (typeof (PasswordState));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Requests to send a 2-step verification password recovery code to an
     * email address that was previously set up
     */
    public async EmailAddressAuthenticationCodeInfo request_password_recovery () throws BadStatusCodeError {
        var obj = new RequestPasswordRecovery ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (request_password_recovery.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        EmailAddressAuthenticationCodeInfo out_obj;
        switch (tdlib_type) {
            case "emailAddressAuthenticationCodeInfo":
                out_obj = (EmailAddressAuthenticationCodeInfo) jsoner.deserialize_object (typeof (EmailAddressAuthenticationCodeInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks whether a 2-step verification password recovery code sent to an
     * email address is valid
     * @param recovery_code Recovery code to check
     */
    public async Ok check_password_recovery_code (
        string recovery_code
    ) throws BadStatusCodeError {
        var obj = new CheckPasswordRecoveryCode (
            recovery_code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_password_recovery_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Recovers the 2-step verification password using a recovery code sent
     * to an email address that was previously set up
     * @param recovery_code Recovery code to check
     * @param new_password New 2-step verification password of the user; may
     * be empty to remove the password
     * @param new_hint New password hint; may be empty
     */
    public async PasswordState recover_password (
        string recovery_code,
        string new_password,
        string new_hint
    ) throws BadStatusCodeError {
        var obj = new RecoverPassword (
            recovery_code,
            new_password,
            new_hint
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (recover_password.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PasswordState out_obj;
        switch (tdlib_type) {
            case "passwordState":
                out_obj = (PasswordState) jsoner.deserialize_object (typeof (PasswordState));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes 2-step verification password without previous password and
     * access to recovery email address. The password can't be reset
     * immediately and the request needs to be repeated after the specified
     * time
     */
    public async ResetPasswordResult reset_password () throws BadStatusCodeError {
        var obj = new ResetPassword ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reset_password.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ResetPasswordResult out_obj;
        switch (tdlib_type) {
            case "resetPasswordResultOk":
                out_obj = (ResetPasswordResultOk) jsoner.deserialize_object (typeof (ResetPasswordResultOk));
                break;
            case "resetPasswordResultPending":
                out_obj = (ResetPasswordResultPending) jsoner.deserialize_object (typeof (ResetPasswordResultPending));
                break;
            case "resetPasswordResultDeclined":
                out_obj = (ResetPasswordResultDeclined) jsoner.deserialize_object (typeof (ResetPasswordResultDeclined));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Cancels reset of 2-step verification password. The method can be
     * called if passwordState.pending_reset_date > 0
     */
    public async Ok cancel_password_reset () throws BadStatusCodeError {
        var obj = new CancelPasswordReset ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (cancel_password_reset.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Creates a new temporary password for processing payments
     * @param password The 2-step verification password of the current user
     * @param valid_for Time during which the temporary password will be
     * valid, in seconds; must be between 60 and 86400
     */
    public async TemporaryPasswordState create_temporary_password (
        string password,
        int32 valid_for
    ) throws BadStatusCodeError {
        var obj = new CreateTemporaryPassword (
            password,
            valid_for
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_temporary_password.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        TemporaryPasswordState out_obj;
        switch (tdlib_type) {
            case "temporaryPasswordState":
                out_obj = (TemporaryPasswordState) jsoner.deserialize_object (typeof (TemporaryPasswordState));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about the current temporary password
     */
    public async TemporaryPasswordState get_temporary_password_state () throws BadStatusCodeError {
        var obj = new GetTemporaryPasswordState ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_temporary_password_state.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        TemporaryPasswordState out_obj;
        switch (tdlib_type) {
            case "temporaryPasswordState":
                out_obj = (TemporaryPasswordState) jsoner.deserialize_object (typeof (TemporaryPasswordState));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the current user
     */
    public async User get_me () throws BadStatusCodeError {
        var obj = new GetMe ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_me.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        User out_obj;
        switch (tdlib_type) {
            case "user":
                out_obj = (User) jsoner.deserialize_object (typeof (User));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a user by their identifier. This is an
     * offline request if the current user is not a bot
     * @param user_id User identifier
     */
    public async User get_user (
        int64 user_id
    ) throws BadStatusCodeError {
        var obj = new GetUser (
            user_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_user.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        User out_obj;
        switch (tdlib_type) {
            case "user":
                out_obj = (User) jsoner.deserialize_object (typeof (User));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns full information about a user by their identifier
     * @param user_id User identifier
     */
    public async UserFullInfo get_user_full_info (
        int64 user_id
    ) throws BadStatusCodeError {
        var obj = new GetUserFullInfo (
            user_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_user_full_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        UserFullInfo out_obj;
        switch (tdlib_type) {
            case "userFullInfo":
                out_obj = (UserFullInfo) jsoner.deserialize_object (typeof (UserFullInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a basic group by its identifier. This is an
     * offline request if the current user is not a bot
     * @param basic_group_id Basic group identifier
     */
    public async BasicGroup get_basic_group (
        int64 basic_group_id
    ) throws BadStatusCodeError {
        var obj = new GetBasicGroup (
            basic_group_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_basic_group.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BasicGroup out_obj;
        switch (tdlib_type) {
            case "basicGroup":
                out_obj = (BasicGroup) jsoner.deserialize_object (typeof (BasicGroup));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns full information about a basic group by its identifier
     * @param basic_group_id Basic group identifier
     */
    public async BasicGroupFullInfo get_basic_group_full_info (
        int64 basic_group_id
    ) throws BadStatusCodeError {
        var obj = new GetBasicGroupFullInfo (
            basic_group_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_basic_group_full_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BasicGroupFullInfo out_obj;
        switch (tdlib_type) {
            case "basicGroupFullInfo":
                out_obj = (BasicGroupFullInfo) jsoner.deserialize_object (typeof (BasicGroupFullInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a supergroup or a channel by its identifier.
     * This is an offline request if the current user is not a bot
     * @param supergroup_id Supergroup or channel identifier
     */
    public async Supergroup get_supergroup (
        int64 supergroup_id
    ) throws BadStatusCodeError {
        var obj = new GetSupergroup (
            supergroup_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_supergroup.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Supergroup out_obj;
        switch (tdlib_type) {
            case "supergroup":
                out_obj = (Supergroup) jsoner.deserialize_object (typeof (Supergroup));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns full information about a supergroup or a channel by its
     * identifier, cached for up to 1 minute
     * @param supergroup_id Supergroup or channel identifier
     */
    public async SupergroupFullInfo get_supergroup_full_info (
        int64 supergroup_id
    ) throws BadStatusCodeError {
        var obj = new GetSupergroupFullInfo (
            supergroup_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_supergroup_full_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        SupergroupFullInfo out_obj;
        switch (tdlib_type) {
            case "supergroupFullInfo":
                out_obj = (SupergroupFullInfo) jsoner.deserialize_object (typeof (SupergroupFullInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a secret chat by its identifier. This is an
     * offline request
     * @param secret_chat_id Secret chat identifier
     */
    public async SecretChat get_secret_chat (
        int32 secret_chat_id
    ) throws BadStatusCodeError {
        var obj = new GetSecretChat (
            secret_chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_secret_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        SecretChat out_obj;
        switch (tdlib_type) {
            case "secretChat":
                out_obj = (SecretChat) jsoner.deserialize_object (typeof (SecretChat));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a chat by its identifier; this is an offline
     * request if the current user is not a bot
     * @param chat_id Chat identifier
     */
    public async Chat get_chat (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new GetChat (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chat out_obj;
        switch (tdlib_type) {
            case "chat":
                out_obj = (Chat) jsoner.deserialize_object (typeof (Chat));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a message. Returns a 404 error if the
     * message doesn't exist
     * @param chat_id Identifier of the chat the message belongs to
     * @param message_id Identifier of the message to get
     */
    public async Message get_message (
        int64 chat_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new GetMessage (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Message out_obj;
        switch (tdlib_type) {
            case "message":
                out_obj = (Message) jsoner.deserialize_object (typeof (Message));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a message, if it is available without
     * sending network request. Returns a 404 error if message isn't
     * available locally. This is an offline request
     * @param chat_id Identifier of the chat the message belongs to
     * @param message_id Identifier of the message to get
     */
    public async Message get_message_locally (
        int64 chat_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new GetMessageLocally (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_locally.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Message out_obj;
        switch (tdlib_type) {
            case "message":
                out_obj = (Message) jsoner.deserialize_object (typeof (Message));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a non-bundled message that is replied by a
     * given message. Also, returns the pinned message, the game message, the
     * invoice message,
     * the message with a previously set same background, the giveaway
     * message, and the topic creation message for messages of the types
     * messagePinMessage, messageGameScore, messagePaymentSuccessful,
     * messageChatSetBackground, messageGiveawayCompleted and topic messages
     * without non-bundled replied message respectively.
     * Returns a 404 error if the message doesn't exist
     * @param chat_id Identifier of the chat the message belongs to
     * @param message_id Identifier of the reply message
     */
    public async Message get_replied_message (
        int64 chat_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new GetRepliedMessage (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_replied_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Message out_obj;
        switch (tdlib_type) {
            case "message":
                out_obj = (Message) jsoner.deserialize_object (typeof (Message));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a newest pinned message in the chat. Returns
     * a 404 error if the message doesn't exist
     * @param chat_id Identifier of the chat the message belongs to
     */
    public async Message get_chat_pinned_message (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new GetChatPinnedMessage (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_pinned_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Message out_obj;
        switch (tdlib_type) {
            case "message":
                out_obj = (Message) jsoner.deserialize_object (typeof (Message));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a message with the callback button that
     * originated a callback query; for bots only
     * @param chat_id Identifier of the chat the message belongs to
     * @param message_id Message identifier
     * @param callback_query_id Identifier of the callback query
     */
    public async Message get_callback_query_message (
        int64 chat_id,
        int64 message_id,
        int64 callback_query_id
    ) throws BadStatusCodeError {
        var obj = new GetCallbackQueryMessage (
            chat_id,
            message_id,
            callback_query_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_callback_query_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Message out_obj;
        switch (tdlib_type) {
            case "message":
                out_obj = (Message) jsoner.deserialize_object (typeof (Message));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about messages. If a message is not found, returns
     * null on the corresponding position of the result
     * @param chat_id Identifier of the chat the messages belong to
     * @param message_ids Identifiers of the messages to get
     */
    public async Messages get_messages (
        int64 chat_id,
        Gee.ArrayList<int64?> message_ids
    ) throws BadStatusCodeError {
        var obj = new GetMessages (
            chat_id,
            message_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Messages out_obj;
        switch (tdlib_type) {
            case "messages":
                out_obj = (Messages) jsoner.deserialize_object (typeof (Messages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns properties of a message; this is an offline request
     * @param chat_id Chat identifier
     * @param message_id Identifier of the message
     */
    public async MessageProperties get_message_properties (
        int64 chat_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new GetMessageProperties (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_properties.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        MessageProperties out_obj;
        switch (tdlib_type) {
            case "messageProperties":
                out_obj = (MessageProperties) jsoner.deserialize_object (typeof (MessageProperties));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a message thread. Can be used only if
     * messageProperties.can_get_message_thread == true
     * @param chat_id Chat identifier
     * @param message_id Identifier of the message
     */
    public async MessageThreadInfo get_message_thread (
        int64 chat_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new GetMessageThread (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_thread.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        MessageThreadInfo out_obj;
        switch (tdlib_type) {
            case "messageThreadInfo":
                out_obj = (MessageThreadInfo) jsoner.deserialize_object (typeof (MessageThreadInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns read date of a recent outgoing message in a private chat. The
     * method can be called if messageProperties.can_get_read_date == true
     * @param chat_id Chat identifier
     * @param message_id Identifier of the message
     */
    public async MessageReadDate get_message_read_date (
        int64 chat_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new GetMessageReadDate (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_read_date.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        MessageReadDate out_obj;
        switch (tdlib_type) {
            case "messageReadDateRead":
                out_obj = (MessageReadDateRead) jsoner.deserialize_object (typeof (MessageReadDateRead));
                break;
            case "messageReadDateUnread":
                out_obj = (MessageReadDateUnread) jsoner.deserialize_object (typeof (MessageReadDateUnread));
                break;
            case "messageReadDateTooOld":
                out_obj = (MessageReadDateTooOld) jsoner.deserialize_object (typeof (MessageReadDateTooOld));
                break;
            case "messageReadDateUserPrivacyRestricted":
                out_obj = (MessageReadDateUserPrivacyRestricted) jsoner.deserialize_object (typeof (MessageReadDateUserPrivacyRestricted));
                break;
            case "messageReadDateMyPrivacyRestricted":
                out_obj = (MessageReadDateMyPrivacyRestricted) jsoner.deserialize_object (typeof (MessageReadDateMyPrivacyRestricted));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns viewers of a recent outgoing message in a basic group or a
     * supergroup chat. For video notes and voice notes only users, opened
     * content of the message, are returned. The method can be called if
     * messageProperties.can_get_viewers == true
     * @param chat_id Chat identifier
     * @param message_id Identifier of the message
     */
    public async MessageViewers get_message_viewers (
        int64 chat_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new GetMessageViewers (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_viewers.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        MessageViewers out_obj;
        switch (tdlib_type) {
            case "messageViewers":
                out_obj = (MessageViewers) jsoner.deserialize_object (typeof (MessageViewers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a file; this is an offline request
     * @param file_id Identifier of the file to get
     */
    public async File get_file (
        int32 file_id
    ) throws BadStatusCodeError {
        var obj = new GetFile (
            file_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_file.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        File out_obj;
        switch (tdlib_type) {
            case "file":
                out_obj = (File) jsoner.deserialize_object (typeof (File));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a file by its remote identifier; this is an
     * offline request. Can be used to register a URL as a file for further
     * uploading, or sending as a message. Even the request succeeds, the
     * file can be used only if it is still accessible to the user.
     * For example, if the file is from a message, then the message must be
     * not deleted and accessible to the user. If the file database is
     * disabled, then the corresponding object with the file must be
     * preloaded by the application
     * @param remote_file_id Remote identifier of the file to get
     * @param file_type File type; pass null if unknown
     */
    public async File get_remote_file (
        string remote_file_id,
        FileType file_type
    ) throws BadStatusCodeError {
        var obj = new GetRemoteFile (
            remote_file_id,
            file_type
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_remote_file.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        File out_obj;
        switch (tdlib_type) {
            case "file":
                out_obj = (File) jsoner.deserialize_object (typeof (File));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Loads more chats from a chat list. The loaded chats and their
     * positions in the chat list will be sent through updates. Chats are
     * sorted by the pair (chat.position.order, chat.id) in descending order.
     * Returns a 404 error if all chats have been loaded
     * @param chat_list The chat list in which to load chats; pass null to
     * load chats from the main chat list
     * @param limit The maximum number of chats to be loaded. For optimal
     * performance, the number of loaded chats is chosen by TDLib and can be
     * smaller than the specified limit, even if the end of the list is not
     * reached
     */
    public async Ok load_chats (
        ChatList chat_list,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new LoadChats (
            chat_list,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (load_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an ordered list of chats from the beginning of a chat list.
     * For informational purposes only. Use loadChats and updates processing
     * instead to maintain chat lists in a consistent state
     * @param chat_list The chat list in which to return chats; pass null to
     * get chats from the main chat list
     * @param limit The maximum number of chats to be returned
     */
    public async Chats get_chats (
        ChatList chat_list,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetChats (
            chat_list,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches a public chat by its username. Currently, only private chats,
     * supergroups and channels can be public. Returns the chat if found;
     * otherwise, an error is returned
     * @param username Username to be resolved
     */
    public async Chat search_public_chat (
        string username
    ) throws BadStatusCodeError {
        var obj = new SearchPublicChat (
            username
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_public_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chat out_obj;
        switch (tdlib_type) {
            case "chat":
                out_obj = (Chat) jsoner.deserialize_object (typeof (Chat));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches public chats by looking for specified query in their username
     * and title. Currently, only private chats, supergroups and channels can
     * be public. Returns a meaningful number of results.
     * Excludes private chats with contacts and chats from the chat list from
     * the results
     * @param query Query to search for
     */
    public async Chats search_public_chats (
        string query
    ) throws BadStatusCodeError {
        var obj = new SearchPublicChats (
            query
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_public_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for the specified query in the title and username of already
     * known chats; this is an offline request. Returns chats in the order
     * seen in the main chat list
     * @param query Query to search for. If the query is empty, returns up to
     * 50 recently found chats
     * @param limit The maximum number of chats to be returned
     */
    public async Chats search_chats (
        string query,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new SearchChats (
            query,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for the specified query in the title and username of already
     * known chats via request to the server. Returns chats in the order seen
     * in the main chat list
     * @param query Query to search for
     * @param limit The maximum number of chats to be returned
     */
    public async Chats search_chats_on_server (
        string query,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new SearchChatsOnServer (
            query,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_chats_on_server.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a list of channel chats recommended to the current user
     */
    public async Chats get_recommended_chats () throws BadStatusCodeError {
        var obj = new GetRecommendedChats ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_recommended_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a list of chats similar to the given chat
     * @param chat_id Identifier of the target chat; must be an identifier of
     * a channel chat
     */
    public async Chats get_chat_similar_chats (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new GetChatSimilarChats (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_similar_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns approximate number of chats similar to the given chat
     * @param chat_id Identifier of the target chat; must be an identifier of
     * a channel chat
     * @param return_local Pass true to get the number of chats without
     * sending network requests, or -1 if the number of chats is unknown
     * locally
     */
    public async Count get_chat_similar_chat_count (
        int64 chat_id,
        bool return_local
    ) throws BadStatusCodeError {
        var obj = new GetChatSimilarChatCount (
            chat_id,
            return_local
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_similar_chat_count.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Count out_obj;
        switch (tdlib_type) {
            case "count":
                out_obj = (Count) jsoner.deserialize_object (typeof (Count));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs TDLib that a chat was opened from the list of similar chats.
     * The method is independent of openChat and closeChat methods
     * @param chat_id Identifier of the original chat, which similar chats
     * were requested
     * @param opened_chat_id Identifier of the opened chat
     */
    public async Ok open_chat_similar_chat (
        int64 chat_id,
        int64 opened_chat_id
    ) throws BadStatusCodeError {
        var obj = new OpenChatSimilarChat (
            chat_id,
            opened_chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (open_chat_similar_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a list of frequently used chats
     * @param category Category of chats to be returned
     * @param limit The maximum number of chats to be returned; up to 30
     */
    public async Chats get_top_chats (
        TopChatCategory category,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetTopChats (
            category,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_top_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes a chat from the list of frequently used chats. Supported only
     * if the chat info database is enabled
     * @param category Category of frequently used chats
     * @param chat_id Chat identifier
     */
    public async Ok remove_top_chat (
        TopChatCategory category,
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new RemoveTopChat (
            category,
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_top_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for the specified query in the title and username of up to 50
     * recently found chats; this is an offline request
     * @param query Query to search for
     * @param limit The maximum number of chats to be returned
     */
    public async Chats search_recently_found_chats (
        string query,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new SearchRecentlyFoundChats (
            query,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_recently_found_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a chat to the list of recently found chats. The chat is added to
     * the beginning of the list. If the chat is already in the list, it will
     * be removed from the list first
     * @param chat_id Identifier of the chat to add
     */
    public async Ok add_recently_found_chat (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new AddRecentlyFoundChat (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_recently_found_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes a chat from the list of recently found chats
     * @param chat_id Identifier of the chat to be removed
     */
    public async Ok remove_recently_found_chat (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new RemoveRecentlyFoundChat (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_recently_found_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Clears the list of recently found chats
     */
    public async Ok clear_recently_found_chats () throws BadStatusCodeError {
        var obj = new ClearRecentlyFoundChats ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clear_recently_found_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns recently opened chats; this is an offline request. Returns
     * chats in the order of last opening
     * @param limit The maximum number of chats to be returned
     */
    public async Chats get_recently_opened_chats (
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetRecentlyOpenedChats (
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_recently_opened_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks whether a username can be set for a chat
     * @param chat_id Chat identifier; must be identifier of a supergroup
     * chat, or a channel chat, or a private chat with self, or 0 if the chat
     * is being created
     * @param username Username to be checked
     */
    public async CheckChatUsernameResult check_chat_username (
        int64 chat_id,
        string username
    ) throws BadStatusCodeError {
        var obj = new CheckChatUsername (
            chat_id,
            username
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_chat_username.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        CheckChatUsernameResult out_obj;
        switch (tdlib_type) {
            case "checkChatUsernameResultOk":
                out_obj = (CheckChatUsernameResultOk) jsoner.deserialize_object (typeof (CheckChatUsernameResultOk));
                break;
            case "checkChatUsernameResultUsernameInvalid":
                out_obj = (CheckChatUsernameResultUsernameInvalid) jsoner.deserialize_object (typeof (CheckChatUsernameResultUsernameInvalid));
                break;
            case "checkChatUsernameResultUsernameOccupied":
                out_obj = (CheckChatUsernameResultUsernameOccupied) jsoner.deserialize_object (typeof (CheckChatUsernameResultUsernameOccupied));
                break;
            case "checkChatUsernameResultUsernamePurchasable":
                out_obj = (CheckChatUsernameResultUsernamePurchasable) jsoner.deserialize_object (typeof (CheckChatUsernameResultUsernamePurchasable));
                break;
            case "checkChatUsernameResultPublicChatsTooMany":
                out_obj = (CheckChatUsernameResultPublicChatsTooMany) jsoner.deserialize_object (typeof (CheckChatUsernameResultPublicChatsTooMany));
                break;
            case "checkChatUsernameResultPublicGroupsUnavailable":
                out_obj = (CheckChatUsernameResultPublicGroupsUnavailable) jsoner.deserialize_object (typeof (CheckChatUsernameResultPublicGroupsUnavailable));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a list of public chats of the specified type, owned by the
     * user
     * @param type_ Type of the public chats to return
     */
    public async Chats get_created_public_chats (
        PublicChatType type_
    ) throws BadStatusCodeError {
        var obj = new GetCreatedPublicChats (
            type_
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_created_public_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks whether the maximum number of owned public chats has been
     * reached. Returns corresponding error if the limit was reached. The
     * limit can be increased with Telegram Premium
     * @param type_ Type of the public chats, for which to check the limit
     */
    public async Ok check_created_public_chats_limit (
        PublicChatType type_
    ) throws BadStatusCodeError {
        var obj = new CheckCreatedPublicChatsLimit (
            type_
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_created_public_chats_limit.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a list of basic group and supergroup chats, which can be used
     * as a discussion group for a channel. Returned basic group chats must
     * be first upgraded to supergroups before they can be set as a
     * discussion group.
     * To set a returned supergroup as a discussion group, access to its old
     * messages must be enabled using toggleSupergroupIsAllHistoryAvailable
     * first
     */
    public async Chats get_suitable_discussion_chats () throws BadStatusCodeError {
        var obj = new GetSuitableDiscussionChats ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_suitable_discussion_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a list of recently inactive supergroups and channels. Can be
     * used when user reaches limit on the number of joined supergroups and
     * channels and receives CHANNELS_TOO_MUCH error. Also, the limit can be
     * increased with Telegram Premium
     */
    public async Chats get_inactive_supergroup_chats () throws BadStatusCodeError {
        var obj = new GetInactiveSupergroupChats ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_inactive_supergroup_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a list of channel chats, which can be used as a personal chat
     */
    public async Chats get_suitable_personal_chats () throws BadStatusCodeError {
        var obj = new GetSuitablePersonalChats ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_suitable_personal_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Loads more Saved Messages topics. The loaded topics will be sent
     * through updateSavedMessagesTopic. Topics are sorted by their
     * topic.order in descending order. Returns a 404 error if all topics
     * have been loaded
     * @param limit The maximum number of topics to be loaded. For optimal
     * performance, the number of loaded topics is chosen by TDLib and can be
     * smaller than the specified limit, even if the end of the list is not
     * reached
     */
    public async Ok load_saved_messages_topics (
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new LoadSavedMessagesTopics (
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (load_saved_messages_topics.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns messages in a Saved Messages topic. The messages are returned
     * in reverse chronological order (i.e., in order of decreasing
     * message_id)
     * @param saved_messages_topic_id Identifier of Saved Messages topic
     * which messages will be fetched
     * @param from_message_id Identifier of the message starting from which
     * messages must be fetched; use 0 to get results from the last message
     * @param offset Specify 0 to get results from exactly the message
     * from_message_id or a negative offset up to 99 to get additionally some
     * newer messages
     * @param limit The maximum number of messages to be returned; must be
     * positive and can't be greater than 100. If the offset is negative, the
     * limit must be greater than or equal to -offset. For optimal
     * performance, the number of returned messages is chosen by TDLib and
     * can be smaller than the specified limit
     */
    public async Messages get_saved_messages_topic_history (
        int64 saved_messages_topic_id,
        int64 from_message_id,
        int32 offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetSavedMessagesTopicHistory (
            saved_messages_topic_id,
            from_message_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_saved_messages_topic_history.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Messages out_obj;
        switch (tdlib_type) {
            case "messages":
                out_obj = (Messages) jsoner.deserialize_object (typeof (Messages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the last message sent in a Saved Messages topic no later than
     * the specified date
     * @param saved_messages_topic_id Identifier of Saved Messages topic
     * which message will be returned
     * @param date Point in time (Unix timestamp) relative to which to search
     * for messages
     */
    public async Message get_saved_messages_topic_message_by_date (
        int64 saved_messages_topic_id,
        int32 date
    ) throws BadStatusCodeError {
        var obj = new GetSavedMessagesTopicMessageByDate (
            saved_messages_topic_id,
            date
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_saved_messages_topic_message_by_date.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Message out_obj;
        switch (tdlib_type) {
            case "message":
                out_obj = (Message) jsoner.deserialize_object (typeof (Message));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes all messages in a Saved Messages topic
     * @param saved_messages_topic_id Identifier of Saved Messages topic
     * which messages will be deleted
     */
    public async Ok delete_saved_messages_topic_history (
        int64 saved_messages_topic_id
    ) throws BadStatusCodeError {
        var obj = new DeleteSavedMessagesTopicHistory (
            saved_messages_topic_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_saved_messages_topic_history.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes all messages between the specified dates in a Saved Messages
     * topic. Messages sent in the last 30 seconds will not be deleted
     * @param saved_messages_topic_id Identifier of Saved Messages topic
     * which messages will be deleted
     * @param min_date The minimum date of the messages to delete
     * @param max_date The maximum date of the messages to delete
     */
    public async Ok delete_saved_messages_topic_messages_by_date (
        int64 saved_messages_topic_id,
        int32 min_date,
        int32 max_date
    ) throws BadStatusCodeError {
        var obj = new DeleteSavedMessagesTopicMessagesByDate (
            saved_messages_topic_id,
            min_date,
            max_date
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_saved_messages_topic_messages_by_date.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the pinned state of a Saved Messages topic. There can be up to
     * getOption("pinned_saved_messages_topic_count_max") pinned topics. The
     * limit can be increased with Telegram Premium
     * @param saved_messages_topic_id Identifier of Saved Messages topic to
     * pin or unpin
     * @param is_pinned Pass true to pin the topic; pass false to unpin it
     */
    public async Ok toggle_saved_messages_topic_is_pinned (
        int64 saved_messages_topic_id,
        bool is_pinned
    ) throws BadStatusCodeError {
        var obj = new ToggleSavedMessagesTopicIsPinned (
            saved_messages_topic_id,
            is_pinned
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_saved_messages_topic_is_pinned.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the order of pinned Saved Messages topics
     * @param saved_messages_topic_ids Identifiers of the new pinned Saved
     * Messages topics
     */
    public async Ok set_pinned_saved_messages_topics (
        Gee.ArrayList<int64?> saved_messages_topic_ids
    ) throws BadStatusCodeError {
        var obj = new SetPinnedSavedMessagesTopics (
            saved_messages_topic_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_pinned_saved_messages_topics.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a list of common group chats with a given user. Chats are
     * sorted by their type and creation date
     * @param user_id User identifier
     * @param offset_chat_id Chat identifier starting from which to return
     * chats; use 0 for the first request
     * @param limit The maximum number of chats to be returned; up to 100
     */
    public async Chats get_groups_in_common (
        int64 user_id,
        int64 offset_chat_id,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetGroupsInCommon (
            user_id,
            offset_chat_id,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_groups_in_common.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns messages in a chat. The messages are returned in reverse
     * chronological order (i.e., in order of decreasing message_id).
     * For optimal performance, the number of returned messages is chosen by
     * TDLib. This is an offline request if only_local is true
     * @param chat_id Chat identifier
     * @param from_message_id Identifier of the message starting from which
     * history must be fetched; use 0 to get results from the last message
     * @param offset Specify 0 to get results from exactly the message
     * from_message_id or a negative offset up to 99 to get additionally some
     * newer messages
     * @param limit The maximum number of messages to be returned; must be
     * positive and can't be greater than 100. If the offset is negative, the
     * limit must be greater than or equal to -offset. For optimal
     * performance, the number of returned messages is chosen by TDLib and
     * can be smaller than the specified limit
     * @param only_local Pass true to get only messages that are available
     * without sending network requests
     */
    public async Messages get_chat_history (
        int64 chat_id,
        int64 from_message_id,
        int32 offset,
        int32 limit,
        bool only_local
    ) throws BadStatusCodeError {
        var obj = new GetChatHistory (
            chat_id,
            from_message_id,
            offset,
            limit,
            only_local
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_history.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Messages out_obj;
        switch (tdlib_type) {
            case "messages":
                out_obj = (Messages) jsoner.deserialize_object (typeof (Messages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns messages in a message thread of a message. Can be used only if
     * messageProperties.can_get_message_thread == true. Message thread of a
     * channel message is in the channel's linked supergroup.
     * The messages are returned in reverse chronological order (i.e., in
     * order of decreasing message_id). For optimal performance, the number
     * of returned messages is chosen by TDLib
     * @param chat_id Chat identifier
     * @param message_id Message identifier, which thread history needs to be
     * returned
     * @param from_message_id Identifier of the message starting from which
     * history must be fetched; use 0 to get results from the last message
     * @param offset Specify 0 to get results from exactly the message
     * from_message_id or a negative offset up to 99 to get additionally some
     * newer messages
     * @param limit The maximum number of messages to be returned; must be
     * positive and can't be greater than 100. If the offset is negative, the
     * limit must be greater than or equal to -offset. For optimal
     * performance, the number of returned messages is chosen by TDLib and
     * can be smaller than the specified limit
     */
    public async Messages get_message_thread_history (
        int64 chat_id,
        int64 message_id,
        int64 from_message_id,
        int32 offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetMessageThreadHistory (
            chat_id,
            message_id,
            from_message_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_thread_history.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Messages out_obj;
        switch (tdlib_type) {
            case "messages":
                out_obj = (Messages) jsoner.deserialize_object (typeof (Messages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes all messages in the chat. Use
     * chat.can_be_deleted_only_for_self and
     * chat.can_be_deleted_for_all_users fields to find whether and how the
     * method can be applied to the chat
     * @param chat_id Chat identifier
     * @param remove_from_chat_list Pass true to remove the chat from all
     * chat lists
     * @param revoke Pass true to delete chat history for all users
     */
    public async Ok delete_chat_history (
        int64 chat_id,
        bool remove_from_chat_list,
        bool revoke
    ) throws BadStatusCodeError {
        var obj = new DeleteChatHistory (
            chat_id,
            remove_from_chat_list,
            revoke
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_chat_history.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes a chat along with all messages in the corresponding chat for
     * all chat members. For group chats this will release the usernames and
     * remove all members.
     * Use the field chat.can_be_deleted_for_all_users to find whether the
     * method can be applied to the chat
     * @param chat_id Chat identifier
     */
    public async Ok delete_chat (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new DeleteChat (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for messages with given words in the chat. Returns the
     * results in reverse chronological order, i.e. in order of decreasing
     * message_id. Cannot be used in secret chats with a non-empty query
     * (searchSecretMessages must be used instead), or without an enabled
     * message database. For optimal performance, the number of returned
     * messages is chosen by TDLib and can be smaller than the specified
     * limit.
     * A combination of query, sender_id, filter and message_thread_id search
     * criteria is expected to be supported, only if it is required for
     * Telegram official application implementation
     * @param chat_id Identifier of the chat in which to search messages
     * @param query Query to search for
     * @param sender_id Identifier of the sender of messages to search for;
     * pass null to search for messages from any sender. Not supported in
     * secret chats
     * @param from_message_id Identifier of the message starting from which
     * history must be fetched; use 0 to get results from the last message
     * @param offset Specify 0 to get results from exactly the message
     * from_message_id or a negative offset to get the specified message and
     * some newer messages
     * @param limit The maximum number of messages to be returned; must be
     * positive and can't be greater than 100. If the offset is negative, the
     * limit must be greater than -offset. For optimal performance, the
     * number of returned messages is chosen by TDLib and can be smaller than
     * the specified limit
     * @param filter Additional filter for messages to search; pass null to
     * search for all messages
     * @param message_thread_id If not 0, only messages in the specified
     * thread will be returned; supergroups only
     * @param saved_messages_topic_id If not 0, only messages in the
     * specified Saved Messages topic will be returned; pass 0 to return all
     * messages, or for chats other than Saved Messages
     */
    public async FoundChatMessages search_chat_messages (
        int64 chat_id,
        string query,
        MessageSender sender_id,
        int64 from_message_id,
        int32 offset,
        int32 limit,
        SearchMessagesFilter filter,
        int64 message_thread_id,
        int64 saved_messages_topic_id
    ) throws BadStatusCodeError {
        var obj = new SearchChatMessages (
            chat_id,
            query,
            sender_id,
            from_message_id,
            offset,
            limit,
            filter,
            message_thread_id,
            saved_messages_topic_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_chat_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundChatMessages out_obj;
        switch (tdlib_type) {
            case "foundChatMessages":
                out_obj = (FoundChatMessages) jsoner.deserialize_object (typeof (FoundChatMessages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for messages in all chats except secret chats. Returns the
     * results in reverse chronological order (i.e., in order of decreasing
     * (date, chat_id, message_id)).
     * For optimal performance, the number of returned messages is chosen by
     * TDLib and can be smaller than the specified limit
     * @param chat_list Chat list in which to search messages; pass null to
     * search in all chats regardless of their chat list. Only Main and
     * Archive chat lists are supported
     * @param only_in_channels Pass true to search only for messages in
     * channels
     * @param query Query to search for
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of messages to be returned; up to 100.
     * For optimal performance, the number of returned messages is chosen by
     * TDLib and can be smaller than the specified limit
     * @param filter Additional filter for messages to search; pass null to
     * search for all messages. Filters searchMessagesFilterMention,
     * searchMessagesFilterUnreadMention, searchMessagesFilterUnreadReaction,
     * searchMessagesFilterFailedToSend, and searchMessagesFilterPinned are
     * unsupported in this function
     * @param min_date If not 0, the minimum date of the messages to return
     * @param max_date If not 0, the maximum date of the messages to return
     */
    public async FoundMessages search_messages (
        ChatList chat_list,
        bool only_in_channels,
        string query,
        string offset,
        int32 limit,
        SearchMessagesFilter filter,
        int32 min_date,
        int32 max_date
    ) throws BadStatusCodeError {
        var obj = new SearchMessages (
            chat_list,
            only_in_channels,
            query,
            offset,
            limit,
            filter,
            min_date,
            max_date
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundMessages out_obj;
        switch (tdlib_type) {
            case "foundMessages":
                out_obj = (FoundMessages) jsoner.deserialize_object (typeof (FoundMessages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for messages in secret chats. Returns the results in reverse
     * chronological order. For optimal performance, the number of returned
     * messages is chosen by TDLib
     * @param chat_id Identifier of the chat in which to search. Specify 0 to
     * search in all secret chats
     * @param query Query to search for. If empty, searchChatMessages must be
     * used instead
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of messages to be returned; up to 100.
     * For optimal performance, the number of returned messages is chosen by
     * TDLib and can be smaller than the specified limit
     * @param filter Additional filter for messages to search; pass null to
     * search for all messages
     */
    public async FoundMessages search_secret_messages (
        int64 chat_id,
        string query,
        string offset,
        int32 limit,
        SearchMessagesFilter filter
    ) throws BadStatusCodeError {
        var obj = new SearchSecretMessages (
            chat_id,
            query,
            offset,
            limit,
            filter
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_secret_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundMessages out_obj;
        switch (tdlib_type) {
            case "foundMessages":
                out_obj = (FoundMessages) jsoner.deserialize_object (typeof (FoundMessages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for messages tagged by the given reaction and with the given
     * words in the Saved Messages chat; for Telegram Premium users only.
     * Returns the results in reverse chronological order, i.e. in order of
     * decreasing message_id.
     * For optimal performance, the number of returned messages is chosen by
     * TDLib and can be smaller than the specified limit
     * @param saved_messages_topic_id If not 0, only messages in the
     * specified Saved Messages topic will be considered; pass 0 to consider
     * all messages
     * @param tag Tag to search for; pass null to return all suitable
     * messages
     * @param query Query to search for
     * @param from_message_id Identifier of the message starting from which
     * messages must be fetched; use 0 to get results from the last message
     * @param offset Specify 0 to get results from exactly the message
     * from_message_id or a negative offset to get the specified message and
     * some newer messages
     * @param limit The maximum number of messages to be returned; must be
     * positive and can't be greater than 100. If the offset is negative, the
     * limit must be greater than -offset. For optimal performance, the
     * number of returned messages is chosen by TDLib and can be smaller than
     * the specified limit
     */
    public async FoundChatMessages search_saved_messages (
        int64 saved_messages_topic_id,
        ReactionType tag,
        string query,
        int64 from_message_id,
        int32 offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new SearchSavedMessages (
            saved_messages_topic_id,
            tag,
            query,
            from_message_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_saved_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundChatMessages out_obj;
        switch (tdlib_type) {
            case "foundChatMessages":
                out_obj = (FoundChatMessages) jsoner.deserialize_object (typeof (FoundChatMessages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for call messages. Returns the results in reverse
     * chronological order (i.e., in order of decreasing message_id). For
     * optimal performance, the number of returned messages is chosen by
     * TDLib
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of messages to be returned; up to 100.
     * For optimal performance, the number of returned messages is chosen by
     * TDLib and can be smaller than the specified limit
     * @param only_missed Pass true to search only for messages with
     * missed/declined calls
     */
    public async FoundMessages search_call_messages (
        string offset,
        int32 limit,
        bool only_missed
    ) throws BadStatusCodeError {
        var obj = new SearchCallMessages (
            offset,
            limit,
            only_missed
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_call_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundMessages out_obj;
        switch (tdlib_type) {
            case "foundMessages":
                out_obj = (FoundMessages) jsoner.deserialize_object (typeof (FoundMessages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for outgoing messages with content of the type
     * messageDocument in all chats except secret chats. Returns the results
     * in reverse chronological order
     * @param query Query to search for in document file name and message
     * caption
     * @param limit The maximum number of messages to be returned; up to 100
     */
    public async FoundMessages search_outgoing_document_messages (
        string query,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new SearchOutgoingDocumentMessages (
            query,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_outgoing_document_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundMessages out_obj;
        switch (tdlib_type) {
            case "foundMessages":
                out_obj = (FoundMessages) jsoner.deserialize_object (typeof (FoundMessages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for public channel posts containing the given hashtag or
     * cashtag. For optimal performance, the number of returned messages is
     * chosen by TDLib and can be smaller than the specified limit
     * @param tag Hashtag or cashtag to search for
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of messages to be returned; up to 100.
     * For optimal performance, the number of returned messages is chosen by
     * TDLib and can be smaller than the specified limit
     */
    public async FoundMessages search_public_messages_by_tag (
        string tag,
        string offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new SearchPublicMessagesByTag (
            tag,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_public_messages_by_tag.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundMessages out_obj;
        switch (tdlib_type) {
            case "foundMessages":
                out_obj = (FoundMessages) jsoner.deserialize_object (typeof (FoundMessages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for public stories containing the given hashtag or cashtag.
     * For optimal performance, the number of returned stories is chosen by
     * TDLib and can be smaller than the specified limit
     * @param story_sender_chat_id Identifier of the chat that posted the
     * stories to search for; pass 0 to search stories in all chats
     * @param tag Hashtag or cashtag to search for
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of stories to be returned; up to 100.
     * For optimal performance, the number of returned stories is chosen by
     * TDLib and can be smaller than the specified limit
     */
    public async FoundStories search_public_stories_by_tag (
        int64 story_sender_chat_id,
        string tag,
        string offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new SearchPublicStoriesByTag (
            story_sender_chat_id,
            tag,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_public_stories_by_tag.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundStories out_obj;
        switch (tdlib_type) {
            case "foundStories":
                out_obj = (FoundStories) jsoner.deserialize_object (typeof (FoundStories));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for public stories by the given address location. For optimal
     * performance, the number of returned stories is chosen by TDLib and can
     * be smaller than the specified limit
     * @param address Address of the location
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of stories to be returned; up to 100.
     * For optimal performance, the number of returned stories is chosen by
     * TDLib and can be smaller than the specified limit
     */
    public async FoundStories search_public_stories_by_location (
        LocationAddress address,
        string offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new SearchPublicStoriesByLocation (
            address,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_public_stories_by_location.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundStories out_obj;
        switch (tdlib_type) {
            case "foundStories":
                out_obj = (FoundStories) jsoner.deserialize_object (typeof (FoundStories));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for public stories from the given venue. For optimal
     * performance, the number of returned stories is chosen by TDLib and can
     * be smaller than the specified limit
     * @param venue_provider Provider of the venue
     * @param venue_id Identifier of the venue in the provider database
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of stories to be returned; up to 100.
     * For optimal performance, the number of returned stories is chosen by
     * TDLib and can be smaller than the specified limit
     */
    public async FoundStories search_public_stories_by_venue (
        string venue_provider,
        string venue_id,
        string offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new SearchPublicStoriesByVenue (
            venue_provider,
            venue_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_public_stories_by_venue.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundStories out_obj;
        switch (tdlib_type) {
            case "foundStories":
                out_obj = (FoundStories) jsoner.deserialize_object (typeof (FoundStories));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns recently searched for hashtags or cashtags by their prefix
     * @param tag_prefix Prefix of hashtags or cashtags to return
     * @param limit The maximum number of items to be returned
     */
    public async Hashtags get_searched_for_tags (
        string tag_prefix,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetSearchedForTags (
            tag_prefix,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_searched_for_tags.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Hashtags out_obj;
        switch (tdlib_type) {
            case "hashtags":
                out_obj = (Hashtags) jsoner.deserialize_object (typeof (Hashtags));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes a hashtag or a cashtag from the list of recently searched for
     * hashtags or cashtags
     * @param tag Hashtag or cashtag to delete
     */
    public async Ok remove_searched_for_tag (
        string tag
    ) throws BadStatusCodeError {
        var obj = new RemoveSearchedForTag (
            tag
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_searched_for_tag.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Clears the list of recently searched for hashtags or cashtags
     * @param clear_cashtags Pass true to clear the list of recently searched
     * for cashtags; otherwise, the list of recently searched for hashtags
     * will be cleared
     */
    public async Ok clear_searched_for_tags (
        bool clear_cashtags
    ) throws BadStatusCodeError {
        var obj = new ClearSearchedForTags (
            clear_cashtags
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clear_searched_for_tags.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes all call messages
     * @param revoke Pass true to delete the messages for all users
     */
    public async Ok delete_all_call_messages (
        bool revoke
    ) throws BadStatusCodeError {
        var obj = new DeleteAllCallMessages (
            revoke
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_all_call_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about the recent locations of chat members that
     * were sent to the chat. Returns up to 1 location message per user
     * @param chat_id Chat identifier
     * @param limit The maximum number of messages to be returned
     */
    public async Messages search_chat_recent_location_messages (
        int64 chat_id,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new SearchChatRecentLocationMessages (
            chat_id,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_chat_recent_location_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Messages out_obj;
        switch (tdlib_type) {
            case "messages":
                out_obj = (Messages) jsoner.deserialize_object (typeof (Messages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the last message sent in a chat no later than the specified
     * date. Returns a 404 error if such message doesn't exist
     * @param chat_id Chat identifier
     * @param date Point in time (Unix timestamp) relative to which to search
     * for messages
     */
    public async Message get_chat_message_by_date (
        int64 chat_id,
        int32 date
    ) throws BadStatusCodeError {
        var obj = new GetChatMessageByDate (
            chat_id,
            date
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_message_by_date.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Message out_obj;
        switch (tdlib_type) {
            case "message":
                out_obj = (Message) jsoner.deserialize_object (typeof (Message));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns sparse positions of messages of the specified type in the chat
     * to be used for shared media scroll implementation. Returns the results
     * in reverse chronological order (i.e., in order of decreasing
     * message_id).
     * Cannot be used in secret chats or with
     * searchMessagesFilterFailedToSend filter without an enabled message
     * database
     * @param chat_id Identifier of the chat in which to return information
     * about message positions
     * @param filter Filter for message content. Filters
     * searchMessagesFilterEmpty, searchMessagesFilterMention,
     * searchMessagesFilterUnreadMention, and
     * searchMessagesFilterUnreadReaction are unsupported in this function
     * @param from_message_id The message identifier from which to return
     * information about message positions
     * @param limit The expected number of message positions to be returned;
     * 50-2000. A smaller number of positions can be returned, if there are
     * not enough appropriate messages
     * @param saved_messages_topic_id If not 0, only messages in the
     * specified Saved Messages topic will be considered; pass 0 to consider
     * all messages, or for chats other than Saved Messages
     */
    public async MessagePositions get_chat_sparse_message_positions (
        int64 chat_id,
        SearchMessagesFilter filter,
        int64 from_message_id,
        int32 limit,
        int64 saved_messages_topic_id
    ) throws BadStatusCodeError {
        var obj = new GetChatSparseMessagePositions (
            chat_id,
            filter,
            from_message_id,
            limit,
            saved_messages_topic_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_sparse_message_positions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        MessagePositions out_obj;
        switch (tdlib_type) {
            case "messagePositions":
                out_obj = (MessagePositions) jsoner.deserialize_object (typeof (MessagePositions));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about the next messages of the specified type in
     * the chat split by days. Returns the results in reverse chronological
     * order. Can return partial result for the last returned day. Behavior
     * of this method depends on the value of the option "utc_time_offset"
     * @param chat_id Identifier of the chat in which to return information
     * about messages
     * @param filter Filter for message content. Filters
     * searchMessagesFilterEmpty, searchMessagesFilterMention,
     * searchMessagesFilterUnreadMention, and
     * searchMessagesFilterUnreadReaction are unsupported in this function
     * @param from_message_id The message identifier from which to return
     * information about messages; use 0 to get results from the last message
     * @param saved_messages_topic_id If not0, only messages in the specified
     * Saved Messages topic will be considered; pass 0 to consider all
     * messages, or for chats other than Saved Messages
     */
    public async MessageCalendar get_chat_message_calendar (
        int64 chat_id,
        SearchMessagesFilter filter,
        int64 from_message_id,
        int64 saved_messages_topic_id
    ) throws BadStatusCodeError {
        var obj = new GetChatMessageCalendar (
            chat_id,
            filter,
            from_message_id,
            saved_messages_topic_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_message_calendar.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        MessageCalendar out_obj;
        switch (tdlib_type) {
            case "messageCalendar":
                out_obj = (MessageCalendar) jsoner.deserialize_object (typeof (MessageCalendar));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns approximate number of messages of the specified type in the
     * chat
     * @param chat_id Identifier of the chat in which to count messages
     * @param filter Filter for message content; searchMessagesFilterEmpty is
     * unsupported in this function
     * @param saved_messages_topic_id If not 0, only messages in the
     * specified Saved Messages topic will be counted; pass 0 to count all
     * messages, or for chats other than Saved Messages
     * @param return_local Pass true to get the number of messages without
     * sending network requests, or -1 if the number of messages is unknown
     * locally
     */
    public async Count get_chat_message_count (
        int64 chat_id,
        SearchMessagesFilter filter,
        int64 saved_messages_topic_id,
        bool return_local
    ) throws BadStatusCodeError {
        var obj = new GetChatMessageCount (
            chat_id,
            filter,
            saved_messages_topic_id,
            return_local
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_message_count.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Count out_obj;
        switch (tdlib_type) {
            case "count":
                out_obj = (Count) jsoner.deserialize_object (typeof (Count));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns approximate 1-based position of a message among messages,
     * which can be found by the specified filter in the chat. Cannot be used
     * in secret chats
     * @param chat_id Identifier of the chat in which to find message
     * position
     * @param message_id Message identifier
     * @param filter Filter for message content; searchMessagesFilterEmpty,
     * searchMessagesFilterUnreadMention, searchMessagesFilterUnreadReaction,
     * and searchMessagesFilterFailedToSend are unsupported in this function
     * @param message_thread_id If not 0, only messages in the specified
     * thread will be considered; supergroups only
     * @param saved_messages_topic_id If not 0, only messages in the
     * specified Saved Messages topic will be considered; pass 0 to consider
     * all relevant messages, or for chats other than Saved Messages
     */
    public async Count get_chat_message_position (
        int64 chat_id,
        int64 message_id,
        SearchMessagesFilter filter,
        int64 message_thread_id,
        int64 saved_messages_topic_id
    ) throws BadStatusCodeError {
        var obj = new GetChatMessagePosition (
            chat_id,
            message_id,
            filter,
            message_thread_id,
            saved_messages_topic_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_message_position.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Count out_obj;
        switch (tdlib_type) {
            case "count":
                out_obj = (Count) jsoner.deserialize_object (typeof (Count));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns all scheduled messages in a chat. The messages are returned in
     * reverse chronological order (i.e., in order of decreasing message_id)
     * @param chat_id Chat identifier
     */
    public async Messages get_chat_scheduled_messages (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new GetChatScheduledMessages (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_scheduled_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Messages out_obj;
        switch (tdlib_type) {
            case "messages":
                out_obj = (Messages) jsoner.deserialize_object (typeof (Messages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns sponsored messages to be shown in a chat; for channel chats
     * and chats with bots only
     * @param chat_id Identifier of the chat
     */
    public async SponsoredMessages get_chat_sponsored_messages (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new GetChatSponsoredMessages (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_sponsored_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        SponsoredMessages out_obj;
        switch (tdlib_type) {
            case "sponsoredMessages":
                out_obj = (SponsoredMessages) jsoner.deserialize_object (typeof (SponsoredMessages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs TDLib that the user opened the sponsored chat via the button,
     * the name, the chat photo, a mention in the sponsored message text, or
     * the media in the sponsored message
     * @param chat_id Chat identifier of the sponsored message
     * @param message_id Identifier of the sponsored message
     * @param is_media_click Pass true if the media was clicked in the
     * sponsored message
     * @param from_fullscreen Pass true if the user expanded the video from
     * the sponsored message fullscreen before the click
     */
    public async Ok click_chat_sponsored_message (
        int64 chat_id,
        int64 message_id,
        bool is_media_click,
        bool from_fullscreen
    ) throws BadStatusCodeError {
        var obj = new ClickChatSponsoredMessage (
            chat_id,
            message_id,
            is_media_click,
            from_fullscreen
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (click_chat_sponsored_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Reports a sponsored message to Telegram moderators
     * @param chat_id Chat identifier of the sponsored message
     * @param message_id Identifier of the sponsored message
     * @param option_id Option identifier chosen by the user; leave empty for
     * the initial request
     */
    public async ReportChatSponsoredMessageResult report_chat_sponsored_message (
        int64 chat_id,
        int64 message_id,
        Bytes option_id
    ) throws BadStatusCodeError {
        var obj = new ReportChatSponsoredMessage (
            chat_id,
            message_id,
            option_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_chat_sponsored_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ReportChatSponsoredMessageResult out_obj;
        switch (tdlib_type) {
            case "reportChatSponsoredMessageResultOk":
                out_obj = (ReportChatSponsoredMessageResultOk) jsoner.deserialize_object (typeof (ReportChatSponsoredMessageResultOk));
                break;
            case "reportChatSponsoredMessageResultFailed":
                out_obj = (ReportChatSponsoredMessageResultFailed) jsoner.deserialize_object (typeof (ReportChatSponsoredMessageResultFailed));
                break;
            case "reportChatSponsoredMessageResultOptionRequired":
                out_obj = (ReportChatSponsoredMessageResultOptionRequired) jsoner.deserialize_object (typeof (ReportChatSponsoredMessageResultOptionRequired));
                break;
            case "reportChatSponsoredMessageResultAdsHidden":
                out_obj = (ReportChatSponsoredMessageResultAdsHidden) jsoner.deserialize_object (typeof (ReportChatSponsoredMessageResultAdsHidden));
                break;
            case "reportChatSponsoredMessageResultPremiumRequired":
                out_obj = (ReportChatSponsoredMessageResultPremiumRequired) jsoner.deserialize_object (typeof (ReportChatSponsoredMessageResultPremiumRequired));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes an active notification from notification list. Needs to be
     * called only if the notification is removed by the current user
     * @param notification_group_id Identifier of notification group to which
     * the notification belongs
     * @param notification_id Identifier of removed notification
     */
    public async Ok remove_notification (
        int32 notification_group_id,
        int32 notification_id
    ) throws BadStatusCodeError {
        var obj = new RemoveNotification (
            notification_group_id,
            notification_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_notification.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes a group of active notifications. Needs to be called only if
     * the notification group is removed by the current user
     * @param notification_group_id Notification group identifier
     * @param max_notification_id The maximum identifier of removed
     * notifications
     */
    public async Ok remove_notification_group (
        int32 notification_group_id,
        int32 max_notification_id
    ) throws BadStatusCodeError {
        var obj = new RemoveNotificationGroup (
            notification_group_id,
            max_notification_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_notification_group.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an HTTPS link to a message in a chat. Available only if
     * messageProperties.can_get_link, or if
     * messageProperties.can_get_media_timestamp_links and a media timestamp
     * link is generated. This is an offline request
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param media_timestamp If not 0, timestamp from which the
     * video/audio/video note/voice note/story playing must start, in
     * seconds. The media can be in the message content or in its link
     * preview
     * @param for_album Pass true to create a link for the whole media album
     * @param in_message_thread Pass true to create a link to the message as
     * a channel post comment, in a message thread, or a forum topic
     */
    public async MessageLink get_message_link (
        int64 chat_id,
        int64 message_id,
        int32 media_timestamp,
        bool for_album,
        bool in_message_thread
    ) throws BadStatusCodeError {
        var obj = new GetMessageLink (
            chat_id,
            message_id,
            media_timestamp,
            for_album,
            in_message_thread
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        MessageLink out_obj;
        switch (tdlib_type) {
            case "messageLink":
                out_obj = (MessageLink) jsoner.deserialize_object (typeof (MessageLink));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an HTML code for embedding the message. Available only if
     * messageProperties.can_get_embedding_code
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param for_album Pass true to return an HTML code for embedding of the
     * whole media album
     */
    public async Text get_message_embedding_code (
        int64 chat_id,
        int64 message_id,
        bool for_album
    ) throws BadStatusCodeError {
        var obj = new GetMessageEmbeddingCode (
            chat_id,
            message_id,
            for_album
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_embedding_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a public or private message link. Can be
     * called for any internal link of the type internalLinkTypeMessage
     * @param url The message link
     */
    public async MessageLinkInfo get_message_link_info (
        string url
    ) throws BadStatusCodeError {
        var obj = new GetMessageLinkInfo (
            url
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_link_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        MessageLinkInfo out_obj;
        switch (tdlib_type) {
            case "messageLinkInfo":
                out_obj = (MessageLinkInfo) jsoner.deserialize_object (typeof (MessageLinkInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Translates a text to the given language. If the current user is a
     * Telegram Premium user, then text formatting is preserved
     * @param text Text to translate
     * @param to_language_code Language code of the language to which the
     * message is translated. Must be one of "af", "sq", "am", "ar", "hy",
     * "az", "eu", "be", "bn", "bs", "bg", "ca", "ceb", "zh-CN", "zh",
     * "zh-Hans", "zh-TW", "zh-Hant", "co", "hr", "cs", "da", "nl", "en",
     * "eo", "et", "fi", "fr", "fy", "gl", "ka", "de", "el", "gu", "ht",
     * "ha", "haw", "he", "iw", "hi", "hmn", "hu", "is", "ig", "id", "in",
     * "ga", "it", "ja", "jv", "kn", "kk", "km", "rw", "ko", "ku", "ky",
     * "lo", "la", "lv", "lt", "lb", "mk", "mg", "ms", "ml", "mt", "mi",
     * "mr", "mn", "my", "ne", "no", "ny", "or", "ps", "fa", "pl", "pt",
     * "pa", "ro", "ru", "sm", "gd", "sr", "st", "sn", "sd", "si", "sk",
     * "sl", "so", "es", "su", "sw", "sv", "tl", "tg", "ta", "tt", "te",
     * "th", "tr", "tk", "uk", "ur", "ug", "uz", "vi", "cy", "xh", "yi",
     * "ji", "yo", "zu"
     */
    public async FormattedText translate_text (
        FormattedText text,
        string to_language_code
    ) throws BadStatusCodeError {
        var obj = new TranslateText (
            text,
            to_language_code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (translate_text.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FormattedText out_obj;
        switch (tdlib_type) {
            case "formattedText":
                out_obj = (FormattedText) jsoner.deserialize_object (typeof (FormattedText));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Extracts text or caption of the given message and translates it to the
     * given language. If the current user is a Telegram Premium user, then
     * text formatting is preserved
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param to_language_code Language code of the language to which the
     * message is translated. Must be one of "af", "sq", "am", "ar", "hy",
     * "az", "eu", "be", "bn", "bs", "bg", "ca", "ceb", "zh-CN", "zh",
     * "zh-Hans", "zh-TW", "zh-Hant", "co", "hr", "cs", "da", "nl", "en",
     * "eo", "et", "fi", "fr", "fy", "gl", "ka", "de", "el", "gu", "ht",
     * "ha", "haw", "he", "iw", "hi", "hmn", "hu", "is", "ig", "id", "in",
     * "ga", "it", "ja", "jv", "kn", "kk", "km", "rw", "ko", "ku", "ky",
     * "lo", "la", "lv", "lt", "lb", "mk", "mg", "ms", "ml", "mt", "mi",
     * "mr", "mn", "my", "ne", "no", "ny", "or", "ps", "fa", "pl", "pt",
     * "pa", "ro", "ru", "sm", "gd", "sr", "st", "sn", "sd", "si", "sk",
     * "sl", "so", "es", "su", "sw", "sv", "tl", "tg", "ta", "tt", "te",
     * "th", "tr", "tk", "uk", "ur", "ug", "uz", "vi", "cy", "xh", "yi",
     * "ji", "yo", "zu"
     */
    public async FormattedText translate_message_text (
        int64 chat_id,
        int64 message_id,
        string to_language_code
    ) throws BadStatusCodeError {
        var obj = new TranslateMessageText (
            chat_id,
            message_id,
            to_language_code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (translate_message_text.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FormattedText out_obj;
        switch (tdlib_type) {
            case "formattedText":
                out_obj = (FormattedText) jsoner.deserialize_object (typeof (FormattedText));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Recognizes speech in a video note or a voice note message
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message. Use
     * messageProperties.can_recognize_speech to check whether the message is
     * suitable
     */
    public async Ok recognize_speech (
        int64 chat_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new RecognizeSpeech (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (recognize_speech.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Rates recognized speech in a video note or a voice note message
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param is_good Pass true if the speech recognition is good
     */
    public async Ok rate_speech_recognition (
        int64 chat_id,
        int64 message_id,
        bool is_good
    ) throws BadStatusCodeError {
        var obj = new RateSpeechRecognition (
            chat_id,
            message_id,
            is_good
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (rate_speech_recognition.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of message sender identifiers, which can be used to
     * send messages in a chat
     * @param chat_id Chat identifier
     */
    public async ChatMessageSenders get_chat_available_message_senders (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new GetChatAvailableMessageSenders (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_available_message_senders.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatMessageSenders out_obj;
        switch (tdlib_type) {
            case "chatMessageSenders":
                out_obj = (ChatMessageSenders) jsoner.deserialize_object (typeof (ChatMessageSenders));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Selects a message sender to send messages in a chat
     * @param chat_id Chat identifier
     * @param message_sender_id New message sender for the chat
     */
    public async Ok set_chat_message_sender (
        int64 chat_id,
        MessageSender message_sender_id
    ) throws BadStatusCodeError {
        var obj = new SetChatMessageSender (
            chat_id,
            message_sender_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_message_sender.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends a message. Returns the sent message
     * @param chat_id Target chat
     * @param message_thread_id If not 0, the message thread identifier in
     * which the message will be sent
     * @param reply_to Information about the message or story to be replied;
     * pass null if none
     * @param options Options to be used to send the message; pass null to
     * use default options
     * @param reply_markup Markup for replying to the message; pass null if
     * none; for bots only
     * @param input_message_content The content of the message to be sent
     */
    public async Message send_message (
        int64 chat_id,
        int64 message_thread_id,
        InputMessageReplyTo reply_to,
        MessageSendOptions options,
        ReplyMarkup reply_markup,
        InputMessageContent input_message_content
    ) throws BadStatusCodeError {
        var obj = new SendMessage (
            chat_id,
            message_thread_id,
            reply_to,
            options,
            reply_markup,
            input_message_content
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Message out_obj;
        switch (tdlib_type) {
            case "message":
                out_obj = (Message) jsoner.deserialize_object (typeof (Message));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends 2-10 messages grouped together into an album. Currently, only
     * audio, document, photo and video messages can be grouped into an
     * album.
     * Documents and audio files can be only grouped in an album with
     * messages of the same type. Returns sent messages
     * @param chat_id Target chat
     * @param message_thread_id If not 0, the message thread identifier in
     * which the messages will be sent
     * @param reply_to Information about the message or story to be replied;
     * pass null if none
     * @param options Options to be used to send the messages; pass null to
     * use default options
     * @param input_message_contents Contents of messages to be sent. At most
     * 10 messages can be added to an album. All messages must have the same
     * value of show_caption_above_media
     */
    public async Messages send_message_album (
        int64 chat_id,
        int64 message_thread_id,
        InputMessageReplyTo reply_to,
        MessageSendOptions options,
        Gee.ArrayList<InputMessageContent?> input_message_contents
    ) throws BadStatusCodeError {
        var obj = new SendMessageAlbum (
            chat_id,
            message_thread_id,
            reply_to,
            options,
            input_message_contents
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_message_album.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Messages out_obj;
        switch (tdlib_type) {
            case "messages":
                out_obj = (Messages) jsoner.deserialize_object (typeof (Messages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Invites a bot to a chat (if it is not yet a member) and sends it the
     * /start command; requires can_invite_users member right. Bots can't be
     * invited to a private chat other than the chat with the bot.
     * Bots can't be invited to channels (although they can be added as
     * admins) and secret chats. Returns the sent message
     * @param bot_user_id Identifier of the bot
     * @param chat_id Identifier of the target chat
     * @param parameter A hidden parameter sent to the bot for deep linking
     * purposes (https://core.telegram.org/bots#deep-linking)
     */
    public async Message send_bot_start_message (
        int64 bot_user_id,
        int64 chat_id,
        string parameter
    ) throws BadStatusCodeError {
        var obj = new SendBotStartMessage (
            bot_user_id,
            chat_id,
            parameter
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_bot_start_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Message out_obj;
        switch (tdlib_type) {
            case "message":
                out_obj = (Message) jsoner.deserialize_object (typeof (Message));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends the result of an inline query as a message. Returns the sent
     * message. Always clears a chat draft message
     * @param chat_id Target chat
     * @param message_thread_id If not 0, the message thread identifier in
     * which the message will be sent
     * @param reply_to Information about the message or story to be replied;
     * pass null if none
     * @param options Options to be used to send the message; pass null to
     * use default options
     * @param query_id Identifier of the inline query
     * @param result_id Identifier of the inline query result
     * @param hide_via_bot Pass true to hide the bot, via which the message
     * is sent. Can be used only for bots
     * getOption("animation_search_bot_username"),
     * getOption("photo_search_bot_username"), and
     * getOption("venue_search_bot_username")
     */
    public async Message send_inline_query_result_message (
        int64 chat_id,
        int64 message_thread_id,
        InputMessageReplyTo reply_to,
        MessageSendOptions options,
        int64 query_id,
        string result_id,
        bool hide_via_bot
    ) throws BadStatusCodeError {
        var obj = new SendInlineQueryResultMessage (
            chat_id,
            message_thread_id,
            reply_to,
            options,
            query_id,
            result_id,
            hide_via_bot
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_inline_query_result_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Message out_obj;
        switch (tdlib_type) {
            case "message":
                out_obj = (Message) jsoner.deserialize_object (typeof (Message));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Forwards previously sent messages. Returns the forwarded messages in
     * the same order as the message identifiers passed in message_ids. If a
     * message can't be forwarded, null will be returned instead of the
     * message
     * @param chat_id Identifier of the chat to which to forward messages
     * @param message_thread_id If not 0, the message thread identifier in
     * which the message will be sent; for forum threads only
     * @param from_chat_id Identifier of the chat from which to forward
     * messages
     * @param message_ids Identifiers of the messages to forward. Message
     * identifiers must be in a strictly increasing order. At most 100
     * messages can be forwarded simultaneously. A message can be forwarded
     * only if messageProperties.can_be_forwarded
     * @param options Options to be used to send the messages; pass null to
     * use default options
     * @param send_copy Pass true to copy content of the messages without
     * reference to the original sender. Always true if the messages are
     * forwarded to a secret chat or are local. Use
     * messageProperties.can_be_saved and
     * messageProperties.can_be_copied_to_secret_chat to check whether the
     * message is suitable
     * @param remove_caption Pass true to remove media captions of message
     * copies. Ignored if send_copy is false
     */
    public async Messages forward_messages (
        int64 chat_id,
        int64 message_thread_id,
        int64 from_chat_id,
        Gee.ArrayList<int64?> message_ids,
        MessageSendOptions options,
        bool send_copy,
        bool remove_caption
    ) throws BadStatusCodeError {
        var obj = new ForwardMessages (
            chat_id,
            message_thread_id,
            from_chat_id,
            message_ids,
            options,
            send_copy,
            remove_caption
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (forward_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Messages out_obj;
        switch (tdlib_type) {
            case "messages":
                out_obj = (Messages) jsoner.deserialize_object (typeof (Messages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends messages from a quick reply shortcut. Requires Telegram Business
     * subscription
     * @param chat_id Identifier of the chat to which to send messages. The
     * chat must be a private chat with a regular user
     * @param shortcut_id Unique identifier of the quick reply shortcut
     * @param sending_id Non-persistent identifier, which will be returned
     * back in messageSendingStatePending object and can be used to match
     * sent messages and corresponding updateNewMessage updates
     */
    public async Messages send_quick_reply_shortcut_messages (
        int64 chat_id,
        int32 shortcut_id,
        int32 sending_id
    ) throws BadStatusCodeError {
        var obj = new SendQuickReplyShortcutMessages (
            chat_id,
            shortcut_id,
            sending_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_quick_reply_shortcut_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Messages out_obj;
        switch (tdlib_type) {
            case "messages":
                out_obj = (Messages) jsoner.deserialize_object (typeof (Messages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Resends messages which failed to send. Can be called only for messages
     * for which messageSendingStateFailed.can_retry is true and after
     * specified in messageSendingStateFailed.retry_after time passed.
     * If a message is re-sent, the corresponding failed to send message is
     * deleted. Returns the sent messages in the same order as the message
     * identifiers passed in message_ids. If a message can't be re-sent, null
     * will be returned instead of the message
     * @param chat_id Identifier of the chat to send messages
     * @param message_ids Identifiers of the messages to resend. Message
     * identifiers must be in a strictly increasing order
     * @param quote New manually chosen quote from the message to be replied;
     * pass null if none. Ignored if more than one message is re-sent, or if
     * messageSendingStateFailed.need_another_reply_quote == false
     */
    public async Messages resend_messages (
        int64 chat_id,
        Gee.ArrayList<int64?> message_ids,
        InputTextQuote quote
    ) throws BadStatusCodeError {
        var obj = new ResendMessages (
            chat_id,
            message_ids,
            quote
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (resend_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Messages out_obj;
        switch (tdlib_type) {
            case "messages":
                out_obj = (Messages) jsoner.deserialize_object (typeof (Messages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a local message to a chat. The message is persistent across
     * application restarts only if the message database is used. Returns the
     * added message
     * @param chat_id Target chat
     * @param sender_id Identifier of the sender of the message
     * @param reply_to Information about the message or story to be replied;
     * pass null if none
     * @param disable_notification Pass true to disable notification for the
     * message
     * @param input_message_content The content of the message to be added
     */
    public async Message add_local_message (
        int64 chat_id,
        MessageSender sender_id,
        InputMessageReplyTo reply_to,
        bool disable_notification,
        InputMessageContent input_message_content
    ) throws BadStatusCodeError {
        var obj = new AddLocalMessage (
            chat_id,
            sender_id,
            reply_to,
            disable_notification,
            input_message_content
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_local_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Message out_obj;
        switch (tdlib_type) {
            case "message":
                out_obj = (Message) jsoner.deserialize_object (typeof (Message));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes messages
     * @param chat_id Chat identifier
     * @param message_ids Identifiers of the messages to be deleted. Use
     * messageProperties.can_be_deleted_only_for_self and
     * messageProperties.can_be_deleted_for_all_users to get suitable
     * messages
     * @param revoke Pass true to delete messages for all chat members.
     * Always true for supergroups, channels and secret chats
     */
    public async Ok delete_messages (
        int64 chat_id,
        Gee.ArrayList<int64?> message_ids,
        bool revoke
    ) throws BadStatusCodeError {
        var obj = new DeleteMessages (
            chat_id,
            message_ids,
            revoke
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes all messages sent by the specified message sender in a chat.
     * Supported only for supergroups; requires can_delete_messages
     * administrator privileges
     * @param chat_id Chat identifier
     * @param sender_id Identifier of the sender of messages to delete
     */
    public async Ok delete_chat_messages_by_sender (
        int64 chat_id,
        MessageSender sender_id
    ) throws BadStatusCodeError {
        var obj = new DeleteChatMessagesBySender (
            chat_id,
            sender_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_chat_messages_by_sender.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes all messages between the specified dates in a chat. Supported
     * only for private chats and basic groups. Messages sent in the last 30
     * seconds will not be deleted
     * @param chat_id Chat identifier
     * @param min_date The minimum date of the messages to delete
     * @param max_date The maximum date of the messages to delete
     * @param revoke Pass true to delete chat messages for all users; private
     * chats only
     */
    public async Ok delete_chat_messages_by_date (
        int64 chat_id,
        int32 min_date,
        int32 max_date,
        bool revoke
    ) throws BadStatusCodeError {
        var obj = new DeleteChatMessagesByDate (
            chat_id,
            min_date,
            max_date,
            revoke
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_chat_messages_by_date.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits the text of a message (or a text of a game message). Returns the
     * edited message after the edit is completed on the server side
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message. Use
     * messageProperties.can_be_edited to check whether the message can be
     * edited
     * @param reply_markup The new message reply markup; pass null if none;
     * for bots only
     * @param input_message_content New text content of the message. Must be
     * of type inputMessageText
     */
    public async Message edit_message_text (
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup,
        InputMessageContent input_message_content
    ) throws BadStatusCodeError {
        var obj = new EditMessageText (
            chat_id,
            message_id,
            reply_markup,
            input_message_content
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_message_text.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Message out_obj;
        switch (tdlib_type) {
            case "message":
                out_obj = (Message) jsoner.deserialize_object (typeof (Message));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits the message content of a live location. Messages can be edited
     * for a limited period of time specified in the live location.
     * Returns the edited message after the edit is completed on the server
     * side
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message. Use
     * messageProperties.can_be_edited to check whether the message can be
     * edited
     * @param reply_markup The new message reply markup; pass null if none;
     * for bots only
     * @param location New location content of the message; pass null to stop
     * sharing the live location
     * @param live_period New time relative to the message send date, for
     * which the location can be updated, in seconds. If 0x7FFFFFFF
     * specified, then the location can be updated forever. Otherwise, must
     * not exceed the current live_period by more than a day, and the live
     * location expiration date must remain in the next 90 days. Pass 0 to
     * keep the current live_period
     * @param heading The new direction in which the location moves, in
     * degrees; 1-360. Pass 0 if unknown
     * @param proximity_alert_radius The new maximum distance for proximity
     * alerts, in meters (0-100000). Pass 0 if the notification is disabled
     */
    public async Message edit_message_live_location (
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup,
        Location location,
        int32 live_period,
        int32 heading,
        int32 proximity_alert_radius
    ) throws BadStatusCodeError {
        var obj = new EditMessageLiveLocation (
            chat_id,
            message_id,
            reply_markup,
            location,
            live_period,
            heading,
            proximity_alert_radius
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_message_live_location.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Message out_obj;
        switch (tdlib_type) {
            case "message":
                out_obj = (Message) jsoner.deserialize_object (typeof (Message));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits the media content of a message, including message caption. If
     * only the caption needs to be edited, use editMessageCaption instead.
     * The type of message content in an album can't be changed with
     * exception of replacing a photo with a video or vice versa. Returns the
     * edited message after the edit is completed on the server side
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message. Use
     * messageProperties.can_edit_media to check whether the message can be
     * edited
     * @param reply_markup The new message reply markup; pass null if none;
     * for bots only
     * @param input_message_content New content of the message. Must be one
     * of the following types: inputMessageAnimation, inputMessageAudio,
     * inputMessageDocument, inputMessagePhoto or inputMessageVideo
     */
    public async Message edit_message_media (
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup,
        InputMessageContent input_message_content
    ) throws BadStatusCodeError {
        var obj = new EditMessageMedia (
            chat_id,
            message_id,
            reply_markup,
            input_message_content
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_message_media.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Message out_obj;
        switch (tdlib_type) {
            case "message":
                out_obj = (Message) jsoner.deserialize_object (typeof (Message));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits the message content caption. Returns the edited message after
     * the edit is completed on the server side
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message. Use
     * messageProperties.can_be_edited to check whether the message can be
     * edited
     * @param reply_markup The new message reply markup; pass null if none;
     * for bots only
     * @param caption New message content caption;
     * 0-getOption("message_caption_length_max") characters; pass null to
     * remove caption
     * @param show_caption_above_media Pass true to show the caption above
     * the media; otherwise, the caption will be shown below the media. May
     * be true only for animation, photo, and video messages
     */
    public async Message edit_message_caption (
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup,
        FormattedText caption,
        bool show_caption_above_media
    ) throws BadStatusCodeError {
        var obj = new EditMessageCaption (
            chat_id,
            message_id,
            reply_markup,
            caption,
            show_caption_above_media
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_message_caption.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Message out_obj;
        switch (tdlib_type) {
            case "message":
                out_obj = (Message) jsoner.deserialize_object (typeof (Message));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits the message reply markup; for bots only. Returns the edited
     * message after the edit is completed on the server side
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message. Use
     * messageProperties.can_be_edited to check whether the message can be
     * edited
     * @param reply_markup The new message reply markup; pass null if none
     */
    public async Message edit_message_reply_markup (
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup
    ) throws BadStatusCodeError {
        var obj = new EditMessageReplyMarkup (
            chat_id,
            message_id,
            reply_markup
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_message_reply_markup.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Message out_obj;
        switch (tdlib_type) {
            case "message":
                out_obj = (Message) jsoner.deserialize_object (typeof (Message));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits the text of an inline text or game message sent via a bot; for
     * bots only
     * @param inline_message_id Inline message identifier
     * @param reply_markup The new message reply markup; pass null if none
     * @param input_message_content New text content of the message. Must be
     * of type inputMessageText
     */
    public async Ok edit_inline_message_text (
        string inline_message_id,
        ReplyMarkup reply_markup,
        InputMessageContent input_message_content
    ) throws BadStatusCodeError {
        var obj = new EditInlineMessageText (
            inline_message_id,
            reply_markup,
            input_message_content
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_inline_message_text.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits the content of a live location in an inline message sent via a
     * bot; for bots only
     * @param inline_message_id Inline message identifier
     * @param reply_markup The new message reply markup; pass null if none
     * @param location New location content of the message; pass null to stop
     * sharing the live location
     * @param live_period New time relative to the message send date, for
     * which the location can be updated, in seconds. If 0x7FFFFFFF
     * specified, then the location can be updated forever. Otherwise, must
     * not exceed the current live_period by more than a day, and the live
     * location expiration date must remain in the next 90 days. Pass 0 to
     * keep the current live_period
     * @param heading The new direction in which the location moves, in
     * degrees; 1-360. Pass 0 if unknown
     * @param proximity_alert_radius The new maximum distance for proximity
     * alerts, in meters (0-100000). Pass 0 if the notification is disabled
     */
    public async Ok edit_inline_message_live_location (
        string inline_message_id,
        ReplyMarkup reply_markup,
        Location location,
        int32 live_period,
        int32 heading,
        int32 proximity_alert_radius
    ) throws BadStatusCodeError {
        var obj = new EditInlineMessageLiveLocation (
            inline_message_id,
            reply_markup,
            location,
            live_period,
            heading,
            proximity_alert_radius
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_inline_message_live_location.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits the media content of a message with a text, an animation, an
     * audio, a document, a photo or a video in an inline message sent via a
     * bot; for bots only
     * @param inline_message_id Inline message identifier
     * @param reply_markup The new message reply markup; pass null if none;
     * for bots only
     * @param input_message_content New content of the message. Must be one
     * of the following types: inputMessageAnimation, inputMessageAudio,
     * inputMessageDocument, inputMessagePhoto or inputMessageVideo
     */
    public async Ok edit_inline_message_media (
        string inline_message_id,
        ReplyMarkup reply_markup,
        InputMessageContent input_message_content
    ) throws BadStatusCodeError {
        var obj = new EditInlineMessageMedia (
            inline_message_id,
            reply_markup,
            input_message_content
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_inline_message_media.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits the caption of an inline message sent via a bot; for bots only
     * @param inline_message_id Inline message identifier
     * @param reply_markup The new message reply markup; pass null if none
     * @param caption New message content caption; pass null to remove
     * caption; 0-getOption("message_caption_length_max") characters
     * @param show_caption_above_media Pass true to show the caption above
     * the media; otherwise, the caption will be shown below the media. May
     * be true only for animation, photo, and video messages
     */
    public async Ok edit_inline_message_caption (
        string inline_message_id,
        ReplyMarkup reply_markup,
        FormattedText caption,
        bool show_caption_above_media
    ) throws BadStatusCodeError {
        var obj = new EditInlineMessageCaption (
            inline_message_id,
            reply_markup,
            caption,
            show_caption_above_media
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_inline_message_caption.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits the reply markup of an inline message sent via a bot; for bots
     * only
     * @param inline_message_id Inline message identifier
     * @param reply_markup The new message reply markup; pass null if none
     */
    public async Ok edit_inline_message_reply_markup (
        string inline_message_id,
        ReplyMarkup reply_markup
    ) throws BadStatusCodeError {
        var obj = new EditInlineMessageReplyMarkup (
            inline_message_id,
            reply_markup
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_inline_message_reply_markup.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits the time when a scheduled message will be sent. Scheduling state
     * of all messages in the same album or forwarded together with the
     * message will be also changed
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message. Use
     * messageProperties.can_edit_scheduling_state to check whether the
     * message is suitable
     * @param scheduling_state The new message scheduling state; pass null to
     * send the message immediately. Must be null for messages in the state
     * messageSchedulingStateSendWhenVideoProcessed
     */
    public async Ok edit_message_scheduling_state (
        int64 chat_id,
        int64 message_id,
        MessageSchedulingState scheduling_state
    ) throws BadStatusCodeError {
        var obj = new EditMessageSchedulingState (
            chat_id,
            message_id,
            scheduling_state
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_message_scheduling_state.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the fact-check of a message. Can be only used if
     * messageProperties.can_set_fact_check == true
     * @param chat_id The channel chat the message belongs to
     * @param message_id Identifier of the message
     * @param text New text of the fact-check;
     * 0-getOption("fact_check_length_max") characters; pass null to remove
     * it. Only Bold, Italic, and TextUrl entities with https://t.me/ links
     * are supported
     */
    public async Ok set_message_fact_check (
        int64 chat_id,
        int64 message_id,
        FormattedText text
    ) throws BadStatusCodeError {
        var obj = new SetMessageFactCheck (
            chat_id,
            message_id,
            text
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_message_fact_check.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends a message on behalf of a business account; for bots only.
     * Returns the message after it was sent
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which to send the request
     * @param chat_id Target chat
     * @param reply_to Information about the message to be replied; pass null
     * if none
     * @param disable_notification Pass true to disable notification for the
     * message
     * @param protect_content Pass true if the content of the message must be
     * protected from forwarding and saving
     * @param effect_id Identifier of the effect to apply to the message
     * @param reply_markup Markup for replying to the message; pass null if
     * none
     * @param input_message_content The content of the message to be sent
     */
    public async BusinessMessage send_business_message (
        string business_connection_id,
        int64 chat_id,
        InputMessageReplyTo reply_to,
        bool disable_notification,
        bool protect_content,
        int64 effect_id,
        ReplyMarkup reply_markup,
        InputMessageContent input_message_content
    ) throws BadStatusCodeError {
        var obj = new SendBusinessMessage (
            business_connection_id,
            chat_id,
            reply_to,
            disable_notification,
            protect_content,
            effect_id,
            reply_markup,
            input_message_content
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_business_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BusinessMessage out_obj;
        switch (tdlib_type) {
            case "businessMessage":
                out_obj = (BusinessMessage) jsoner.deserialize_object (typeof (BusinessMessage));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends 2-10 messages grouped together into an album on behalf of a
     * business account; for bots only. Currently, only audio, document,
     * photo and video messages can be grouped into an album.
     * Documents and audio files can be only grouped in an album with
     * messages of the same type. Returns sent messages
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which to send the request
     * @param chat_id Target chat
     * @param reply_to Information about the message to be replied; pass null
     * if none
     * @param disable_notification Pass true to disable notification for the
     * message
     * @param protect_content Pass true if the content of the message must be
     * protected from forwarding and saving
     * @param effect_id Identifier of the effect to apply to the message
     * @param input_message_contents Contents of messages to be sent. At most
     * 10 messages can be added to an album. All messages must have the same
     * value of show_caption_above_media
     */
    public async BusinessMessages send_business_message_album (
        string business_connection_id,
        int64 chat_id,
        InputMessageReplyTo reply_to,
        bool disable_notification,
        bool protect_content,
        int64 effect_id,
        Gee.ArrayList<InputMessageContent?> input_message_contents
    ) throws BadStatusCodeError {
        var obj = new SendBusinessMessageAlbum (
            business_connection_id,
            chat_id,
            reply_to,
            disable_notification,
            protect_content,
            effect_id,
            input_message_contents
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_business_message_album.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BusinessMessages out_obj;
        switch (tdlib_type) {
            case "businessMessages":
                out_obj = (BusinessMessages) jsoner.deserialize_object (typeof (BusinessMessages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits the text of a text or game message sent on behalf of a business
     * account; for bots only
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which the message was sent
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message
     * @param reply_markup The new message reply markup; pass null if none
     * @param input_message_content New text content of the message. Must be
     * of type inputMessageText
     */
    public async BusinessMessage edit_business_message_text (
        string business_connection_id,
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup,
        InputMessageContent input_message_content
    ) throws BadStatusCodeError {
        var obj = new EditBusinessMessageText (
            business_connection_id,
            chat_id,
            message_id,
            reply_markup,
            input_message_content
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_business_message_text.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BusinessMessage out_obj;
        switch (tdlib_type) {
            case "businessMessage":
                out_obj = (BusinessMessage) jsoner.deserialize_object (typeof (BusinessMessage));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits the content of a live location in a message sent on behalf of a
     * business account; for bots only
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which the message was sent
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message
     * @param reply_markup The new message reply markup; pass null if none
     * @param location New location content of the message; pass null to stop
     * sharing the live location
     * @param live_period New time relative to the message send date, for
     * which the location can be updated, in seconds. If 0x7FFFFFFF
     * specified, then the location can be updated forever. Otherwise, must
     * not exceed the current live_period by more than a day, and the live
     * location expiration date must remain in the next 90 days. Pass 0 to
     * keep the current live_period
     * @param heading The new direction in which the location moves, in
     * degrees; 1-360. Pass 0 if unknown
     * @param proximity_alert_radius The new maximum distance for proximity
     * alerts, in meters (0-100000). Pass 0 if the notification is disabled
     */
    public async BusinessMessage edit_business_message_live_location (
        string business_connection_id,
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup,
        Location location,
        int32 live_period,
        int32 heading,
        int32 proximity_alert_radius
    ) throws BadStatusCodeError {
        var obj = new EditBusinessMessageLiveLocation (
            business_connection_id,
            chat_id,
            message_id,
            reply_markup,
            location,
            live_period,
            heading,
            proximity_alert_radius
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_business_message_live_location.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BusinessMessage out_obj;
        switch (tdlib_type) {
            case "businessMessage":
                out_obj = (BusinessMessage) jsoner.deserialize_object (typeof (BusinessMessage));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits the media content of a message with a text, an animation, an
     * audio, a document, a photo or a video in a message sent on behalf of a
     * business account; for bots only
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which the message was sent
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message
     * @param reply_markup The new message reply markup; pass null if none;
     * for bots only
     * @param input_message_content New content of the message. Must be one
     * of the following types: inputMessageAnimation, inputMessageAudio,
     * inputMessageDocument, inputMessagePhoto or inputMessageVideo
     */
    public async BusinessMessage edit_business_message_media (
        string business_connection_id,
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup,
        InputMessageContent input_message_content
    ) throws BadStatusCodeError {
        var obj = new EditBusinessMessageMedia (
            business_connection_id,
            chat_id,
            message_id,
            reply_markup,
            input_message_content
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_business_message_media.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BusinessMessage out_obj;
        switch (tdlib_type) {
            case "businessMessage":
                out_obj = (BusinessMessage) jsoner.deserialize_object (typeof (BusinessMessage));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits the caption of a message sent on behalf of a business account;
     * for bots only
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which the message was sent
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message
     * @param reply_markup The new message reply markup; pass null if none
     * @param caption New message content caption; pass null to remove
     * caption; 0-getOption("message_caption_length_max") characters
     * @param show_caption_above_media Pass true to show the caption above
     * the media; otherwise, the caption will be shown below the media. May
     * be true only for animation, photo, and video messages
     */
    public async BusinessMessage edit_business_message_caption (
        string business_connection_id,
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup,
        FormattedText caption,
        bool show_caption_above_media
    ) throws BadStatusCodeError {
        var obj = new EditBusinessMessageCaption (
            business_connection_id,
            chat_id,
            message_id,
            reply_markup,
            caption,
            show_caption_above_media
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_business_message_caption.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BusinessMessage out_obj;
        switch (tdlib_type) {
            case "businessMessage":
                out_obj = (BusinessMessage) jsoner.deserialize_object (typeof (BusinessMessage));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits the reply markup of a message sent on behalf of a business
     * account; for bots only
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which the message was sent
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message
     * @param reply_markup The new message reply markup; pass null if none
     */
    public async BusinessMessage edit_business_message_reply_markup (
        string business_connection_id,
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup
    ) throws BadStatusCodeError {
        var obj = new EditBusinessMessageReplyMarkup (
            business_connection_id,
            chat_id,
            message_id,
            reply_markup
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_business_message_reply_markup.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BusinessMessage out_obj;
        switch (tdlib_type) {
            case "businessMessage":
                out_obj = (BusinessMessage) jsoner.deserialize_object (typeof (BusinessMessage));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Stops a poll sent on behalf of a business account; for bots only
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which the message with the poll was sent
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message containing the poll
     * @param reply_markup The new message reply markup; pass null if none
     */
    public async BusinessMessage stop_business_poll (
        string business_connection_id,
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup
    ) throws BadStatusCodeError {
        var obj = new StopBusinessPoll (
            business_connection_id,
            chat_id,
            message_id,
            reply_markup
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (stop_business_poll.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BusinessMessage out_obj;
        switch (tdlib_type) {
            case "businessMessage":
                out_obj = (BusinessMessage) jsoner.deserialize_object (typeof (BusinessMessage));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Pins or unpins a message sent on behalf of a business account; for
     * bots only
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which the message was sent
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message
     * @param is_pinned Pass true to pin the message, pass false to unpin it
     */
    public async Ok set_business_message_is_pinned (
        string business_connection_id,
        int64 chat_id,
        int64 message_id,
        bool is_pinned
    ) throws BadStatusCodeError {
        var obj = new SetBusinessMessageIsPinned (
            business_connection_id,
            chat_id,
            message_id,
            is_pinned
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_business_message_is_pinned.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks validness of a name for a quick reply shortcut. Can be called
     * synchronously
     * @param name The name of the shortcut; 1-32 characters
     */
    public Ok check_quick_reply_shortcut_name_sync (
        string name
    ) throws BadStatusCodeError {
        var obj = new CheckQuickReplyShortcutName (
            name
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks validness of a name for a quick reply shortcut. Can be called
     * synchronously
     * @param name The name of the shortcut; 1-32 characters
     */
    public async Ok check_quick_reply_shortcut_name (
        string name
    ) throws BadStatusCodeError {
        var obj = new CheckQuickReplyShortcutName (
            name
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_quick_reply_shortcut_name.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Loads quick reply shortcuts created by the current user. The loaded
     * data will be sent through updateQuickReplyShortcut and
     * updateQuickReplyShortcuts
     */
    public async Ok load_quick_reply_shortcuts () throws BadStatusCodeError {
        var obj = new LoadQuickReplyShortcuts ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (load_quick_reply_shortcuts.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes name of a quick reply shortcut
     * @param shortcut_id Unique identifier of the quick reply shortcut
     * @param name New name for the shortcut. Use checkQuickReplyShortcutName
     * to check its validness
     */
    public async Ok set_quick_reply_shortcut_name (
        int32 shortcut_id,
        string name
    ) throws BadStatusCodeError {
        var obj = new SetQuickReplyShortcutName (
            shortcut_id,
            name
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_quick_reply_shortcut_name.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes a quick reply shortcut
     * @param shortcut_id Unique identifier of the quick reply shortcut
     */
    public async Ok delete_quick_reply_shortcut (
        int32 shortcut_id
    ) throws BadStatusCodeError {
        var obj = new DeleteQuickReplyShortcut (
            shortcut_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_quick_reply_shortcut.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the order of quick reply shortcuts
     * @param shortcut_ids The new order of quick reply shortcuts
     */
    public async Ok reorder_quick_reply_shortcuts (
        Gee.ArrayList<int32?> shortcut_ids
    ) throws BadStatusCodeError {
        var obj = new ReorderQuickReplyShortcuts (
            shortcut_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reorder_quick_reply_shortcuts.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Loads quick reply messages that can be sent by a given quick reply
     * shortcut. The loaded messages will be sent through
     * updateQuickReplyShortcutMessages
     * @param shortcut_id Unique identifier of the quick reply shortcut
     */
    public async Ok load_quick_reply_shortcut_messages (
        int32 shortcut_id
    ) throws BadStatusCodeError {
        var obj = new LoadQuickReplyShortcutMessages (
            shortcut_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (load_quick_reply_shortcut_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes specified quick reply messages
     * @param shortcut_id Unique identifier of the quick reply shortcut to
     * which the messages belong
     * @param message_ids Unique identifiers of the messages
     */
    public async Ok delete_quick_reply_shortcut_messages (
        int32 shortcut_id,
        Gee.ArrayList<int64?> message_ids
    ) throws BadStatusCodeError {
        var obj = new DeleteQuickReplyShortcutMessages (
            shortcut_id,
            message_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_quick_reply_shortcut_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a message to a quick reply shortcut. If shortcut doesn't exist
     * and there are less than getOption("quick_reply_shortcut_count_max")
     * shortcuts, then a new shortcut is created.
     * The shortcut must not contain more than
     * getOption("quick_reply_shortcut_message_count_max") messages after
     * adding the new message. Returns the added message
     * @param shortcut_name Name of the target shortcut
     * @param reply_to_message_id Identifier of a quick reply message in the
     * same shortcut to be replied; pass 0 if none
     * @param input_message_content The content of the message to be added;
     * inputMessagePoll, inputMessageForwarded and inputMessageLocation with
     * live_period aren't supported
     */
    public async QuickReplyMessage add_quick_reply_shortcut_message (
        string shortcut_name,
        int64 reply_to_message_id,
        InputMessageContent input_message_content
    ) throws BadStatusCodeError {
        var obj = new AddQuickReplyShortcutMessage (
            shortcut_name,
            reply_to_message_id,
            input_message_content
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_quick_reply_shortcut_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        QuickReplyMessage out_obj;
        switch (tdlib_type) {
            case "quickReplyMessage":
                out_obj = (QuickReplyMessage) jsoner.deserialize_object (typeof (QuickReplyMessage));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a message to a quick reply shortcut via inline bot. If shortcut
     * doesn't exist and there are less than
     * getOption("quick_reply_shortcut_count_max") shortcuts, then a new
     * shortcut is created.
     * The shortcut must not contain more than
     * getOption("quick_reply_shortcut_message_count_max") messages after
     * adding the new message. Returns the added message
     * @param shortcut_name Name of the target shortcut
     * @param reply_to_message_id Identifier of a quick reply message in the
     * same shortcut to be replied; pass 0 if none
     * @param query_id Identifier of the inline query
     * @param result_id Identifier of the inline query result
     * @param hide_via_bot Pass true to hide the bot, via which the message
     * is sent. Can be used only for bots
     * getOption("animation_search_bot_username"),
     * getOption("photo_search_bot_username"), and
     * getOption("venue_search_bot_username")
     */
    public async QuickReplyMessage add_quick_reply_shortcut_inline_query_result_message (
        string shortcut_name,
        int64 reply_to_message_id,
        int64 query_id,
        string result_id,
        bool hide_via_bot
    ) throws BadStatusCodeError {
        var obj = new AddQuickReplyShortcutInlineQueryResultMessage (
            shortcut_name,
            reply_to_message_id,
            query_id,
            result_id,
            hide_via_bot
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_quick_reply_shortcut_inline_query_result_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        QuickReplyMessage out_obj;
        switch (tdlib_type) {
            case "quickReplyMessage":
                out_obj = (QuickReplyMessage) jsoner.deserialize_object (typeof (QuickReplyMessage));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds 2-10 messages grouped together into an album to a quick reply
     * shortcut. Currently, only audio, document, photo and video messages
     * can be grouped into an album.
     * Documents and audio files can be only grouped in an album with
     * messages of the same type. Returns sent messages
     * @param shortcut_name Name of the target shortcut
     * @param reply_to_message_id Identifier of a quick reply message in the
     * same shortcut to be replied; pass 0 if none
     * @param input_message_contents Contents of messages to be sent. At most
     * 10 messages can be added to an album. All messages must have the same
     * value of show_caption_above_media
     */
    public async QuickReplyMessages add_quick_reply_shortcut_message_album (
        string shortcut_name,
        int64 reply_to_message_id,
        Gee.ArrayList<InputMessageContent?> input_message_contents
    ) throws BadStatusCodeError {
        var obj = new AddQuickReplyShortcutMessageAlbum (
            shortcut_name,
            reply_to_message_id,
            input_message_contents
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_quick_reply_shortcut_message_album.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        QuickReplyMessages out_obj;
        switch (tdlib_type) {
            case "quickReplyMessages":
                out_obj = (QuickReplyMessages) jsoner.deserialize_object (typeof (QuickReplyMessages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Readds quick reply messages which failed to add. Can be called only
     * for messages for which messageSendingStateFailed.can_retry is true and
     * after specified in messageSendingStateFailed.retry_after time passed.
     * If a message is readded, the corresponding failed to send message is
     * deleted. Returns the sent messages in the same order as the message
     * identifiers passed in message_ids. If a message can't be readded, null
     * will be returned instead of the message
     * @param shortcut_name Name of the target shortcut
     * @param message_ids Identifiers of the quick reply messages to readd.
     * Message identifiers must be in a strictly increasing order
     */
    public async QuickReplyMessages readd_quick_reply_shortcut_messages (
        string shortcut_name,
        Gee.ArrayList<int64?> message_ids
    ) throws BadStatusCodeError {
        var obj = new ReaddQuickReplyShortcutMessages (
            shortcut_name,
            message_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (readd_quick_reply_shortcut_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        QuickReplyMessages out_obj;
        switch (tdlib_type) {
            case "quickReplyMessages":
                out_obj = (QuickReplyMessages) jsoner.deserialize_object (typeof (QuickReplyMessages));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Asynchronously edits the text, media or caption of a quick reply
     * message. Use quickReplyMessage.can_be_edited to check whether a
     * message can be edited.
     * Media message can be edited only to a media message. The type of
     * message content in an album can't be changed with exception of
     * replacing a photo with a video or vice versa
     * @param shortcut_id Unique identifier of the quick reply shortcut with
     * the message
     * @param message_id Identifier of the message
     * @param input_message_content New content of the message. Must be one
     * of the following types: inputMessageText, inputMessageAnimation,
     * inputMessageAudio, inputMessageDocument, inputMessagePhoto or
     * inputMessageVideo
     */
    public async Ok edit_quick_reply_message (
        int32 shortcut_id,
        int64 message_id,
        InputMessageContent input_message_content
    ) throws BadStatusCodeError {
        var obj = new EditQuickReplyMessage (
            shortcut_id,
            message_id,
            input_message_content
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_quick_reply_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of custom emoji, which can be used as forum topic
     * icon by all users
     */
    public async Stickers get_forum_topic_default_icons () throws BadStatusCodeError {
        var obj = new GetForumTopicDefaultIcons ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_forum_topic_default_icons.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Stickers out_obj;
        switch (tdlib_type) {
            case "stickers":
                out_obj = (Stickers) jsoner.deserialize_object (typeof (Stickers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Creates a topic in a forum supergroup chat; requires can_manage_topics
     * administrator or can_create_topics member right in the supergroup
     * @param chat_id Identifier of the chat
     * @param name Name of the topic; 1-128 characters
     * @param icon Icon of the topic. Icon color must be one of 0x6FB9F0,
     * 0xFFD67E, 0xCB86DB, 0x8EEE98, 0xFF93B2, or 0xFB6F5F. Telegram Premium
     * users can use any custom emoji as topic icon, other users can use only
     * a custom emoji returned by getForumTopicDefaultIcons
     */
    public async ForumTopicInfo create_forum_topic (
        int64 chat_id,
        string name,
        ForumTopicIcon icon
    ) throws BadStatusCodeError {
        var obj = new CreateForumTopic (
            chat_id,
            name,
            icon
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_forum_topic.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ForumTopicInfo out_obj;
        switch (tdlib_type) {
            case "forumTopicInfo":
                out_obj = (ForumTopicInfo) jsoner.deserialize_object (typeof (ForumTopicInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits title and icon of a topic in a forum supergroup chat; requires
     * can_manage_topics right in the supergroup unless the user is creator
     * of the topic
     * @param chat_id Identifier of the chat
     * @param message_thread_id Message thread identifier of the forum topic
     * @param name New name of the topic; 0-128 characters. If empty, the
     * previous topic name is kept
     * @param edit_icon_custom_emoji Pass true to edit the icon of the topic.
     * Icon of the General topic can't be edited
     * @param icon_custom_emoji_id Identifier of the new custom emoji for
     * topic icon; pass 0 to remove the custom emoji. Ignored if
     * edit_icon_custom_emoji is false. Telegram Premium users can use any
     * custom emoji, other users can use only a custom emoji returned by
     * getForumTopicDefaultIcons
     */
    public async Ok edit_forum_topic (
        int64 chat_id,
        int64 message_thread_id,
        string name,
        bool edit_icon_custom_emoji,
        int64 icon_custom_emoji_id
    ) throws BadStatusCodeError {
        var obj = new EditForumTopic (
            chat_id,
            message_thread_id,
            name,
            edit_icon_custom_emoji,
            icon_custom_emoji_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_forum_topic.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a forum topic
     * @param chat_id Identifier of the chat
     * @param message_thread_id Message thread identifier of the forum topic
     */
    public async ForumTopic get_forum_topic (
        int64 chat_id,
        int64 message_thread_id
    ) throws BadStatusCodeError {
        var obj = new GetForumTopic (
            chat_id,
            message_thread_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_forum_topic.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ForumTopic out_obj;
        switch (tdlib_type) {
            case "forumTopic":
                out_obj = (ForumTopic) jsoner.deserialize_object (typeof (ForumTopic));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an HTTPS link to a topic in a forum chat. This is an offline
     * request
     * @param chat_id Identifier of the chat
     * @param message_thread_id Message thread identifier of the forum topic
     */
    public async MessageLink get_forum_topic_link (
        int64 chat_id,
        int64 message_thread_id
    ) throws BadStatusCodeError {
        var obj = new GetForumTopicLink (
            chat_id,
            message_thread_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_forum_topic_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        MessageLink out_obj;
        switch (tdlib_type) {
            case "messageLink":
                out_obj = (MessageLink) jsoner.deserialize_object (typeof (MessageLink));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns found forum topics in a forum chat. This is a temporary method
     * for getting information about topic list from the server
     * @param chat_id Identifier of the forum chat
     * @param query Query to search for in the forum topic's name
     * @param offset_date The date starting from which the results need to be
     * fetched. Use 0 or any date in the future to get results from the last
     * topic
     * @param offset_message_id The message identifier of the last message in
     * the last found topic, or 0 for the first request
     * @param offset_message_thread_id The message thread identifier of the
     * last found topic, or 0 for the first request
     * @param limit The maximum number of forum topics to be returned; up to
     * 100. For optimal performance, the number of returned forum topics is
     * chosen by TDLib and can be smaller than the specified limit
     */
    public async ForumTopics get_forum_topics (
        int64 chat_id,
        string query,
        int32 offset_date,
        int64 offset_message_id,
        int64 offset_message_thread_id,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetForumTopics (
            chat_id,
            query,
            offset_date,
            offset_message_id,
            offset_message_thread_id,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_forum_topics.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ForumTopics out_obj;
        switch (tdlib_type) {
            case "forumTopics":
                out_obj = (ForumTopics) jsoner.deserialize_object (typeof (ForumTopics));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the notification settings of a forum topic
     * @param chat_id Chat identifier
     * @param message_thread_id Message thread identifier of the forum topic
     * @param notification_settings New notification settings for the forum
     * topic. If the topic is muted for more than 366 days, it is considered
     * to be muted forever
     */
    public async Ok set_forum_topic_notification_settings (
        int64 chat_id,
        int64 message_thread_id,
        ChatNotificationSettings notification_settings
    ) throws BadStatusCodeError {
        var obj = new SetForumTopicNotificationSettings (
            chat_id,
            message_thread_id,
            notification_settings
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_forum_topic_notification_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether a topic is closed in a forum supergroup chat; requires
     * can_manage_topics right in the supergroup unless the user is creator
     * of the topic
     * @param chat_id Identifier of the chat
     * @param message_thread_id Message thread identifier of the forum topic
     * @param is_closed Pass true to close the topic; pass false to reopen it
     */
    public async Ok toggle_forum_topic_is_closed (
        int64 chat_id,
        int64 message_thread_id,
        bool is_closed
    ) throws BadStatusCodeError {
        var obj = new ToggleForumTopicIsClosed (
            chat_id,
            message_thread_id,
            is_closed
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_forum_topic_is_closed.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether a General topic is hidden in a forum supergroup chat;
     * requires can_manage_topics right in the supergroup
     * @param chat_id Identifier of the chat
     * @param is_hidden Pass true to hide and close the General topic; pass
     * false to unhide it
     */
    public async Ok toggle_general_forum_topic_is_hidden (
        int64 chat_id,
        bool is_hidden
    ) throws BadStatusCodeError {
        var obj = new ToggleGeneralForumTopicIsHidden (
            chat_id,
            is_hidden
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_general_forum_topic_is_hidden.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the pinned state of a forum topic; requires can_manage_topics
     * right in the supergroup. There can be up to
     * getOption("pinned_forum_topic_count_max") pinned forum topics
     * @param chat_id Chat identifier
     * @param message_thread_id Message thread identifier of the forum topic
     * @param is_pinned Pass true to pin the topic; pass false to unpin it
     */
    public async Ok toggle_forum_topic_is_pinned (
        int64 chat_id,
        int64 message_thread_id,
        bool is_pinned
    ) throws BadStatusCodeError {
        var obj = new ToggleForumTopicIsPinned (
            chat_id,
            message_thread_id,
            is_pinned
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_forum_topic_is_pinned.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the order of pinned forum topics; requires can_manage_topics
     * right in the supergroup
     * @param chat_id Chat identifier
     * @param message_thread_ids The new list of pinned forum topics
     */
    public async Ok set_pinned_forum_topics (
        int64 chat_id,
        Gee.ArrayList<int64?> message_thread_ids
    ) throws BadStatusCodeError {
        var obj = new SetPinnedForumTopics (
            chat_id,
            message_thread_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_pinned_forum_topics.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes all messages in a forum topic; requires can_delete_messages
     * administrator right in the supergroup unless the user is creator of
     * the topic, the topic has no messages from other users and has at most
     * 11 messages
     * @param chat_id Identifier of the chat
     * @param message_thread_id Message thread identifier of the forum topic
     */
    public async Ok delete_forum_topic (
        int64 chat_id,
        int64 message_thread_id
    ) throws BadStatusCodeError {
        var obj = new DeleteForumTopic (
            chat_id,
            message_thread_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_forum_topic.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about an emoji reaction. Returns a 404 error if
     * the reaction is not found
     * @param emoji Text representation of the reaction
     */
    public async EmojiReaction get_emoji_reaction (
        string emoji
    ) throws BadStatusCodeError {
        var obj = new GetEmojiReaction (
            emoji
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_emoji_reaction.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        EmojiReaction out_obj;
        switch (tdlib_type) {
            case "emojiReaction":
                out_obj = (EmojiReaction) jsoner.deserialize_object (typeof (EmojiReaction));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns TGS stickers with generic animations for custom emoji
     * reactions
     */
    public async Stickers get_custom_emoji_reaction_animations () throws BadStatusCodeError {
        var obj = new GetCustomEmojiReactionAnimations ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_custom_emoji_reaction_animations.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Stickers out_obj;
        switch (tdlib_type) {
            case "stickers":
                out_obj = (Stickers) jsoner.deserialize_object (typeof (Stickers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns reactions, which can be added to a message. The list can
     * change after updateActiveEmojiReactions, updateChatAvailableReactions
     * for the chat, or updateMessageInteractionInfo for the message
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param row_size Number of reaction per row, 5-25
     */
    public async AvailableReactions get_message_available_reactions (
        int64 chat_id,
        int64 message_id,
        int32 row_size
    ) throws BadStatusCodeError {
        var obj = new GetMessageAvailableReactions (
            chat_id,
            message_id,
            row_size
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_available_reactions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        AvailableReactions out_obj;
        switch (tdlib_type) {
            case "availableReactions":
                out_obj = (AvailableReactions) jsoner.deserialize_object (typeof (AvailableReactions));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Clears the list of recently used reactions
     */
    public async Ok clear_recent_reactions () throws BadStatusCodeError {
        var obj = new ClearRecentReactions ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clear_recent_reactions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a reaction or a tag to a message. Use
     * getMessageAvailableReactions to receive the list of available
     * reactions for the message
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param reaction_type Type of the reaction to add. Use
     * addPendingPaidMessageReaction instead to add the paid reaction
     * @param is_big Pass true if the reaction is added with a big animation
     * @param update_recent_reactions Pass true if the reaction needs to be
     * added to recent reactions; tags are never added to the list of recent
     * reactions
     */
    public async Ok add_message_reaction (
        int64 chat_id,
        int64 message_id,
        ReactionType reaction_type,
        bool is_big,
        bool update_recent_reactions
    ) throws BadStatusCodeError {
        var obj = new AddMessageReaction (
            chat_id,
            message_id,
            reaction_type,
            is_big,
            update_recent_reactions
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_message_reaction.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes a reaction from a message. A chosen reaction can always be
     * removed
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param reaction_type Type of the reaction to remove. The paid reaction
     * can't be removed
     */
    public async Ok remove_message_reaction (
        int64 chat_id,
        int64 message_id,
        ReactionType reaction_type
    ) throws BadStatusCodeError {
        var obj = new RemoveMessageReaction (
            chat_id,
            message_id,
            reaction_type
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_message_reaction.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds the paid message reaction to a message. Use
     * getMessageAvailableReactions to check whether the reaction is
     * available for the message
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param star_count Number of Telegram Stars to be used for the
     * reaction. The total number of pending paid reactions must not exceed
     * getOption("paid_reaction_star_count_max")
     * @param use_default_is_anonymous Pass true if the user didn't choose
     * anonymity explicitly, for example, the reaction is set from the
     * message bubble
     * @param is_anonymous Pass true to make paid reaction of the user on the
     * message anonymous; pass false to make the user's profile visible among
     * top reactors. Ignored if use_default_is_anonymous == true
     */
    public async Ok add_pending_paid_message_reaction (
        int64 chat_id,
        int64 message_id,
        int64 star_count,
        bool use_default_is_anonymous,
        bool is_anonymous
    ) throws BadStatusCodeError {
        var obj = new AddPendingPaidMessageReaction (
            chat_id,
            message_id,
            star_count,
            use_default_is_anonymous,
            is_anonymous
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_pending_paid_message_reaction.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Applies all pending paid reactions on a message
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     */
    public async Ok commit_pending_paid_message_reactions (
        int64 chat_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new CommitPendingPaidMessageReactions (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (commit_pending_paid_message_reactions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes all pending paid reactions on a message
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     */
    public async Ok remove_pending_paid_message_reactions (
        int64 chat_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new RemovePendingPaidMessageReactions (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_pending_paid_message_reactions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes whether the paid message reaction of the user to a message is
     * anonymous. The message must have paid reaction added by the user
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param is_anonymous Pass true to make paid reaction of the user on the
     * message anonymous; pass false to make the user's profile visible among
     * top reactors
     */
    public async Ok toggle_paid_message_reaction_is_anonymous (
        int64 chat_id,
        int64 message_id,
        bool is_anonymous
    ) throws BadStatusCodeError {
        var obj = new TogglePaidMessageReactionIsAnonymous (
            chat_id,
            message_id,
            is_anonymous
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_paid_message_reaction_is_anonymous.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets reactions on a message; for bots only
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param reaction_types Types of the reaction to set; pass an empty list
     * to remove the reactions
     * @param is_big Pass true if the reactions are added with a big
     * animation
     */
    public async Ok set_message_reactions (
        int64 chat_id,
        int64 message_id,
        Gee.ArrayList<ReactionType?> reaction_types,
        bool is_big
    ) throws BadStatusCodeError {
        var obj = new SetMessageReactions (
            chat_id,
            message_id,
            reaction_types,
            is_big
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_message_reactions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns reactions added for a message, along with their sender
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message. Use
     * message.interaction_info.reactions.can_get_added_reactions to check
     * whether added reactions can be received for the message
     * @param reaction_type Type of the reactions to return; pass null to
     * return all added reactions; reactionTypePaid isn't supported
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of reactions to be returned; must be
     * positive and can't be greater than 100
     */
    public async AddedReactions get_message_added_reactions (
        int64 chat_id,
        int64 message_id,
        ReactionType reaction_type,
        string offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetMessageAddedReactions (
            chat_id,
            message_id,
            reaction_type,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_added_reactions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        AddedReactions out_obj;
        switch (tdlib_type) {
            case "addedReactions":
                out_obj = (AddedReactions) jsoner.deserialize_object (typeof (AddedReactions));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes type of default reaction for the current user
     * @param reaction_type New type of the default reaction. The paid
     * reaction can't be set as default
     */
    public async Ok set_default_reaction_type (
        ReactionType reaction_type
    ) throws BadStatusCodeError {
        var obj = new SetDefaultReactionType (
            reaction_type
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_default_reaction_type.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns tags used in Saved Messages or a Saved Messages topic
     * @param saved_messages_topic_id Identifier of Saved Messages topic
     * which tags will be returned; pass 0 to get all Saved Messages tags
     */
    public async SavedMessagesTags get_saved_messages_tags (
        int64 saved_messages_topic_id
    ) throws BadStatusCodeError {
        var obj = new GetSavedMessagesTags (
            saved_messages_topic_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_saved_messages_tags.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        SavedMessagesTags out_obj;
        switch (tdlib_type) {
            case "savedMessagesTags":
                out_obj = (SavedMessagesTags) jsoner.deserialize_object (typeof (SavedMessagesTags));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes label of a Saved Messages tag; for Telegram Premium users only
     * @param tag The tag which label will be changed
     * @param label New label for the tag; 0-12 characters
     */
    public async Ok set_saved_messages_tag_label (
        ReactionType tag,
        string label
    ) throws BadStatusCodeError {
        var obj = new SetSavedMessagesTagLabel (
            tag,
            label
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_saved_messages_tag_label.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a message effect. Returns a 404 error if the
     * effect is not found
     * @param effect_id Unique identifier of the effect
     */
    public async MessageEffect get_message_effect (
        int64 effect_id
    ) throws BadStatusCodeError {
        var obj = new GetMessageEffect (
            effect_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_effect.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        MessageEffect out_obj;
        switch (tdlib_type) {
            case "messageEffect":
                out_obj = (MessageEffect) jsoner.deserialize_object (typeof (MessageEffect));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for a given quote in a text. Returns found quote start
     * position in UTF-16 code units. Returns a 404 error if the quote is not
     * found. Can be called synchronously
     * @param text Text in which to search for the quote
     * @param quote Quote to search for
     * @param quote_position Approximate quote position in UTF-16 code units
     */
    public FoundPosition search_quote_sync (
        FormattedText text,
        FormattedText quote,
        int32 quote_position
    ) throws BadStatusCodeError {
        var obj = new SearchQuote (
            text,
            quote,
            quote_position
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundPosition out_obj;
        switch (tdlib_type) {
            case "foundPosition":
                out_obj = (FoundPosition) jsoner.deserialize_object (typeof (FoundPosition));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for a given quote in a text. Returns found quote start
     * position in UTF-16 code units. Returns a 404 error if the quote is not
     * found. Can be called synchronously
     * @param text Text in which to search for the quote
     * @param quote Quote to search for
     * @param quote_position Approximate quote position in UTF-16 code units
     */
    public async FoundPosition search_quote (
        FormattedText text,
        FormattedText quote,
        int32 quote_position
    ) throws BadStatusCodeError {
        var obj = new SearchQuote (
            text,
            quote,
            quote_position
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_quote.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundPosition out_obj;
        switch (tdlib_type) {
            case "foundPosition":
                out_obj = (FoundPosition) jsoner.deserialize_object (typeof (FoundPosition));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns all entities (mentions, hashtags, cashtags, bot commands, bank
     * card numbers, URLs, and email addresses) found in the text. Can be
     * called synchronously
     * @param text The text in which to look for entities
     */
    public TextEntities get_text_entities_sync (
        string text
    ) throws BadStatusCodeError {
        var obj = new GetTextEntities (
            text
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        TextEntities out_obj;
        switch (tdlib_type) {
            case "textEntities":
                out_obj = (TextEntities) jsoner.deserialize_object (typeof (TextEntities));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns all entities (mentions, hashtags, cashtags, bot commands, bank
     * card numbers, URLs, and email addresses) found in the text. Can be
     * called synchronously
     * @param text The text in which to look for entities
     */
    public async TextEntities get_text_entities (
        string text
    ) throws BadStatusCodeError {
        var obj = new GetTextEntities (
            text
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_text_entities.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        TextEntities out_obj;
        switch (tdlib_type) {
            case "textEntities":
                out_obj = (TextEntities) jsoner.deserialize_object (typeof (TextEntities));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Parses Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji,
     * BlockQuote, ExpandableBlockQuote, Code, Pre, PreCode, TextUrl
     * and MentionName entities from a marked-up text. Can be called
     * synchronously
     * @param text The text to parse
     * @param parse_mode Text parse mode
     */
    public FormattedText parse_text_entities_sync (
        string text,
        TextParseMode parse_mode
    ) throws BadStatusCodeError {
        var obj = new ParseTextEntities (
            text,
            parse_mode
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FormattedText out_obj;
        switch (tdlib_type) {
            case "formattedText":
                out_obj = (FormattedText) jsoner.deserialize_object (typeof (FormattedText));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Parses Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji,
     * BlockQuote, ExpandableBlockQuote, Code, Pre, PreCode, TextUrl
     * and MentionName entities from a marked-up text. Can be called
     * synchronously
     * @param text The text to parse
     * @param parse_mode Text parse mode
     */
    public async FormattedText parse_text_entities (
        string text,
        TextParseMode parse_mode
    ) throws BadStatusCodeError {
        var obj = new ParseTextEntities (
            text,
            parse_mode
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (parse_text_entities.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FormattedText out_obj;
        switch (tdlib_type) {
            case "formattedText":
                out_obj = (FormattedText) jsoner.deserialize_object (typeof (FormattedText));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Parses Markdown entities in a human-friendly format, ignoring markup
     * errors. Can be called synchronously
     * @param text The text to parse. For example, "__italic__
     * ~~strikethrough~~ ||spoiler|| **bold** `code` ```pre``` __[italic__
     * text_url](telegram.org) __italic**bold italic__bold**"
     */
    public FormattedText parse_markdown_sync (
        FormattedText text
    ) throws BadStatusCodeError {
        var obj = new ParseMarkdown (
            text
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FormattedText out_obj;
        switch (tdlib_type) {
            case "formattedText":
                out_obj = (FormattedText) jsoner.deserialize_object (typeof (FormattedText));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Parses Markdown entities in a human-friendly format, ignoring markup
     * errors. Can be called synchronously
     * @param text The text to parse. For example, "__italic__
     * ~~strikethrough~~ ||spoiler|| **bold** `code` ```pre``` __[italic__
     * text_url](telegram.org) __italic**bold italic__bold**"
     */
    public async FormattedText parse_markdown (
        FormattedText text
    ) throws BadStatusCodeError {
        var obj = new ParseMarkdown (
            text
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (parse_markdown.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FormattedText out_obj;
        switch (tdlib_type) {
            case "formattedText":
                out_obj = (FormattedText) jsoner.deserialize_object (typeof (FormattedText));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Replaces text entities with Markdown formatting in a human-friendly
     * format. Entities that can't be represented in Markdown unambiguously
     * are kept as is. Can be called synchronously
     * @param text The text
     */
    public FormattedText get_markdown_text_sync (
        FormattedText text
    ) throws BadStatusCodeError {
        var obj = new GetMarkdownText (
            text
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FormattedText out_obj;
        switch (tdlib_type) {
            case "formattedText":
                out_obj = (FormattedText) jsoner.deserialize_object (typeof (FormattedText));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Replaces text entities with Markdown formatting in a human-friendly
     * format. Entities that can't be represented in Markdown unambiguously
     * are kept as is. Can be called synchronously
     * @param text The text
     */
    public async FormattedText get_markdown_text (
        FormattedText text
    ) throws BadStatusCodeError {
        var obj = new GetMarkdownText (
            text
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_markdown_text.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FormattedText out_obj;
        switch (tdlib_type) {
            case "formattedText":
                out_obj = (FormattedText) jsoner.deserialize_object (typeof (FormattedText));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an emoji for the given country. Returns an empty string on
     * failure. Can be called synchronously
     * @param country_code A two-letter ISO 3166-1 alpha-2 country code as
     * received from getCountries
     */
    public Text get_country_flag_emoji_sync (
        string country_code
    ) throws BadStatusCodeError {
        var obj = new GetCountryFlagEmoji (
            country_code
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an emoji for the given country. Returns an empty string on
     * failure. Can be called synchronously
     * @param country_code A two-letter ISO 3166-1 alpha-2 country code as
     * received from getCountries
     */
    public async Text get_country_flag_emoji (
        string country_code
    ) throws BadStatusCodeError {
        var obj = new GetCountryFlagEmoji (
            country_code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_country_flag_emoji.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the MIME type of a file, guessed by its extension. Returns an
     * empty string on failure. Can be called synchronously
     * @param file_name The name of the file or path to the file
     */
    public Text get_file_mime_type_sync (
        string file_name
    ) throws BadStatusCodeError {
        var obj = new GetFileMimeType (
            file_name
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the MIME type of a file, guessed by its extension. Returns an
     * empty string on failure. Can be called synchronously
     * @param file_name The name of the file or path to the file
     */
    public async Text get_file_mime_type (
        string file_name
    ) throws BadStatusCodeError {
        var obj = new GetFileMimeType (
            file_name
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_file_mime_type.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the extension of a file, guessed by its MIME type. Returns an
     * empty string on failure. Can be called synchronously
     * @param mime_type The MIME type of the file
     */
    public Text get_file_extension_sync (
        string mime_type
    ) throws BadStatusCodeError {
        var obj = new GetFileExtension (
            mime_type
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the extension of a file, guessed by its MIME type. Returns an
     * empty string on failure. Can be called synchronously
     * @param mime_type The MIME type of the file
     */
    public async Text get_file_extension (
        string mime_type
    ) throws BadStatusCodeError {
        var obj = new GetFileExtension (
            mime_type
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_file_extension.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes potentially dangerous characters from the name of a file.
     * Returns an empty string on failure. Can be called synchronously
     * @param file_name File name or path to the file
     */
    public Text clean_file_name_sync (
        string file_name
    ) throws BadStatusCodeError {
        var obj = new CleanFileName (
            file_name
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes potentially dangerous characters from the name of a file.
     * Returns an empty string on failure. Can be called synchronously
     * @param file_name File name or path to the file
     */
    public async Text clean_file_name (
        string file_name
    ) throws BadStatusCodeError {
        var obj = new CleanFileName (
            file_name
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clean_file_name.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a string stored in the local database from the specified
     * localization target and language pack by its key. Returns a 404 error
     * if the string is not found. Can be called synchronously
     * @param language_pack_database_path Path to the language pack database
     * in which strings are stored
     * @param localization_target Localization target to which the language
     * pack belongs
     * @param language_pack_id Language pack identifier
     * @param key Language pack key of the string to be returned
     */
    public LanguagePackStringValue get_language_pack_string_sync (
        string language_pack_database_path,
        string localization_target,
        string language_pack_id,
        string key
    ) throws BadStatusCodeError {
        var obj = new GetLanguagePackString (
            language_pack_database_path,
            localization_target,
            language_pack_id,
            key
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        LanguagePackStringValue out_obj;
        switch (tdlib_type) {
            case "languagePackStringValueOrdinary":
                out_obj = (LanguagePackStringValueOrdinary) jsoner.deserialize_object (typeof (LanguagePackStringValueOrdinary));
                break;
            case "languagePackStringValuePluralized":
                out_obj = (LanguagePackStringValuePluralized) jsoner.deserialize_object (typeof (LanguagePackStringValuePluralized));
                break;
            case "languagePackStringValueDeleted":
                out_obj = (LanguagePackStringValueDeleted) jsoner.deserialize_object (typeof (LanguagePackStringValueDeleted));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a string stored in the local database from the specified
     * localization target and language pack by its key. Returns a 404 error
     * if the string is not found. Can be called synchronously
     * @param language_pack_database_path Path to the language pack database
     * in which strings are stored
     * @param localization_target Localization target to which the language
     * pack belongs
     * @param language_pack_id Language pack identifier
     * @param key Language pack key of the string to be returned
     */
    public async LanguagePackStringValue get_language_pack_string (
        string language_pack_database_path,
        string localization_target,
        string language_pack_id,
        string key
    ) throws BadStatusCodeError {
        var obj = new GetLanguagePackString (
            language_pack_database_path,
            localization_target,
            language_pack_id,
            key
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_language_pack_string.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        LanguagePackStringValue out_obj;
        switch (tdlib_type) {
            case "languagePackStringValueOrdinary":
                out_obj = (LanguagePackStringValueOrdinary) jsoner.deserialize_object (typeof (LanguagePackStringValueOrdinary));
                break;
            case "languagePackStringValuePluralized":
                out_obj = (LanguagePackStringValuePluralized) jsoner.deserialize_object (typeof (LanguagePackStringValuePluralized));
                break;
            case "languagePackStringValueDeleted":
                out_obj = (LanguagePackStringValueDeleted) jsoner.deserialize_object (typeof (LanguagePackStringValueDeleted));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Converts a JSON-serialized string to corresponding JsonValue object.
     * Can be called synchronously
     * @param json The JSON-serialized string
     */
    public JsonValue get_json_value_sync (
        string json
    ) throws BadStatusCodeError {
        var obj = new GetJsonValue (
            json
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        JsonValue out_obj;
        switch (tdlib_type) {
            case "jsonValueNull":
                out_obj = (JsonValueNull) jsoner.deserialize_object (typeof (JsonValueNull));
                break;
            case "jsonValueBoolean":
                out_obj = (JsonValueBoolean) jsoner.deserialize_object (typeof (JsonValueBoolean));
                break;
            case "jsonValueNumber":
                out_obj = (JsonValueNumber) jsoner.deserialize_object (typeof (JsonValueNumber));
                break;
            case "jsonValueString":
                out_obj = (JsonValueString) jsoner.deserialize_object (typeof (JsonValueString));
                break;
            case "jsonValueArray":
                out_obj = (JsonValueArray) jsoner.deserialize_object (typeof (JsonValueArray));
                break;
            case "jsonValueObject":
                out_obj = (JsonValueObject) jsoner.deserialize_object (typeof (JsonValueObject));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Converts a JSON-serialized string to corresponding JsonValue object.
     * Can be called synchronously
     * @param json The JSON-serialized string
     */
    public async JsonValue get_json_value (
        string json
    ) throws BadStatusCodeError {
        var obj = new GetJsonValue (
            json
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_json_value.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        JsonValue out_obj;
        switch (tdlib_type) {
            case "jsonValueNull":
                out_obj = (JsonValueNull) jsoner.deserialize_object (typeof (JsonValueNull));
                break;
            case "jsonValueBoolean":
                out_obj = (JsonValueBoolean) jsoner.deserialize_object (typeof (JsonValueBoolean));
                break;
            case "jsonValueNumber":
                out_obj = (JsonValueNumber) jsoner.deserialize_object (typeof (JsonValueNumber));
                break;
            case "jsonValueString":
                out_obj = (JsonValueString) jsoner.deserialize_object (typeof (JsonValueString));
                break;
            case "jsonValueArray":
                out_obj = (JsonValueArray) jsoner.deserialize_object (typeof (JsonValueArray));
                break;
            case "jsonValueObject":
                out_obj = (JsonValueObject) jsoner.deserialize_object (typeof (JsonValueObject));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Converts a JsonValue object to corresponding JSON-serialized string.
     * Can be called synchronously
     * @param json_value The JsonValue object
     */
    public Text get_json_string_sync (
        JsonValue json_value
    ) throws BadStatusCodeError {
        var obj = new GetJsonString (
            json_value
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Converts a JsonValue object to corresponding JSON-serialized string.
     * Can be called synchronously
     * @param json_value The JsonValue object
     */
    public async Text get_json_string (
        JsonValue json_value
    ) throws BadStatusCodeError {
        var obj = new GetJsonString (
            json_value
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_json_string.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Converts a themeParameters object to corresponding JSON-serialized
     * string. Can be called synchronously
     * @param theme Theme parameters to convert to JSON
     */
    public Text get_theme_parameters_json_string_sync (
        ThemeParameters theme
    ) throws BadStatusCodeError {
        var obj = new GetThemeParametersJsonString (
            theme
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Converts a themeParameters object to corresponding JSON-serialized
     * string. Can be called synchronously
     * @param theme Theme parameters to convert to JSON
     */
    public async Text get_theme_parameters_json_string (
        ThemeParameters theme
    ) throws BadStatusCodeError {
        var obj = new GetThemeParametersJsonString (
            theme
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_theme_parameters_json_string.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the user answer to a poll. A poll in quiz mode can be answered
     * only once
     * @param chat_id Identifier of the chat to which the poll belongs
     * @param message_id Identifier of the message containing the poll
     * @param option_ids 0-based identifiers of answer options, chosen by the
     * user. User can choose more than 1 answer option only is the poll
     * allows multiple answers
     */
    public async Ok set_poll_answer (
        int64 chat_id,
        int64 message_id,
        Gee.ArrayList<int32?> option_ids
    ) throws BadStatusCodeError {
        var obj = new SetPollAnswer (
            chat_id,
            message_id,
            option_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_poll_answer.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns message senders voted for the specified option in a
     * non-anonymous polls. For optimal performance, the number of returned
     * users is chosen by TDLib
     * @param chat_id Identifier of the chat to which the poll belongs
     * @param message_id Identifier of the message containing the poll
     * @param option_id 0-based identifier of the answer option
     * @param offset Number of voters to skip in the result; must be
     * non-negative
     * @param limit The maximum number of voters to be returned; must be
     * positive and can't be greater than 50. For optimal performance, the
     * number of returned voters is chosen by TDLib and can be smaller than
     * the specified limit, even if the end of the voter list has not been
     * reached
     */
    public async MessageSenders get_poll_voters (
        int64 chat_id,
        int64 message_id,
        int32 option_id,
        int32 offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetPollVoters (
            chat_id,
            message_id,
            option_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_poll_voters.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        MessageSenders out_obj;
        switch (tdlib_type) {
            case "messageSenders":
                out_obj = (MessageSenders) jsoner.deserialize_object (typeof (MessageSenders));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Stops a poll
     * @param chat_id Identifier of the chat to which the poll belongs
     * @param message_id Identifier of the message containing the poll. Use
     * messageProperties.can_be_edited to check whether the poll can be
     * stopped
     * @param reply_markup The new message reply markup; pass null if none;
     * for bots only
     */
    public async Ok stop_poll (
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup
    ) throws BadStatusCodeError {
        var obj = new StopPoll (
            chat_id,
            message_id,
            reply_markup
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (stop_poll.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Hides a suggested action
     * @param action Suggested action to hide
     */
    public async Ok hide_suggested_action (
        SuggestedAction action
    ) throws BadStatusCodeError {
        var obj = new HideSuggestedAction (
            action
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (hide_suggested_action.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Hides the list of contacts that have close birthdays for 24 hours
     */
    public async Ok hide_contact_close_birthdays () throws BadStatusCodeError {
        var obj = new HideContactCloseBirthdays ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (hide_contact_close_birthdays.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a business connection by its identifier; for
     * bots only
     * @param connection_id Identifier of the business connection to return
     */
    public async BusinessConnection get_business_connection (
        string connection_id
    ) throws BadStatusCodeError {
        var obj = new GetBusinessConnection (
            connection_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_business_connection.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BusinessConnection out_obj;
        switch (tdlib_type) {
            case "businessConnection":
                out_obj = (BusinessConnection) jsoner.deserialize_object (typeof (BusinessConnection));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a button of type
     * inlineKeyboardButtonTypeLoginUrl. The method needs to be called when
     * the user presses the button
     * @param chat_id Chat identifier of the message with the button
     * @param message_id Message identifier of the message with the button.
     * The message must not be scheduled
     * @param button_id Button identifier
     */
    public async LoginUrlInfo get_login_url_info (
        int64 chat_id,
        int64 message_id,
        int64 button_id
    ) throws BadStatusCodeError {
        var obj = new GetLoginUrlInfo (
            chat_id,
            message_id,
            button_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_login_url_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        LoginUrlInfo out_obj;
        switch (tdlib_type) {
            case "loginUrlInfoOpen":
                out_obj = (LoginUrlInfoOpen) jsoner.deserialize_object (typeof (LoginUrlInfoOpen));
                break;
            case "loginUrlInfoRequestConfirmation":
                out_obj = (LoginUrlInfoRequestConfirmation) jsoner.deserialize_object (typeof (LoginUrlInfoRequestConfirmation));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an HTTP URL which can be used to automatically authorize the
     * user on a website after clicking an inline button of type
     * inlineKeyboardButtonTypeLoginUrl.
     * Use the method getLoginUrlInfo to find whether a prior user
     * confirmation is needed. If an error is returned, then the button must
     * be handled as an ordinary URL button
     * @param chat_id Chat identifier of the message with the button
     * @param message_id Message identifier of the message with the button
     * @param button_id Button identifier
     * @param allow_write_access Pass true to allow the bot to send messages
     * to the current user
     */
    public async HttpUrl get_login_url (
        int64 chat_id,
        int64 message_id,
        int64 button_id,
        bool allow_write_access
    ) throws BadStatusCodeError {
        var obj = new GetLoginUrl (
            chat_id,
            message_id,
            button_id,
            allow_write_access
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_login_url.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        HttpUrl out_obj;
        switch (tdlib_type) {
            case "httpUrl":
                out_obj = (HttpUrl) jsoner.deserialize_object (typeof (HttpUrl));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Shares users after pressing a keyboardButtonTypeRequestUsers button
     * with the bot
     * @param chat_id Identifier of the chat with the bot
     * @param message_id Identifier of the message with the button
     * @param button_id Identifier of the button
     * @param shared_user_ids Identifiers of the shared users
     * @param only_check Pass true to check that the users can be shared by
     * the button instead of actually sharing them
     */
    public async Ok share_users_with_bot (
        int64 chat_id,
        int64 message_id,
        int32 button_id,
        Gee.ArrayList<int64?> shared_user_ids,
        bool only_check
    ) throws BadStatusCodeError {
        var obj = new ShareUsersWithBot (
            chat_id,
            message_id,
            button_id,
            shared_user_ids,
            only_check
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (share_users_with_bot.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Shares a chat after pressing a keyboardButtonTypeRequestChat button
     * with the bot
     * @param chat_id Identifier of the chat with the bot
     * @param message_id Identifier of the message with the button
     * @param button_id Identifier of the button
     * @param shared_chat_id Identifier of the shared chat
     * @param only_check Pass true to check that the chat can be shared by
     * the button instead of actually sharing it. Doesn't check bot_is_member
     * and bot_administrator_rights restrictions. If the bot must be a
     * member, then all chats from getGroupsInCommon and all chats, where the
     * user can add the bot, are suitable. In the latter case the bot will be
     * automatically added to the chat. If the bot must be an administrator,
     * then all chats, where the bot already has requested rights or can be
     * added to administrators by the user, are suitable. In the latter case
     * the bot will be automatically granted requested rights
     */
    public async Ok share_chat_with_bot (
        int64 chat_id,
        int64 message_id,
        int32 button_id,
        int64 shared_chat_id,
        bool only_check
    ) throws BadStatusCodeError {
        var obj = new ShareChatWithBot (
            chat_id,
            message_id,
            button_id,
            shared_chat_id,
            only_check
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (share_chat_with_bot.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends an inline query to a bot and returns its results. Returns an
     * error with code 502 if the bot fails to answer the query before the
     * query timeout expires
     * @param bot_user_id Identifier of the target bot
     * @param chat_id Identifier of the chat where the query was sent
     * @param user_location Location of the user; pass null if unknown or the
     * bot doesn't need user's location
     * @param query Text of the query
     * @param offset Offset of the first entry to return; use empty string to
     * get the first chunk of results
     */
    public async InlineQueryResults get_inline_query_results (
        int64 bot_user_id,
        int64 chat_id,
        Location user_location,
        string query,
        string offset
    ) throws BadStatusCodeError {
        var obj = new GetInlineQueryResults (
            bot_user_id,
            chat_id,
            user_location,
            query,
            offset
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_inline_query_results.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        InlineQueryResults out_obj;
        switch (tdlib_type) {
            case "inlineQueryResults":
                out_obj = (InlineQueryResults) jsoner.deserialize_object (typeof (InlineQueryResults));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the result of an inline query; for bots only
     * @param inline_query_id Identifier of the inline query
     * @param is_personal Pass true if results may be cached and returned
     * only for the user that sent the query. By default, results may be
     * returned to any user who sends the same query
     * @param button Button to be shown above inline query results; pass null
     * if none
     * @param results The results of the query
     * @param cache_time Allowed time to cache the results of the query, in
     * seconds
     * @param next_offset Offset for the next inline query; pass an empty
     * string if there are no more results
     */
    public async Ok answer_inline_query (
        int64 inline_query_id,
        bool is_personal,
        InlineQueryResultsButton button,
        Gee.ArrayList<InputInlineQueryResult?> results,
        int32 cache_time,
        string next_offset
    ) throws BadStatusCodeError {
        var obj = new AnswerInlineQuery (
            inline_query_id,
            is_personal,
            button,
            results,
            cache_time,
            next_offset
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (answer_inline_query.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Saves an inline message to be sent by the given user; for bots only
     * @param user_id Identifier of the user
     * @param result The description of the message
     * @param chat_types Types of the chats to which the message can be sent
     */
    public async PreparedInlineMessageId save_prepared_inline_message (
        int64 user_id,
        InputInlineQueryResult result,
        TargetChatTypes chat_types
    ) throws BadStatusCodeError {
        var obj = new SavePreparedInlineMessage (
            user_id,
            result,
            chat_types
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (save_prepared_inline_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PreparedInlineMessageId out_obj;
        switch (tdlib_type) {
            case "preparedInlineMessageId":
                out_obj = (PreparedInlineMessageId) jsoner.deserialize_object (typeof (PreparedInlineMessageId));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Saves an inline message to be sent by the given user; for bots only
     * @param bot_user_id Identifier of the bot that created the message
     * @param prepared_message_id Identifier of the prepared message
     */
    public async PreparedInlineMessage get_prepared_inline_message (
        int64 bot_user_id,
        string prepared_message_id
    ) throws BadStatusCodeError {
        var obj = new GetPreparedInlineMessage (
            bot_user_id,
            prepared_message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_prepared_inline_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PreparedInlineMessage out_obj;
        switch (tdlib_type) {
            case "preparedInlineMessage":
                out_obj = (PreparedInlineMessage) jsoner.deserialize_object (typeof (PreparedInlineMessage));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the most grossing Web App bots
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of bots to be returned; up to 100
     */
    public async FoundUsers get_grossing_web_app_bots (
        string offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetGrossingWebAppBots (
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_grossing_web_app_bots.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundUsers out_obj;
        switch (tdlib_type) {
            case "foundUsers":
                out_obj = (FoundUsers) jsoner.deserialize_object (typeof (FoundUsers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a Web App by its short name. Returns a 404
     * error if the Web App is not found
     * @param bot_user_id Identifier of the target bot
     * @param web_app_short_name Short name of the Web App
     */
    public async FoundWebApp search_web_app (
        int64 bot_user_id,
        string web_app_short_name
    ) throws BadStatusCodeError {
        var obj = new SearchWebApp (
            bot_user_id,
            web_app_short_name
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_web_app.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundWebApp out_obj;
        switch (tdlib_type) {
            case "foundWebApp":
                out_obj = (FoundWebApp) jsoner.deserialize_object (typeof (FoundWebApp));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a default placeholder for Web Apps of a bot; this is an
     * offline request. Returns a 404 error if the placeholder isn't known
     * @param bot_user_id Identifier of the target bot
     */
    public async Outline get_web_app_placeholder (
        int64 bot_user_id
    ) throws BadStatusCodeError {
        var obj = new GetWebAppPlaceholder (
            bot_user_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_web_app_placeholder.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Outline out_obj;
        switch (tdlib_type) {
            case "outline":
                out_obj = (Outline) jsoner.deserialize_object (typeof (Outline));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an HTTPS URL of a Web App to open after a link of the type
     * internalLinkTypeWebApp is clicked
     * @param chat_id Identifier of the chat in which the link was clicked;
     * pass 0 if none
     * @param bot_user_id Identifier of the target bot
     * @param web_app_short_name Short name of the Web App
     * @param start_parameter Start parameter from internalLinkTypeWebApp
     * @param allow_write_access Pass true if the current user allowed the
     * bot to send them messages
     * @param parameters Parameters to use to open the Web App
     */
    public async HttpUrl get_web_app_link_url (
        int64 chat_id,
        int64 bot_user_id,
        string web_app_short_name,
        string start_parameter,
        bool allow_write_access,
        WebAppOpenParameters parameters
    ) throws BadStatusCodeError {
        var obj = new GetWebAppLinkUrl (
            chat_id,
            bot_user_id,
            web_app_short_name,
            start_parameter,
            allow_write_access,
            parameters
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_web_app_link_url.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        HttpUrl out_obj;
        switch (tdlib_type) {
            case "httpUrl":
                out_obj = (HttpUrl) jsoner.deserialize_object (typeof (HttpUrl));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information needed to open the main Web App of a bot
     * @param chat_id Identifier of the chat in which the Web App is opened;
     * pass 0 if none
     * @param bot_user_id Identifier of the target bot
     * @param start_parameter Start parameter from internalLinkTypeMainWebApp
     * @param parameters Parameters to use to open the Web App
     */
    public async MainWebApp get_main_web_app (
        int64 chat_id,
        int64 bot_user_id,
        string start_parameter,
        WebAppOpenParameters parameters
    ) throws BadStatusCodeError {
        var obj = new GetMainWebApp (
            chat_id,
            bot_user_id,
            start_parameter,
            parameters
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_main_web_app.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        MainWebApp out_obj;
        switch (tdlib_type) {
            case "mainWebApp":
                out_obj = (MainWebApp) jsoner.deserialize_object (typeof (MainWebApp));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an HTTPS URL of a Web App to open from the side menu, a
     * keyboardButtonTypeWebApp button, or an
     * inlineQueryResultsButtonTypeWebApp button
     * @param bot_user_id Identifier of the target bot
     * @param url The URL from a keyboardButtonTypeWebApp button,
     * inlineQueryResultsButtonTypeWebApp button, or an empty string when the
     * bot is opened from the side menu
     * @param parameters Parameters to use to open the Web App
     */
    public async HttpUrl get_web_app_url (
        int64 bot_user_id,
        string url,
        WebAppOpenParameters parameters
    ) throws BadStatusCodeError {
        var obj = new GetWebAppUrl (
            bot_user_id,
            url,
            parameters
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_web_app_url.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        HttpUrl out_obj;
        switch (tdlib_type) {
            case "httpUrl":
                out_obj = (HttpUrl) jsoner.deserialize_object (typeof (HttpUrl));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends data received from a keyboardButtonTypeWebApp Web App to a bot
     * @param bot_user_id Identifier of the target bot
     * @param button_text Text of the keyboardButtonTypeWebApp button, which
     * opened the Web App
     * @param data The data
     */
    public async Ok send_web_app_data (
        int64 bot_user_id,
        string button_text,
        string data
    ) throws BadStatusCodeError {
        var obj = new SendWebAppData (
            bot_user_id,
            button_text,
            data
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_web_app_data.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs TDLib that a Web App is being opened from the attachment menu,
     * a botMenuButton button, an internalLinkTypeAttachmentMenuBot link, or
     * an inlineKeyboardButtonTypeWebApp button.
     * For each bot, a confirmation alert about data sent to the bot must be
     * shown once
     * @param chat_id Identifier of the chat in which the Web App is opened.
     * The Web App can't be opened in secret chats
     * @param bot_user_id Identifier of the bot, providing the Web App
     * @param url The URL from an inlineKeyboardButtonTypeWebApp button, a
     * botMenuButton button, an internalLinkTypeAttachmentMenuBot link, or an
     * empty string otherwise
     * @param message_thread_id If not 0, the message thread identifier in
     * which the message will be sent
     * @param reply_to Information about the message or story to be replied
     * in the message sent by the Web App; pass null if none
     * @param parameters Parameters to use to open the Web App
     */
    public async WebAppInfo open_web_app (
        int64 chat_id,
        int64 bot_user_id,
        string url,
        int64 message_thread_id,
        InputMessageReplyTo reply_to,
        WebAppOpenParameters parameters
    ) throws BadStatusCodeError {
        var obj = new OpenWebApp (
            chat_id,
            bot_user_id,
            url,
            message_thread_id,
            reply_to,
            parameters
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (open_web_app.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        WebAppInfo out_obj;
        switch (tdlib_type) {
            case "webAppInfo":
                out_obj = (WebAppInfo) jsoner.deserialize_object (typeof (WebAppInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs TDLib that a previously opened Web App was closed
     * @param web_app_launch_id Identifier of Web App launch, received from
     * openWebApp
     */
    public async Ok close_web_app (
        int64 web_app_launch_id
    ) throws BadStatusCodeError {
        var obj = new CloseWebApp (
            web_app_launch_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (close_web_app.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the result of interaction with a Web App and sends corresponding
     * message on behalf of the user to the chat from which the query
     * originated; for bots only
     * @param web_app_query_id Identifier of the Web App query
     * @param result The result of the query
     */
    public async SentWebAppMessage answer_web_app_query (
        string web_app_query_id,
        InputInlineQueryResult result
    ) throws BadStatusCodeError {
        var obj = new AnswerWebAppQuery (
            web_app_query_id,
            result
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (answer_web_app_query.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        SentWebAppMessage out_obj;
        switch (tdlib_type) {
            case "sentWebAppMessage":
                out_obj = (SentWebAppMessage) jsoner.deserialize_object (typeof (SentWebAppMessage));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks whether a file can be downloaded and saved locally by Web App
     * request
     * @param bot_user_id Identifier of the bot, providing the Web App
     * @param file_name Name of the file
     * @param url URL of the file
     */
    public async Ok check_web_app_file_download (
        int64 bot_user_id,
        string file_name,
        string url
    ) throws BadStatusCodeError {
        var obj = new CheckWebAppFileDownload (
            bot_user_id,
            file_name,
            url
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_web_app_file_download.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends a callback query to a bot and returns an answer. Returns an
     * error with code 502 if the bot fails to answer the query before the
     * query timeout expires
     * @param chat_id Identifier of the chat with the message
     * @param message_id Identifier of the message from which the query
     * originated. The message must not be scheduled
     * @param payload Query payload
     */
    public async CallbackQueryAnswer get_callback_query_answer (
        int64 chat_id,
        int64 message_id,
        CallbackQueryPayload payload
    ) throws BadStatusCodeError {
        var obj = new GetCallbackQueryAnswer (
            chat_id,
            message_id,
            payload
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_callback_query_answer.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        CallbackQueryAnswer out_obj;
        switch (tdlib_type) {
            case "callbackQueryAnswer":
                out_obj = (CallbackQueryAnswer) jsoner.deserialize_object (typeof (CallbackQueryAnswer));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the result of a callback query; for bots only
     * @param callback_query_id Identifier of the callback query
     * @param text Text of the answer
     * @param show_alert Pass true to show an alert to the user instead of a
     * toast notification
     * @param url URL to be opened
     * @param cache_time Time during which the result of the query can be
     * cached, in seconds
     */
    public async Ok answer_callback_query (
        int64 callback_query_id,
        string text,
        bool show_alert,
        string url,
        int32 cache_time
    ) throws BadStatusCodeError {
        var obj = new AnswerCallbackQuery (
            callback_query_id,
            text,
            show_alert,
            url,
            cache_time
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (answer_callback_query.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the result of a shipping query; for bots only
     * @param shipping_query_id Identifier of the shipping query
     * @param shipping_options Available shipping options
     * @param error_message An error message, empty on success
     */
    public async Ok answer_shipping_query (
        int64 shipping_query_id,
        Gee.ArrayList<ShippingOption?> shipping_options,
        string error_message
    ) throws BadStatusCodeError {
        var obj = new AnswerShippingQuery (
            shipping_query_id,
            shipping_options,
            error_message
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (answer_shipping_query.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the result of a pre-checkout query; for bots only
     * @param pre_checkout_query_id Identifier of the pre-checkout query
     * @param error_message An error message, empty on success
     */
    public async Ok answer_pre_checkout_query (
        int64 pre_checkout_query_id,
        string error_message
    ) throws BadStatusCodeError {
        var obj = new AnswerPreCheckoutQuery (
            pre_checkout_query_id,
            error_message
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (answer_pre_checkout_query.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Updates the game score of the specified user in the game; for bots
     * only
     * @param chat_id The chat to which the message with the game belongs
     * @param message_id Identifier of the message
     * @param edit_message Pass true to edit the game message to include the
     * current scoreboard
     * @param user_id User identifier
     * @param score The new score
     * @param force Pass true to update the score even if it decreases. If
     * the score is 0, the user will be deleted from the high score table
     */
    public async Message set_game_score (
        int64 chat_id,
        int64 message_id,
        bool edit_message,
        int64 user_id,
        int32 score,
        bool force
    ) throws BadStatusCodeError {
        var obj = new SetGameScore (
            chat_id,
            message_id,
            edit_message,
            user_id,
            score,
            force
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_game_score.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Message out_obj;
        switch (tdlib_type) {
            case "message":
                out_obj = (Message) jsoner.deserialize_object (typeof (Message));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Updates the game score of the specified user in a game; for bots only
     * @param inline_message_id Inline message identifier
     * @param edit_message Pass true to edit the game message to include the
     * current scoreboard
     * @param user_id User identifier
     * @param score The new score
     * @param force Pass true to update the score even if it decreases. If
     * the score is 0, the user will be deleted from the high score table
     */
    public async Ok set_inline_game_score (
        string inline_message_id,
        bool edit_message,
        int64 user_id,
        int32 score,
        bool force
    ) throws BadStatusCodeError {
        var obj = new SetInlineGameScore (
            inline_message_id,
            edit_message,
            user_id,
            score,
            force
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_inline_game_score.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the high scores for a game and some part of the high score
     * table in the range of the specified user; for bots only
     * @param chat_id The chat that contains the message with the game
     * @param message_id Identifier of the message
     * @param user_id User identifier
     */
    public async GameHighScores get_game_high_scores (
        int64 chat_id,
        int64 message_id,
        int64 user_id
    ) throws BadStatusCodeError {
        var obj = new GetGameHighScores (
            chat_id,
            message_id,
            user_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_game_high_scores.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        GameHighScores out_obj;
        switch (tdlib_type) {
            case "gameHighScores":
                out_obj = (GameHighScores) jsoner.deserialize_object (typeof (GameHighScores));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns game high scores and some part of the high score table in the
     * range of the specified user; for bots only
     * @param inline_message_id Inline message identifier
     * @param user_id User identifier
     */
    public async GameHighScores get_inline_game_high_scores (
        string inline_message_id,
        int64 user_id
    ) throws BadStatusCodeError {
        var obj = new GetInlineGameHighScores (
            inline_message_id,
            user_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_inline_game_high_scores.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        GameHighScores out_obj;
        switch (tdlib_type) {
            case "gameHighScores":
                out_obj = (GameHighScores) jsoner.deserialize_object (typeof (GameHighScores));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes the default reply markup from a chat. Must be called after a
     * one-time keyboard or a replyMarkupForceReply reply markup has been
     * used. An updateChatReplyMarkup update will be sent if the reply markup
     * is changed
     * @param chat_id Chat identifier
     * @param message_id The message identifier of the used keyboard
     */
    public async Ok delete_chat_reply_markup (
        int64 chat_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new DeleteChatReplyMarkup (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_chat_reply_markup.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends a notification about user activity in a chat
     * @param chat_id Chat identifier
     * @param message_thread_id If not 0, the message thread identifier in
     * which the action was performed
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which to send the request; for bots only
     * @param action The action description; pass null to cancel the
     * currently active action
     */
    public async Ok send_chat_action (
        int64 chat_id,
        int64 message_thread_id,
        string business_connection_id,
        ChatAction action
    ) throws BadStatusCodeError {
        var obj = new SendChatAction (
            chat_id,
            message_thread_id,
            business_connection_id,
            action
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_chat_action.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs TDLib that the chat is opened by the user. Many useful
     * activities depend on the chat being opened or closed (e.g., in
     * supergroups and channels all updates are received only for opened
     * chats)
     * @param chat_id Chat identifier
     */
    public async Ok open_chat (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new OpenChat (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (open_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs TDLib that the chat is closed by the user. Many useful
     * activities depend on the chat being opened or closed
     * @param chat_id Chat identifier
     */
    public async Ok close_chat (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new CloseChat (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (close_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs TDLib that messages are being viewed by the user. Sponsored
     * messages must be marked as viewed only when the entire text of the
     * message is shown on the screen (excluding the button).
     * Many useful activities depend on whether the messages are currently
     * being viewed or not (e.g., marking messages as read, incrementing a
     * view counter, updating a view counter, removing deleted messages in
     * supergroups and channels)
     * @param chat_id Chat identifier
     * @param message_ids The identifiers of the messages being viewed
     * @param source Source of the message view; pass null to guess the
     * source based on chat open state
     * @param force_read Pass true to mark as read the specified messages
     * even the chat is closed
     */
    public async Ok view_messages (
        int64 chat_id,
        Gee.ArrayList<int64?> message_ids,
        MessageSource source,
        bool force_read
    ) throws BadStatusCodeError {
        var obj = new ViewMessages (
            chat_id,
            message_ids,
            source,
            force_read
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (view_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs TDLib that the message content has been opened (e.g., the user
     * has opened a photo, video, document, location or venue, or has
     * listened to an audio file or voice note message).
     * An updateMessageContentOpened update will be generated if something
     * has changed
     * @param chat_id Chat identifier of the message
     * @param message_id Identifier of the message with the opened content
     */
    public async Ok open_message_content (
        int64 chat_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new OpenMessageContent (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (open_message_content.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs TDLib that a message with an animated emoji was clicked by the
     * user. Returns a big animated sticker to be played or a 404 error if
     * usual animation needs to be played
     * @param chat_id Chat identifier of the message
     * @param message_id Identifier of the clicked message
     */
    public async Sticker click_animated_emoji_message (
        int64 chat_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new ClickAnimatedEmojiMessage (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (click_animated_emoji_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Sticker out_obj;
        switch (tdlib_type) {
            case "sticker":
                out_obj = (Sticker) jsoner.deserialize_object (typeof (Sticker));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an HTTPS or a tg: link with the given type. Can be called
     * before authorization
     * @param type_ Expected type of the link
     * @param is_http Pass true to create an HTTPS link (only available for
     * some link types); pass false to create a tg: link
     */
    public async HttpUrl get_internal_link (
        InternalLinkType type_,
        bool is_http
    ) throws BadStatusCodeError {
        var obj = new GetInternalLink (
            type_,
            is_http
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_internal_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        HttpUrl out_obj;
        switch (tdlib_type) {
            case "httpUrl":
                out_obj = (HttpUrl) jsoner.deserialize_object (typeof (HttpUrl));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about the type of internal link. Returns a 404
     * error if the link is not internal. Can be called before authorization
     * @param link The link
     */
    public async InternalLinkType get_internal_link_type (
        string link
    ) throws BadStatusCodeError {
        var obj = new GetInternalLinkType (
            link
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_internal_link_type.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        InternalLinkType out_obj;
        switch (tdlib_type) {
            case "internalLinkTypeActiveSessions":
                out_obj = (InternalLinkTypeActiveSessions) jsoner.deserialize_object (typeof (InternalLinkTypeActiveSessions));
                break;
            case "internalLinkTypeAttachmentMenuBot":
                out_obj = (InternalLinkTypeAttachmentMenuBot) jsoner.deserialize_object (typeof (InternalLinkTypeAttachmentMenuBot));
                break;
            case "internalLinkTypeAuthenticationCode":
                out_obj = (InternalLinkTypeAuthenticationCode) jsoner.deserialize_object (typeof (InternalLinkTypeAuthenticationCode));
                break;
            case "internalLinkTypeBackground":
                out_obj = (InternalLinkTypeBackground) jsoner.deserialize_object (typeof (InternalLinkTypeBackground));
                break;
            case "internalLinkTypeBotAddToChannel":
                out_obj = (InternalLinkTypeBotAddToChannel) jsoner.deserialize_object (typeof (InternalLinkTypeBotAddToChannel));
                break;
            case "internalLinkTypeBotStart":
                out_obj = (InternalLinkTypeBotStart) jsoner.deserialize_object (typeof (InternalLinkTypeBotStart));
                break;
            case "internalLinkTypeBotStartInGroup":
                out_obj = (InternalLinkTypeBotStartInGroup) jsoner.deserialize_object (typeof (InternalLinkTypeBotStartInGroup));
                break;
            case "internalLinkTypeBusinessChat":
                out_obj = (InternalLinkTypeBusinessChat) jsoner.deserialize_object (typeof (InternalLinkTypeBusinessChat));
                break;
            case "internalLinkTypeBuyStars":
                out_obj = (InternalLinkTypeBuyStars) jsoner.deserialize_object (typeof (InternalLinkTypeBuyStars));
                break;
            case "internalLinkTypeChangePhoneNumber":
                out_obj = (InternalLinkTypeChangePhoneNumber) jsoner.deserialize_object (typeof (InternalLinkTypeChangePhoneNumber));
                break;
            case "internalLinkTypeChatBoost":
                out_obj = (InternalLinkTypeChatBoost) jsoner.deserialize_object (typeof (InternalLinkTypeChatBoost));
                break;
            case "internalLinkTypeChatFolderInvite":
                out_obj = (InternalLinkTypeChatFolderInvite) jsoner.deserialize_object (typeof (InternalLinkTypeChatFolderInvite));
                break;
            case "internalLinkTypeChatFolderSettings":
                out_obj = (InternalLinkTypeChatFolderSettings) jsoner.deserialize_object (typeof (InternalLinkTypeChatFolderSettings));
                break;
            case "internalLinkTypeChatInvite":
                out_obj = (InternalLinkTypeChatInvite) jsoner.deserialize_object (typeof (InternalLinkTypeChatInvite));
                break;
            case "internalLinkTypeDefaultMessageAutoDeleteTimerSettings":
                out_obj = (InternalLinkTypeDefaultMessageAutoDeleteTimerSettings) jsoner.deserialize_object (typeof (InternalLinkTypeDefaultMessageAutoDeleteTimerSettings));
                break;
            case "internalLinkTypeEditProfileSettings":
                out_obj = (InternalLinkTypeEditProfileSettings) jsoner.deserialize_object (typeof (InternalLinkTypeEditProfileSettings));
                break;
            case "internalLinkTypeGame":
                out_obj = (InternalLinkTypeGame) jsoner.deserialize_object (typeof (InternalLinkTypeGame));
                break;
            case "internalLinkTypeInstantView":
                out_obj = (InternalLinkTypeInstantView) jsoner.deserialize_object (typeof (InternalLinkTypeInstantView));
                break;
            case "internalLinkTypeInvoice":
                out_obj = (InternalLinkTypeInvoice) jsoner.deserialize_object (typeof (InternalLinkTypeInvoice));
                break;
            case "internalLinkTypeLanguagePack":
                out_obj = (InternalLinkTypeLanguagePack) jsoner.deserialize_object (typeof (InternalLinkTypeLanguagePack));
                break;
            case "internalLinkTypeLanguageSettings":
                out_obj = (InternalLinkTypeLanguageSettings) jsoner.deserialize_object (typeof (InternalLinkTypeLanguageSettings));
                break;
            case "internalLinkTypeMainWebApp":
                out_obj = (InternalLinkTypeMainWebApp) jsoner.deserialize_object (typeof (InternalLinkTypeMainWebApp));
                break;
            case "internalLinkTypeMessage":
                out_obj = (InternalLinkTypeMessage) jsoner.deserialize_object (typeof (InternalLinkTypeMessage));
                break;
            case "internalLinkTypeMessageDraft":
                out_obj = (InternalLinkTypeMessageDraft) jsoner.deserialize_object (typeof (InternalLinkTypeMessageDraft));
                break;
            case "internalLinkTypePassportDataRequest":
                out_obj = (InternalLinkTypePassportDataRequest) jsoner.deserialize_object (typeof (InternalLinkTypePassportDataRequest));
                break;
            case "internalLinkTypePhoneNumberConfirmation":
                out_obj = (InternalLinkTypePhoneNumberConfirmation) jsoner.deserialize_object (typeof (InternalLinkTypePhoneNumberConfirmation));
                break;
            case "internalLinkTypePremiumFeatures":
                out_obj = (InternalLinkTypePremiumFeatures) jsoner.deserialize_object (typeof (InternalLinkTypePremiumFeatures));
                break;
            case "internalLinkTypePremiumGift":
                out_obj = (InternalLinkTypePremiumGift) jsoner.deserialize_object (typeof (InternalLinkTypePremiumGift));
                break;
            case "internalLinkTypePremiumGiftCode":
                out_obj = (InternalLinkTypePremiumGiftCode) jsoner.deserialize_object (typeof (InternalLinkTypePremiumGiftCode));
                break;
            case "internalLinkTypePrivacyAndSecuritySettings":
                out_obj = (InternalLinkTypePrivacyAndSecuritySettings) jsoner.deserialize_object (typeof (InternalLinkTypePrivacyAndSecuritySettings));
                break;
            case "internalLinkTypeProxy":
                out_obj = (InternalLinkTypeProxy) jsoner.deserialize_object (typeof (InternalLinkTypeProxy));
                break;
            case "internalLinkTypePublicChat":
                out_obj = (InternalLinkTypePublicChat) jsoner.deserialize_object (typeof (InternalLinkTypePublicChat));
                break;
            case "internalLinkTypeQrCodeAuthentication":
                out_obj = (InternalLinkTypeQrCodeAuthentication) jsoner.deserialize_object (typeof (InternalLinkTypeQrCodeAuthentication));
                break;
            case "internalLinkTypeRestorePurchases":
                out_obj = (InternalLinkTypeRestorePurchases) jsoner.deserialize_object (typeof (InternalLinkTypeRestorePurchases));
                break;
            case "internalLinkTypeSettings":
                out_obj = (InternalLinkTypeSettings) jsoner.deserialize_object (typeof (InternalLinkTypeSettings));
                break;
            case "internalLinkTypeStickerSet":
                out_obj = (InternalLinkTypeStickerSet) jsoner.deserialize_object (typeof (InternalLinkTypeStickerSet));
                break;
            case "internalLinkTypeStory":
                out_obj = (InternalLinkTypeStory) jsoner.deserialize_object (typeof (InternalLinkTypeStory));
                break;
            case "internalLinkTypeTheme":
                out_obj = (InternalLinkTypeTheme) jsoner.deserialize_object (typeof (InternalLinkTypeTheme));
                break;
            case "internalLinkTypeThemeSettings":
                out_obj = (InternalLinkTypeThemeSettings) jsoner.deserialize_object (typeof (InternalLinkTypeThemeSettings));
                break;
            case "internalLinkTypeUnknownDeepLink":
                out_obj = (InternalLinkTypeUnknownDeepLink) jsoner.deserialize_object (typeof (InternalLinkTypeUnknownDeepLink));
                break;
            case "internalLinkTypeUnsupportedProxy":
                out_obj = (InternalLinkTypeUnsupportedProxy) jsoner.deserialize_object (typeof (InternalLinkTypeUnsupportedProxy));
                break;
            case "internalLinkTypeUserPhoneNumber":
                out_obj = (InternalLinkTypeUserPhoneNumber) jsoner.deserialize_object (typeof (InternalLinkTypeUserPhoneNumber));
                break;
            case "internalLinkTypeUserToken":
                out_obj = (InternalLinkTypeUserToken) jsoner.deserialize_object (typeof (InternalLinkTypeUserToken));
                break;
            case "internalLinkTypeVideoChat":
                out_obj = (InternalLinkTypeVideoChat) jsoner.deserialize_object (typeof (InternalLinkTypeVideoChat));
                break;
            case "internalLinkTypeWebApp":
                out_obj = (InternalLinkTypeWebApp) jsoner.deserialize_object (typeof (InternalLinkTypeWebApp));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about an action to be done when the current user
     * clicks an external link. Don't use this method for links from secret
     * chats if link preview is disabled in secret chats
     * @param link The link
     */
    public async LoginUrlInfo get_external_link_info (
        string link
    ) throws BadStatusCodeError {
        var obj = new GetExternalLinkInfo (
            link
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_external_link_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        LoginUrlInfo out_obj;
        switch (tdlib_type) {
            case "loginUrlInfoOpen":
                out_obj = (LoginUrlInfoOpen) jsoner.deserialize_object (typeof (LoginUrlInfoOpen));
                break;
            case "loginUrlInfoRequestConfirmation":
                out_obj = (LoginUrlInfoRequestConfirmation) jsoner.deserialize_object (typeof (LoginUrlInfoRequestConfirmation));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an HTTP URL which can be used to automatically authorize the
     * current user on a website after clicking an HTTP link. Use the method
     * getExternalLinkInfo to find whether a prior user confirmation is
     * needed
     * @param link The HTTP link
     * @param allow_write_access Pass true if the current user allowed the
     * bot, returned in getExternalLinkInfo, to send them messages
     */
    public async HttpUrl get_external_link (
        string link,
        bool allow_write_access
    ) throws BadStatusCodeError {
        var obj = new GetExternalLink (
            link,
            allow_write_access
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_external_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        HttpUrl out_obj;
        switch (tdlib_type) {
            case "httpUrl":
                out_obj = (HttpUrl) jsoner.deserialize_object (typeof (HttpUrl));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Marks all mentions in a chat as read
     * @param chat_id Chat identifier
     */
    public async Ok read_all_chat_mentions (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new ReadAllChatMentions (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (read_all_chat_mentions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Marks all mentions in a forum topic as read
     * @param chat_id Chat identifier
     * @param message_thread_id Message thread identifier in which mentions
     * are marked as read
     */
    public async Ok read_all_message_thread_mentions (
        int64 chat_id,
        int64 message_thread_id
    ) throws BadStatusCodeError {
        var obj = new ReadAllMessageThreadMentions (
            chat_id,
            message_thread_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (read_all_message_thread_mentions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Marks all reactions in a chat or a forum topic as read
     * @param chat_id Chat identifier
     */
    public async Ok read_all_chat_reactions (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new ReadAllChatReactions (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (read_all_chat_reactions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Marks all reactions in a forum topic as read
     * @param chat_id Chat identifier
     * @param message_thread_id Message thread identifier in which reactions
     * are marked as read
     */
    public async Ok read_all_message_thread_reactions (
        int64 chat_id,
        int64 message_thread_id
    ) throws BadStatusCodeError {
        var obj = new ReadAllMessageThreadReactions (
            chat_id,
            message_thread_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (read_all_message_thread_reactions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an existing chat corresponding to a given user
     * @param user_id User identifier
     * @param force Pass true to create the chat without a network request.
     * In this case all information about the chat except its type, title and
     * photo can be incorrect
     */
    public async Chat create_private_chat (
        int64 user_id,
        bool force
    ) throws BadStatusCodeError {
        var obj = new CreatePrivateChat (
            user_id,
            force
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_private_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chat out_obj;
        switch (tdlib_type) {
            case "chat":
                out_obj = (Chat) jsoner.deserialize_object (typeof (Chat));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an existing chat corresponding to a known basic group
     * @param basic_group_id Basic group identifier
     * @param force Pass true to create the chat without a network request.
     * In this case all information about the chat except its type, title and
     * photo can be incorrect
     */
    public async Chat create_basic_group_chat (
        int64 basic_group_id,
        bool force
    ) throws BadStatusCodeError {
        var obj = new CreateBasicGroupChat (
            basic_group_id,
            force
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_basic_group_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chat out_obj;
        switch (tdlib_type) {
            case "chat":
                out_obj = (Chat) jsoner.deserialize_object (typeof (Chat));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an existing chat corresponding to a known supergroup or
     * channel
     * @param supergroup_id Supergroup or channel identifier
     * @param force Pass true to create the chat without a network request.
     * In this case all information about the chat except its type, title and
     * photo can be incorrect
     */
    public async Chat create_supergroup_chat (
        int64 supergroup_id,
        bool force
    ) throws BadStatusCodeError {
        var obj = new CreateSupergroupChat (
            supergroup_id,
            force
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_supergroup_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chat out_obj;
        switch (tdlib_type) {
            case "chat":
                out_obj = (Chat) jsoner.deserialize_object (typeof (Chat));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an existing chat corresponding to a known secret chat
     * @param secret_chat_id Secret chat identifier
     */
    public async Chat create_secret_chat (
        int32 secret_chat_id
    ) throws BadStatusCodeError {
        var obj = new CreateSecretChat (
            secret_chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_secret_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chat out_obj;
        switch (tdlib_type) {
            case "chat":
                out_obj = (Chat) jsoner.deserialize_object (typeof (Chat));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Creates a new basic group and sends a corresponding
     * messageBasicGroupChatCreate. Returns information about the newly
     * created chat
     * @param user_ids Identifiers of users to be added to the basic group;
     * may be empty to create a basic group without other members
     * @param title Title of the new basic group; 1-128 characters
     * @param message_auto_delete_time Message auto-delete time value, in
     * seconds; must be from 0 up to 365 * 86400 and be divisible by 86400.
     * If 0, then messages aren't deleted automatically
     */
    public async CreatedBasicGroupChat create_new_basic_group_chat (
        Gee.ArrayList<int64?> user_ids,
        string title,
        int32 message_auto_delete_time
    ) throws BadStatusCodeError {
        var obj = new CreateNewBasicGroupChat (
            user_ids,
            title,
            message_auto_delete_time
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_new_basic_group_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        CreatedBasicGroupChat out_obj;
        switch (tdlib_type) {
            case "createdBasicGroupChat":
                out_obj = (CreatedBasicGroupChat) jsoner.deserialize_object (typeof (CreatedBasicGroupChat));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Creates a new supergroup or channel and sends a corresponding
     * messageSupergroupChatCreate. Returns the newly created chat
     * @param title Title of the new chat; 1-128 characters
     * @param is_forum Pass true to create a forum supergroup chat
     * @param is_channel Pass true to create a channel chat; ignored if a
     * forum is created
     * @param description Chat description; 0-255 characters
     * @param location Chat location if a location-based supergroup is being
     * created; pass null to create an ordinary supergroup chat
     * @param message_auto_delete_time Message auto-delete time value, in
     * seconds; must be from 0 up to 365 * 86400 and be divisible by 86400.
     * If 0, then messages aren't deleted automatically
     * @param for_import Pass true to create a supergroup for importing
     * messages using importMessages
     */
    public async Chat create_new_supergroup_chat (
        string title,
        bool is_forum,
        bool is_channel,
        string description,
        ChatLocation location,
        int32 message_auto_delete_time,
        bool for_import
    ) throws BadStatusCodeError {
        var obj = new CreateNewSupergroupChat (
            title,
            is_forum,
            is_channel,
            description,
            location,
            message_auto_delete_time,
            for_import
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_new_supergroup_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chat out_obj;
        switch (tdlib_type) {
            case "chat":
                out_obj = (Chat) jsoner.deserialize_object (typeof (Chat));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Creates a new secret chat. Returns the newly created chat
     * @param user_id Identifier of the target user
     */
    public async Chat create_new_secret_chat (
        int64 user_id
    ) throws BadStatusCodeError {
        var obj = new CreateNewSecretChat (
            user_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_new_secret_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chat out_obj;
        switch (tdlib_type) {
            case "chat":
                out_obj = (Chat) jsoner.deserialize_object (typeof (Chat));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Creates a new supergroup from an existing basic group and sends a
     * corresponding messageChatUpgradeTo and messageChatUpgradeFrom;
     * requires owner privileges. Deactivates the original basic group
     * @param chat_id Identifier of the chat to upgrade
     */
    public async Chat upgrade_basic_group_chat_to_supergroup_chat (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new UpgradeBasicGroupChatToSupergroupChat (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (upgrade_basic_group_chat_to_supergroup_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chat out_obj;
        switch (tdlib_type) {
            case "chat":
                out_obj = (Chat) jsoner.deserialize_object (typeof (Chat));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns chat lists to which the chat can be added. This is an offline
     * request
     * @param chat_id Chat identifier
     */
    public async ChatLists get_chat_lists_to_add_chat (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new GetChatListsToAddChat (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_lists_to_add_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatLists out_obj;
        switch (tdlib_type) {
            case "chatLists":
                out_obj = (ChatLists) jsoner.deserialize_object (typeof (ChatLists));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a chat to a chat list. A chat can't be simultaneously in Main and
     * Archive chat lists, so it is automatically removed from another one if
     * needed
     * @param chat_id Chat identifier
     * @param chat_list The chat list. Use getChatListsToAddChat to get
     * suitable chat lists
     */
    public async Ok add_chat_to_list (
        int64 chat_id,
        ChatList chat_list
    ) throws BadStatusCodeError {
        var obj = new AddChatToList (
            chat_id,
            chat_list
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_chat_to_list.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a chat folder by its identifier
     * @param chat_folder_id Chat folder identifier
     */
    public async ChatFolder get_chat_folder (
        int32 chat_folder_id
    ) throws BadStatusCodeError {
        var obj = new GetChatFolder (
            chat_folder_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_folder.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatFolder out_obj;
        switch (tdlib_type) {
            case "chatFolder":
                out_obj = (ChatFolder) jsoner.deserialize_object (typeof (ChatFolder));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Creates new chat folder. Returns information about the created chat
     * folder. There can be up to getOption("chat_folder_count_max") chat
     * folders, but the limit can be increased with Telegram Premium
     * @param folder The new chat folder
     */
    public async ChatFolderInfo create_chat_folder (
        ChatFolder folder
    ) throws BadStatusCodeError {
        var obj = new CreateChatFolder (
            folder
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_chat_folder.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatFolderInfo out_obj;
        switch (tdlib_type) {
            case "chatFolderInfo":
                out_obj = (ChatFolderInfo) jsoner.deserialize_object (typeof (ChatFolderInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits existing chat folder. Returns information about the edited chat
     * folder
     * @param chat_folder_id Chat folder identifier
     * @param folder The edited chat folder
     */
    public async ChatFolderInfo edit_chat_folder (
        int32 chat_folder_id,
        ChatFolder folder
    ) throws BadStatusCodeError {
        var obj = new EditChatFolder (
            chat_folder_id,
            folder
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_chat_folder.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatFolderInfo out_obj;
        switch (tdlib_type) {
            case "chatFolderInfo":
                out_obj = (ChatFolderInfo) jsoner.deserialize_object (typeof (ChatFolderInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes existing chat folder
     * @param chat_folder_id Chat folder identifier
     * @param leave_chat_ids Identifiers of the chats to leave. The chats
     * must be pinned or always included in the folder
     */
    public async Ok delete_chat_folder (
        int32 chat_folder_id,
        Gee.ArrayList<int64?> leave_chat_ids
    ) throws BadStatusCodeError {
        var obj = new DeleteChatFolder (
            chat_folder_id,
            leave_chat_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_chat_folder.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns identifiers of pinned or always included chats from a chat
     * folder, which are suggested to be left when the chat folder is deleted
     * @param chat_folder_id Chat folder identifier
     */
    public async Chats get_chat_folder_chats_to_leave (
        int32 chat_folder_id
    ) throws BadStatusCodeError {
        var obj = new GetChatFolderChatsToLeave (
            chat_folder_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_folder_chats_to_leave.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns approximate number of chats in a being created chat folder.
     * Main and archive chat lists must be fully preloaded for this function
     * to work correctly
     * @param folder The new chat folder
     */
    public async Count get_chat_folder_chat_count (
        ChatFolder folder
    ) throws BadStatusCodeError {
        var obj = new GetChatFolderChatCount (
            folder
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_folder_chat_count.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Count out_obj;
        switch (tdlib_type) {
            case "count":
                out_obj = (Count) jsoner.deserialize_object (typeof (Count));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the order of chat folders
     * @param chat_folder_ids Identifiers of chat folders in the new correct
     * order
     * @param main_chat_list_position Position of the main chat list among
     * chat folders, 0-based. Can be non-zero only for Premium users
     */
    public async Ok reorder_chat_folders (
        Gee.ArrayList<int32?> chat_folder_ids,
        int32 main_chat_list_position
    ) throws BadStatusCodeError {
        var obj = new ReorderChatFolders (
            chat_folder_ids,
            main_chat_list_position
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reorder_chat_folders.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether chat folder tags are enabled
     * @param are_tags_enabled Pass true to enable folder tags; pass false to
     * disable them
     */
    public async Ok toggle_chat_folder_tags (
        bool are_tags_enabled
    ) throws BadStatusCodeError {
        var obj = new ToggleChatFolderTags (
            are_tags_enabled
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_chat_folder_tags.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns recommended chat folders for the current user
     */
    public async RecommendedChatFolders get_recommended_chat_folders () throws BadStatusCodeError {
        var obj = new GetRecommendedChatFolders ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_recommended_chat_folders.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        RecommendedChatFolders out_obj;
        switch (tdlib_type) {
            case "recommendedChatFolders":
                out_obj = (RecommendedChatFolders) jsoner.deserialize_object (typeof (RecommendedChatFolders));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns default icon name for a folder. Can be called synchronously
     * @param folder Chat folder
     */
    public ChatFolderIcon get_chat_folder_default_icon_name_sync (
        ChatFolder folder
    ) throws BadStatusCodeError {
        var obj = new GetChatFolderDefaultIconName (
            folder
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatFolderIcon out_obj;
        switch (tdlib_type) {
            case "chatFolderIcon":
                out_obj = (ChatFolderIcon) jsoner.deserialize_object (typeof (ChatFolderIcon));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns default icon name for a folder. Can be called synchronously
     * @param folder Chat folder
     */
    public async ChatFolderIcon get_chat_folder_default_icon_name (
        ChatFolder folder
    ) throws BadStatusCodeError {
        var obj = new GetChatFolderDefaultIconName (
            folder
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_folder_default_icon_name.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatFolderIcon out_obj;
        switch (tdlib_type) {
            case "chatFolderIcon":
                out_obj = (ChatFolderIcon) jsoner.deserialize_object (typeof (ChatFolderIcon));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns identifiers of chats from a chat folder, suitable for adding
     * to a chat folder invite link
     * @param chat_folder_id Chat folder identifier
     */
    public async Chats get_chats_for_chat_folder_invite_link (
        int32 chat_folder_id
    ) throws BadStatusCodeError {
        var obj = new GetChatsForChatFolderInviteLink (
            chat_folder_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chats_for_chat_folder_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Creates a new invite link for a chat folder. A link can be created for
     * a chat folder if it has only pinned and included chats
     * @param chat_folder_id Chat folder identifier
     * @param name Name of the link; 0-32 characters
     * @param chat_ids Identifiers of chats to be accessible by the invite
     * link. Use getChatsForChatFolderInviteLink to get suitable chats. Basic
     * groups will be automatically converted to supergroups before link
     * creation
     */
    public async ChatFolderInviteLink create_chat_folder_invite_link (
        int32 chat_folder_id,
        string name,
        Gee.ArrayList<int64?> chat_ids
    ) throws BadStatusCodeError {
        var obj = new CreateChatFolderInviteLink (
            chat_folder_id,
            name,
            chat_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_chat_folder_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatFolderInviteLink out_obj;
        switch (tdlib_type) {
            case "chatFolderInviteLink":
                out_obj = (ChatFolderInviteLink) jsoner.deserialize_object (typeof (ChatFolderInviteLink));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns invite links created by the current user for a shareable chat
     * folder
     * @param chat_folder_id Chat folder identifier
     */
    public async ChatFolderInviteLinks get_chat_folder_invite_links (
        int32 chat_folder_id
    ) throws BadStatusCodeError {
        var obj = new GetChatFolderInviteLinks (
            chat_folder_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_folder_invite_links.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatFolderInviteLinks out_obj;
        switch (tdlib_type) {
            case "chatFolderInviteLinks":
                out_obj = (ChatFolderInviteLinks) jsoner.deserialize_object (typeof (ChatFolderInviteLinks));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits an invite link for a chat folder
     * @param chat_folder_id Chat folder identifier
     * @param invite_link Invite link to be edited
     * @param name New name of the link; 0-32 characters
     * @param chat_ids New identifiers of chats to be accessible by the
     * invite link. Use getChatsForChatFolderInviteLink to get suitable
     * chats. Basic groups will be automatically converted to supergroups
     * before link editing
     */
    public async ChatFolderInviteLink edit_chat_folder_invite_link (
        int32 chat_folder_id,
        string invite_link,
        string name,
        Gee.ArrayList<int64?> chat_ids
    ) throws BadStatusCodeError {
        var obj = new EditChatFolderInviteLink (
            chat_folder_id,
            invite_link,
            name,
            chat_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_chat_folder_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatFolderInviteLink out_obj;
        switch (tdlib_type) {
            case "chatFolderInviteLink":
                out_obj = (ChatFolderInviteLink) jsoner.deserialize_object (typeof (ChatFolderInviteLink));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes an invite link for a chat folder
     * @param chat_folder_id Chat folder identifier
     * @param invite_link Invite link to be deleted
     */
    public async Ok delete_chat_folder_invite_link (
        int32 chat_folder_id,
        string invite_link
    ) throws BadStatusCodeError {
        var obj = new DeleteChatFolderInviteLink (
            chat_folder_id,
            invite_link
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_chat_folder_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks the validity of an invite link for a chat folder and returns
     * information about the corresponding chat folder
     * @param invite_link Invite link to be checked
     */
    public async ChatFolderInviteLinkInfo check_chat_folder_invite_link (
        string invite_link
    ) throws BadStatusCodeError {
        var obj = new CheckChatFolderInviteLink (
            invite_link
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_chat_folder_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatFolderInviteLinkInfo out_obj;
        switch (tdlib_type) {
            case "chatFolderInviteLinkInfo":
                out_obj = (ChatFolderInviteLinkInfo) jsoner.deserialize_object (typeof (ChatFolderInviteLinkInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a chat folder by an invite link
     * @param invite_link Invite link for the chat folder
     * @param chat_ids Identifiers of the chats added to the chat folder. The
     * chats are automatically joined if they aren't joined yet
     */
    public async Ok add_chat_folder_by_invite_link (
        string invite_link,
        Gee.ArrayList<int64?> chat_ids
    ) throws BadStatusCodeError {
        var obj = new AddChatFolderByInviteLink (
            invite_link,
            chat_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_chat_folder_by_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns new chats added to a shareable chat folder by its owner. The
     * method must be called at most once in
     * getOption("chat_folder_new_chats_update_period") for the given chat
     * folder
     * @param chat_folder_id Chat folder identifier
     */
    public async Chats get_chat_folder_new_chats (
        int32 chat_folder_id
    ) throws BadStatusCodeError {
        var obj = new GetChatFolderNewChats (
            chat_folder_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_folder_new_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Process new chats added to a shareable chat folder by its owner
     * @param chat_folder_id Chat folder identifier
     * @param added_chat_ids Identifiers of the new chats, which are added to
     * the chat folder. The chats are automatically joined if they aren't
     * joined yet
     */
    public async Ok process_chat_folder_new_chats (
        int32 chat_folder_id,
        Gee.ArrayList<int64?> added_chat_ids
    ) throws BadStatusCodeError {
        var obj = new ProcessChatFolderNewChats (
            chat_folder_id,
            added_chat_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (process_chat_folder_new_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns settings for automatic moving of chats to and from the Archive
     * chat lists
     */
    public async ArchiveChatListSettings get_archive_chat_list_settings () throws BadStatusCodeError {
        var obj = new GetArchiveChatListSettings ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_archive_chat_list_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ArchiveChatListSettings out_obj;
        switch (tdlib_type) {
            case "archiveChatListSettings":
                out_obj = (ArchiveChatListSettings) jsoner.deserialize_object (typeof (ArchiveChatListSettings));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes settings for automatic moving of chats to and from the Archive
     * chat lists
     * @param settings New settings
     */
    public async Ok set_archive_chat_list_settings (
        ArchiveChatListSettings settings
    ) throws BadStatusCodeError {
        var obj = new SetArchiveChatListSettings (
            settings
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_archive_chat_list_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the chat title. Supported only for basic groups, supergroups
     * and channels. Requires can_change_info member right
     * @param chat_id Chat identifier
     * @param title New title of the chat; 1-128 characters
     */
    public async Ok set_chat_title (
        int64 chat_id,
        string title
    ) throws BadStatusCodeError {
        var obj = new SetChatTitle (
            chat_id,
            title
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_title.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the photo of a chat. Supported only for basic groups,
     * supergroups and channels. Requires can_change_info member right
     * @param chat_id Chat identifier
     * @param photo New chat photo; pass null to delete the chat photo
     */
    public async Ok set_chat_photo (
        int64 chat_id,
        InputChatPhoto photo
    ) throws BadStatusCodeError {
        var obj = new SetChatPhoto (
            chat_id,
            photo
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_photo.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes accent color and background custom emoji of a channel chat.
     * Requires can_change_info administrator right
     * @param chat_id Chat identifier
     * @param accent_color_id Identifier of the accent color to use. The chat
     * must have at least accentColor.min_channel_chat_boost_level boost
     * level to pass the corresponding color
     * @param background_custom_emoji_id Identifier of a custom emoji to be
     * shown on the reply header and link preview background; 0 if none. Use
     * chatBoostLevelFeatures.can_set_background_custom_emoji to check
     * whether a custom emoji can be set
     */
    public async Ok set_chat_accent_color (
        int64 chat_id,
        int32 accent_color_id,
        int64 background_custom_emoji_id
    ) throws BadStatusCodeError {
        var obj = new SetChatAccentColor (
            chat_id,
            accent_color_id,
            background_custom_emoji_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_accent_color.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes accent color and background custom emoji for profile of a
     * supergroup or channel chat. Requires can_change_info administrator
     * right
     * @param chat_id Chat identifier
     * @param profile_accent_color_id Identifier of the accent color to use
     * for profile; pass -1 if none. The chat must have at least
     * profileAccentColor.min_supergroup_chat_boost_level for supergroups or
     * profileAccentColor.min_channel_chat_boost_level for channels boost
     * level to pass the corresponding color
     * @param profile_background_custom_emoji_id Identifier of a custom emoji
     * to be shown on the chat's profile photo background; 0 if none. Use
     * chatBoostLevelFeatures.can_set_profile_background_custom_emoji to
     * check whether a custom emoji can be set
     */
    public async Ok set_chat_profile_accent_color (
        int64 chat_id,
        int32 profile_accent_color_id,
        int64 profile_background_custom_emoji_id
    ) throws BadStatusCodeError {
        var obj = new SetChatProfileAccentColor (
            chat_id,
            profile_accent_color_id,
            profile_background_custom_emoji_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_profile_accent_color.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the message auto-delete or self-destruct (for secret chats)
     * time in a chat. Requires change_info administrator right in basic
     * groups, supergroups and channels.
     * Message auto-delete time can't be changed in a chat with the current
     * user (Saved Messages) and the chat 777000 (Telegram).
     * @param chat_id Chat identifier
     * @param message_auto_delete_time New time value, in seconds; unless the
     * chat is secret, it must be from 0 up to 365 * 86400 and be divisible
     * by 86400. If 0, then messages aren't deleted automatically
     */
    public async Ok set_chat_message_auto_delete_time (
        int64 chat_id,
        int32 message_auto_delete_time
    ) throws BadStatusCodeError {
        var obj = new SetChatMessageAutoDeleteTime (
            chat_id,
            message_auto_delete_time
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_message_auto_delete_time.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the emoji status of a chat. Use
     * chatBoostLevelFeatures.can_set_emoji_status to check whether an emoji
     * status can be set. Requires can_change_info administrator right
     * @param chat_id Chat identifier
     * @param emoji_status New emoji status; pass null to remove emoji status
     */
    public async Ok set_chat_emoji_status (
        int64 chat_id,
        EmojiStatus emoji_status
    ) throws BadStatusCodeError {
        var obj = new SetChatEmojiStatus (
            chat_id,
            emoji_status
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_emoji_status.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the chat members permissions. Supported only for basic groups
     * and supergroups. Requires can_restrict_members administrator right
     * @param chat_id Chat identifier
     * @param permissions New non-administrator members permissions in the
     * chat
     */
    public async Ok set_chat_permissions (
        int64 chat_id,
        ChatPermissions permissions
    ) throws BadStatusCodeError {
        var obj = new SetChatPermissions (
            chat_id,
            permissions
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_permissions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the background in a specific chat. Supported only in private and
     * secret chats with non-deleted users, and in chats with sufficient
     * boost level and can_change_info administrator right
     * @param chat_id Chat identifier
     * @param background The input background to use; pass null to create a
     * new filled or chat theme background
     * @param type_ Background type; pass null to use default background type
     * for the chosen background; backgroundTypeChatTheme isn't supported for
     * private and secret chats. Use
     * chatBoostLevelFeatures.chat_theme_background_count and
     * chatBoostLevelFeatures.can_set_custom_background to check whether the
     * background type can be set in the boosted chat
     * @param dark_theme_dimming Dimming of the background in dark themes, as
     * a percentage; 0-100. Applied only to Wallpaper and Fill types of
     * background
     * @param only_for_self Pass true to set background only for self; pass
     * false to set background for all chat users. Always false for
     * backgrounds set in boosted chats. Background can be set for both users
     * only by Telegram Premium users and if set background isn't of the type
     * inputBackgroundPrevious
     */
    public async Ok set_chat_background (
        int64 chat_id,
        InputBackground background,
        BackgroundType type_,
        int32 dark_theme_dimming,
        bool only_for_self
    ) throws BadStatusCodeError {
        var obj = new SetChatBackground (
            chat_id,
            background,
            type_,
            dark_theme_dimming,
            only_for_self
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_background.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes background in a specific chat
     * @param chat_id Chat identifier
     * @param restore_previous Pass true to restore previously set
     * background. Can be used only in private and secret chats with
     * non-deleted users if userFullInfo.set_chat_background == true.
     * Supposed to be used from messageChatSetBackground messages with the
     * currently set background that was set for both sides by the other user
     */
    public async Ok delete_chat_background (
        int64 chat_id,
        bool restore_previous
    ) throws BadStatusCodeError {
        var obj = new DeleteChatBackground (
            chat_id,
            restore_previous
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_chat_background.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the chat theme. Supported only in private and secret chats
     * @param chat_id Chat identifier
     * @param theme_name Name of the new chat theme; pass an empty string to
     * return the default theme
     */
    public async Ok set_chat_theme (
        int64 chat_id,
        string theme_name
    ) throws BadStatusCodeError {
        var obj = new SetChatTheme (
            chat_id,
            theme_name
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_theme.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the draft message in a chat
     * @param chat_id Chat identifier
     * @param message_thread_id If not 0, the message thread identifier in
     * which the draft was changed
     * @param draft_message New draft message; pass null to remove the draft.
     * All files in draft message content must be of the type inputFileLocal.
     * Media thumbnails and captions are ignored
     */
    public async Ok set_chat_draft_message (
        int64 chat_id,
        int64 message_thread_id,
        DraftMessage draft_message
    ) throws BadStatusCodeError {
        var obj = new SetChatDraftMessage (
            chat_id,
            message_thread_id,
            draft_message
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_draft_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the notification settings of a chat. Notification settings of
     * a chat with the current user (Saved Messages) can't be changed
     * @param chat_id Chat identifier
     * @param notification_settings New notification settings for the chat.
     * If the chat is muted for more than 366 days, it is considered to be
     * muted forever
     */
    public async Ok set_chat_notification_settings (
        int64 chat_id,
        ChatNotificationSettings notification_settings
    ) throws BadStatusCodeError {
        var obj = new SetChatNotificationSettings (
            chat_id,
            notification_settings
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_notification_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the ability of users to save, forward, or copy chat content.
     * Supported only for basic groups, supergroups and channels. Requires
     * owner privileges
     * @param chat_id Chat identifier
     * @param has_protected_content New value of has_protected_content
     */
    public async Ok toggle_chat_has_protected_content (
        int64 chat_id,
        bool has_protected_content
    ) throws BadStatusCodeError {
        var obj = new ToggleChatHasProtectedContent (
            chat_id,
            has_protected_content
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_chat_has_protected_content.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the view_as_topics setting of a forum chat or Saved Messages
     * @param chat_id Chat identifier
     * @param view_as_topics New value of view_as_topics
     */
    public async Ok toggle_chat_view_as_topics (
        int64 chat_id,
        bool view_as_topics
    ) throws BadStatusCodeError {
        var obj = new ToggleChatViewAsTopics (
            chat_id,
            view_as_topics
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_chat_view_as_topics.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the translatable state of a chat
     * @param chat_id Chat identifier
     * @param is_translatable New value of is_translatable
     */
    public async Ok toggle_chat_is_translatable (
        int64 chat_id,
        bool is_translatable
    ) throws BadStatusCodeError {
        var obj = new ToggleChatIsTranslatable (
            chat_id,
            is_translatable
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_chat_is_translatable.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the marked as unread state of a chat
     * @param chat_id Chat identifier
     * @param is_marked_as_unread New value of is_marked_as_unread
     */
    public async Ok toggle_chat_is_marked_as_unread (
        int64 chat_id,
        bool is_marked_as_unread
    ) throws BadStatusCodeError {
        var obj = new ToggleChatIsMarkedAsUnread (
            chat_id,
            is_marked_as_unread
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_chat_is_marked_as_unread.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the value of the default disable_notification parameter, used
     * when a message is sent to a chat
     * @param chat_id Chat identifier
     * @param default_disable_notification New value of
     * default_disable_notification
     */
    public async Ok toggle_chat_default_disable_notification (
        int64 chat_id,
        bool default_disable_notification
    ) throws BadStatusCodeError {
        var obj = new ToggleChatDefaultDisableNotification (
            chat_id,
            default_disable_notification
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_chat_default_disable_notification.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes reactions, available in a chat. Available for basic groups,
     * supergroups, and channels. Requires can_change_info member right
     * @param chat_id Identifier of the chat
     * @param available_reactions Reactions available in the chat. All
     * explicitly specified emoji reactions must be active. In channel chats
     * up to the chat's boost level custom emoji reactions can be explicitly
     * specified
     */
    public async Ok set_chat_available_reactions (
        int64 chat_id,
        ChatAvailableReactions available_reactions
    ) throws BadStatusCodeError {
        var obj = new SetChatAvailableReactions (
            chat_id,
            available_reactions
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_available_reactions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes application-specific data associated with a chat
     * @param chat_id Chat identifier
     * @param client_data New value of client_data
     */
    public async Ok set_chat_client_data (
        int64 chat_id,
        string client_data
    ) throws BadStatusCodeError {
        var obj = new SetChatClientData (
            chat_id,
            client_data
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_client_data.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes information about a chat. Available for basic groups,
     * supergroups, and channels. Requires can_change_info member right
     * @param chat_id Identifier of the chat
     * @param description New chat description; 0-255 characters
     */
    public async Ok set_chat_description (
        int64 chat_id,
        string description
    ) throws BadStatusCodeError {
        var obj = new SetChatDescription (
            chat_id,
            description
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_description.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the discussion group of a channel chat; requires
     * can_change_info administrator right in the channel if it is specified
     * @param chat_id Identifier of the channel chat. Pass 0 to remove a link
     * from the supergroup passed in the second argument to a linked channel
     * chat (requires can_pin_messages member right in the supergroup)
     * @param discussion_chat_id Identifier of a new channel's discussion
     * group. Use 0 to remove the discussion group. Use the method
     * getSuitableDiscussionChats to find all suitable groups. Basic group
     * chats must be first upgraded to supergroup chats. If new chat members
     * don't have access to old messages in the supergroup, then
     * toggleSupergroupIsAllHistoryAvailable must be used first to change
     * that
     */
    public async Ok set_chat_discussion_group (
        int64 chat_id,
        int64 discussion_chat_id
    ) throws BadStatusCodeError {
        var obj = new SetChatDiscussionGroup (
            chat_id,
            discussion_chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_discussion_group.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the location of a chat. Available only for some location-based
     * supergroups, use supergroupFullInfo.can_set_location to check whether
     * the method is allowed to use
     * @param chat_id Chat identifier
     * @param location New location for the chat; must be valid and not null
     */
    public async Ok set_chat_location (
        int64 chat_id,
        ChatLocation location
    ) throws BadStatusCodeError {
        var obj = new SetChatLocation (
            chat_id,
            location
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_location.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the slow mode delay of a chat. Available only for supergroups;
     * requires can_restrict_members right
     * @param chat_id Chat identifier
     * @param slow_mode_delay New slow mode delay for the chat, in seconds;
     * must be one of 0, 10, 30, 60, 300, 900, 3600
     */
    public async Ok set_chat_slow_mode_delay (
        int64 chat_id,
        int32 slow_mode_delay
    ) throws BadStatusCodeError {
        var obj = new SetChatSlowModeDelay (
            chat_id,
            slow_mode_delay
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_slow_mode_delay.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Pins a message in a chat. A message can be pinned only if
     * messageProperties.can_be_pinned
     * @param chat_id Identifier of the chat
     * @param message_id Identifier of the new pinned message
     * @param disable_notification Pass true to disable notification about
     * the pinned message. Notifications are always disabled in channels and
     * private chats
     * @param only_for_self Pass true to pin the message only for self;
     * private chats only
     */
    public async Ok pin_chat_message (
        int64 chat_id,
        int64 message_id,
        bool disable_notification,
        bool only_for_self
    ) throws BadStatusCodeError {
        var obj = new PinChatMessage (
            chat_id,
            message_id,
            disable_notification,
            only_for_self
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (pin_chat_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes a pinned message from a chat; requires can_pin_messages member
     * right if the chat is a basic group or supergroup, or can_edit_messages
     * administrator right if the chat is a channel
     * @param chat_id Identifier of the chat
     * @param message_id Identifier of the removed pinned message
     */
    public async Ok unpin_chat_message (
        int64 chat_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new UnpinChatMessage (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (unpin_chat_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes all pinned messages from a chat; requires can_pin_messages
     * member right if the chat is a basic group or supergroup, or
     * can_edit_messages administrator right if the chat is a channel
     * @param chat_id Identifier of the chat
     */
    public async Ok unpin_all_chat_messages (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new UnpinAllChatMessages (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (unpin_all_chat_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes all pinned messages from a forum topic; requires
     * can_pin_messages member right in the supergroup
     * @param chat_id Identifier of the chat
     * @param message_thread_id Message thread identifier in which messages
     * will be unpinned
     */
    public async Ok unpin_all_message_thread_messages (
        int64 chat_id,
        int64 message_thread_id
    ) throws BadStatusCodeError {
        var obj = new UnpinAllMessageThreadMessages (
            chat_id,
            message_thread_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (unpin_all_message_thread_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds the current user as a new member to a chat. Private and secret
     * chats can't be joined using this method. May return an error with a
     * message "INVITE_REQUEST_SENT" if only a join request was created
     * @param chat_id Chat identifier
     */
    public async Ok join_chat (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new JoinChat (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (join_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes the current user from chat members. Private and secret chats
     * can't be left using this method
     * @param chat_id Chat identifier
     */
    public async Ok leave_chat (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new LeaveChat (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (leave_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a new member to a chat; requires can_invite_users member right.
     * Members can't be added to private or secret chats. Returns information
     * about members that weren't added
     * @param chat_id Chat identifier
     * @param user_id Identifier of the user
     * @param forward_limit The number of earlier messages from the chat to
     * be forwarded to the new member; up to 100. Ignored for supergroups and
     * channels, or if the added user is a bot
     */
    public async FailedToAddMembers add_chat_member (
        int64 chat_id,
        int64 user_id,
        int32 forward_limit
    ) throws BadStatusCodeError {
        var obj = new AddChatMember (
            chat_id,
            user_id,
            forward_limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_chat_member.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FailedToAddMembers out_obj;
        switch (tdlib_type) {
            case "failedToAddMembers":
                out_obj = (FailedToAddMembers) jsoner.deserialize_object (typeof (FailedToAddMembers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds multiple new members to a chat; requires can_invite_users member
     * right. Currently, this method is only available for supergroups and
     * channels.
     * This method can't be used to join a chat. Members can't be added to a
     * channel if it has more than 200 members. Returns information about
     * members that weren't added
     * @param chat_id Chat identifier
     * @param user_ids Identifiers of the users to be added to the chat. The
     * maximum number of added users is 20 for supergroups and 100 for
     * channels
     */
    public async FailedToAddMembers add_chat_members (
        int64 chat_id,
        Gee.ArrayList<int64?> user_ids
    ) throws BadStatusCodeError {
        var obj = new AddChatMembers (
            chat_id,
            user_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_chat_members.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FailedToAddMembers out_obj;
        switch (tdlib_type) {
            case "failedToAddMembers":
                out_obj = (FailedToAddMembers) jsoner.deserialize_object (typeof (FailedToAddMembers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the status of a chat member; requires can_invite_users member
     * right to add a chat member, can_promote_members administrator right to
     * change administrator rights of the member,
     * and can_restrict_members administrator right to change restrictions of
     * a user. This function is currently not suitable for transferring chat
     * ownership; use transferChatOwnership instead.
     * Use addChatMember or banChatMember if some additional parameters needs
     * to be passed
     * @param chat_id Chat identifier
     * @param member_id Member identifier. Chats can be only banned and
     * unbanned in supergroups and channels
     * @param status The new status of the member in the chat
     */
    public async Ok set_chat_member_status (
        int64 chat_id,
        MessageSender member_id,
        ChatMemberStatus status
    ) throws BadStatusCodeError {
        var obj = new SetChatMemberStatus (
            chat_id,
            member_id,
            status
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_member_status.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Bans a member in a chat; requires can_restrict_members administrator
     * right. Members can't be banned in private or secret chats. In
     * supergroups and channels, the user will not be able to return to the
     * group on their own using invite links, etc., unless unbanned first
     * @param chat_id Chat identifier
     * @param member_id Member identifier
     * @param banned_until_date Point in time (Unix timestamp) when the user
     * will be unbanned; 0 if never. If the user is banned for more than 366
     * days or for less than 30 seconds from the current time, the user is
     * considered to be banned forever. Ignored in basic groups and if a chat
     * is banned
     * @param revoke_messages Pass true to delete all messages in the chat
     * for the user that is being removed. Always true for supergroups and
     * channels
     */
    public async Ok ban_chat_member (
        int64 chat_id,
        MessageSender member_id,
        int32 banned_until_date,
        bool revoke_messages
    ) throws BadStatusCodeError {
        var obj = new BanChatMember (
            chat_id,
            member_id,
            banned_until_date,
            revoke_messages
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (ban_chat_member.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks whether the current session can be used to transfer a chat
     * ownership to another user
     */
    public async CanTransferOwnershipResult can_transfer_ownership () throws BadStatusCodeError {
        var obj = new CanTransferOwnership ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (can_transfer_ownership.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        CanTransferOwnershipResult out_obj;
        switch (tdlib_type) {
            case "canTransferOwnershipResultOk":
                out_obj = (CanTransferOwnershipResultOk) jsoner.deserialize_object (typeof (CanTransferOwnershipResultOk));
                break;
            case "canTransferOwnershipResultPasswordNeeded":
                out_obj = (CanTransferOwnershipResultPasswordNeeded) jsoner.deserialize_object (typeof (CanTransferOwnershipResultPasswordNeeded));
                break;
            case "canTransferOwnershipResultPasswordTooFresh":
                out_obj = (CanTransferOwnershipResultPasswordTooFresh) jsoner.deserialize_object (typeof (CanTransferOwnershipResultPasswordTooFresh));
                break;
            case "canTransferOwnershipResultSessionTooFresh":
                out_obj = (CanTransferOwnershipResultSessionTooFresh) jsoner.deserialize_object (typeof (CanTransferOwnershipResultSessionTooFresh));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the owner of a chat; requires owner privileges in the chat.
     * Use the method canTransferOwnership to check whether the ownership can
     * be transferred from the current session. Available only for
     * supergroups and channel chats
     * @param chat_id Chat identifier
     * @param user_id Identifier of the user to which transfer the ownership.
     * The ownership can't be transferred to a bot or to a deleted user
     * @param password The 2-step verification password of the current user
     */
    public async Ok transfer_chat_ownership (
        int64 chat_id,
        int64 user_id,
        string password
    ) throws BadStatusCodeError {
        var obj = new TransferChatOwnership (
            chat_id,
            user_id,
            password
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (transfer_chat_ownership.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a single member of a chat
     * @param chat_id Chat identifier
     * @param member_id Member identifier
     */
    public async ChatMember get_chat_member (
        int64 chat_id,
        MessageSender member_id
    ) throws BadStatusCodeError {
        var obj = new GetChatMember (
            chat_id,
            member_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_member.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatMember out_obj;
        switch (tdlib_type) {
            case "chatMember":
                out_obj = (ChatMember) jsoner.deserialize_object (typeof (ChatMember));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for a specified query in the first name, last name and
     * usernames of the members of a specified chat. Requires administrator
     * rights if the chat is a channel
     * @param chat_id Chat identifier
     * @param query Query to search for
     * @param limit The maximum number of users to be returned; up to 200
     * @param filter The type of users to search for; pass null to search
     * among all chat members
     */
    public async ChatMembers search_chat_members (
        int64 chat_id,
        string query,
        int32 limit,
        ChatMembersFilter filter
    ) throws BadStatusCodeError {
        var obj = new SearchChatMembers (
            chat_id,
            query,
            limit,
            filter
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_chat_members.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatMembers out_obj;
        switch (tdlib_type) {
            case "chatMembers":
                out_obj = (ChatMembers) jsoner.deserialize_object (typeof (ChatMembers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a list of administrators of the chat with their custom titles
     * @param chat_id Chat identifier
     */
    public async ChatAdministrators get_chat_administrators (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new GetChatAdministrators (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_administrators.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatAdministrators out_obj;
        switch (tdlib_type) {
            case "chatAdministrators":
                out_obj = (ChatAdministrators) jsoner.deserialize_object (typeof (ChatAdministrators));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Clears message drafts in all chats
     * @param exclude_secret_chats Pass true to keep local message drafts in
     * secret chats
     */
    public async Ok clear_all_draft_messages (
        bool exclude_secret_chats
    ) throws BadStatusCodeError {
        var obj = new ClearAllDraftMessages (
            exclude_secret_chats
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clear_all_draft_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns saved notification sound by its identifier. Returns a 404
     * error if there is no saved notification sound with the specified
     * identifier
     * @param notification_sound_id Identifier of the notification sound
     */
    public async NotificationSounds get_saved_notification_sound (
        int64 notification_sound_id
    ) throws BadStatusCodeError {
        var obj = new GetSavedNotificationSound (
            notification_sound_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_saved_notification_sound.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        NotificationSounds out_obj;
        switch (tdlib_type) {
            case "notificationSounds":
                out_obj = (NotificationSounds) jsoner.deserialize_object (typeof (NotificationSounds));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of saved notification sounds. If a sound isn't in the
     * list, then default sound needs to be used
     */
    public async NotificationSounds get_saved_notification_sounds () throws BadStatusCodeError {
        var obj = new GetSavedNotificationSounds ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_saved_notification_sounds.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        NotificationSounds out_obj;
        switch (tdlib_type) {
            case "notificationSounds":
                out_obj = (NotificationSounds) jsoner.deserialize_object (typeof (NotificationSounds));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a new notification sound to the list of saved notification
     * sounds. The new notification sound is added to the top of the list. If
     * it is already in the list, its position isn't changed
     * @param sound Notification sound file to add
     */
    public async NotificationSound add_saved_notification_sound (
        InputFile sound
    ) throws BadStatusCodeError {
        var obj = new AddSavedNotificationSound (
            sound
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_saved_notification_sound.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        NotificationSound out_obj;
        switch (tdlib_type) {
            case "notificationSound":
                out_obj = (NotificationSound) jsoner.deserialize_object (typeof (NotificationSound));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes a notification sound from the list of saved notification
     * sounds
     * @param notification_sound_id Identifier of the notification sound
     */
    public async Ok remove_saved_notification_sound (
        int64 notification_sound_id
    ) throws BadStatusCodeError {
        var obj = new RemoveSavedNotificationSound (
            notification_sound_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_saved_notification_sound.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of chats with non-default notification settings for
     * new messages
     * @param scope If specified, only chats from the scope will be returned;
     * pass null to return chats from all scopes
     * @param compare_sound Pass true to include in the response chats with
     * only non-default sound
     */
    public async Chats get_chat_notification_settings_exceptions (
        NotificationSettingsScope scope,
        bool compare_sound
    ) throws BadStatusCodeError {
        var obj = new GetChatNotificationSettingsExceptions (
            scope,
            compare_sound
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_notification_settings_exceptions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the notification settings for chats of a given type
     * @param scope Types of chats for which to return the notification
     * settings information
     */
    public async ScopeNotificationSettings get_scope_notification_settings (
        NotificationSettingsScope scope
    ) throws BadStatusCodeError {
        var obj = new GetScopeNotificationSettings (
            scope
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_scope_notification_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ScopeNotificationSettings out_obj;
        switch (tdlib_type) {
            case "scopeNotificationSettings":
                out_obj = (ScopeNotificationSettings) jsoner.deserialize_object (typeof (ScopeNotificationSettings));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes notification settings for chats of a given type
     * @param scope Types of chats for which to change the notification
     * settings
     * @param notification_settings The new notification settings for the
     * given scope
     */
    public async Ok set_scope_notification_settings (
        NotificationSettingsScope scope,
        ScopeNotificationSettings notification_settings
    ) throws BadStatusCodeError {
        var obj = new SetScopeNotificationSettings (
            scope,
            notification_settings
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_scope_notification_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes notification settings for reactions
     * @param notification_settings The new notification settings for
     * reactions
     */
    public async Ok set_reaction_notification_settings (
        ReactionNotificationSettings notification_settings
    ) throws BadStatusCodeError {
        var obj = new SetReactionNotificationSettings (
            notification_settings
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_reaction_notification_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Resets all chat and scope notification settings to their default
     * values. By default, all chats are unmuted and message previews are
     * shown
     */
    public async Ok reset_all_notification_settings () throws BadStatusCodeError {
        var obj = new ResetAllNotificationSettings ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reset_all_notification_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the pinned state of a chat. There can be up to
     * getOption("pinned_chat_count_max")/getOption("pinned_archived_chat_count_max")
     * pinned non-secret chats and the same number of secret chats in the
     * main/archive chat list. The limit can be increased with Telegram
     * Premium
     * @param chat_list Chat list in which to change the pinned state of the
     * chat
     * @param chat_id Chat identifier
     * @param is_pinned Pass true to pin the chat; pass false to unpin it
     */
    public async Ok toggle_chat_is_pinned (
        ChatList chat_list,
        int64 chat_id,
        bool is_pinned
    ) throws BadStatusCodeError {
        var obj = new ToggleChatIsPinned (
            chat_list,
            chat_id,
            is_pinned
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_chat_is_pinned.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the order of pinned chats
     * @param chat_list Chat list in which to change the order of pinned
     * chats
     * @param chat_ids The new list of pinned chats
     */
    public async Ok set_pinned_chats (
        ChatList chat_list,
        Gee.ArrayList<int64?> chat_ids
    ) throws BadStatusCodeError {
        var obj = new SetPinnedChats (
            chat_list,
            chat_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_pinned_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Traverse all chats in a chat list and marks all messages in the chats
     * as read
     * @param chat_list Chat list in which to mark all chats as read
     */
    public async Ok read_chat_list (
        ChatList chat_list
    ) throws BadStatusCodeError {
        var obj = new ReadChatList (
            chat_list
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (read_chat_list.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the current weather in the given location
     * @param location The location
     */
    public async CurrentWeather get_current_weather (
        Location location
    ) throws BadStatusCodeError {
        var obj = new GetCurrentWeather (
            location
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_current_weather.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        CurrentWeather out_obj;
        switch (tdlib_type) {
            case "currentWeather":
                out_obj = (CurrentWeather) jsoner.deserialize_object (typeof (CurrentWeather));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a story
     * @param story_sender_chat_id Identifier of the chat that posted the
     * story
     * @param story_id Story identifier
     * @param only_local Pass true to get only locally available information
     * without sending network requests
     */
    public async Story get_story (
        int64 story_sender_chat_id,
        int32 story_id,
        bool only_local
    ) throws BadStatusCodeError {
        var obj = new GetStory (
            story_sender_chat_id,
            story_id,
            only_local
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_story.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Story out_obj;
        switch (tdlib_type) {
            case "story":
                out_obj = (Story) jsoner.deserialize_object (typeof (Story));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns supergroup and channel chats in which the current user has the
     * right to post stories. The chats must be rechecked with canSendStory
     * before actually trying to post a story there
     */
    public async Chats get_chats_to_send_stories () throws BadStatusCodeError {
        var obj = new GetChatsToSendStories ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chats_to_send_stories.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks whether the current user can send a story on behalf of a chat;
     * requires can_post_stories right for supergroup and channel chats
     * @param chat_id Chat identifier. Pass Saved Messages chat identifier
     * when posting a story on behalf of the current user
     */
    public async CanSendStoryResult can_send_story (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new CanSendStory (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (can_send_story.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        CanSendStoryResult out_obj;
        switch (tdlib_type) {
            case "canSendStoryResultOk":
                out_obj = (CanSendStoryResultOk) jsoner.deserialize_object (typeof (CanSendStoryResultOk));
                break;
            case "canSendStoryResultPremiumNeeded":
                out_obj = (CanSendStoryResultPremiumNeeded) jsoner.deserialize_object (typeof (CanSendStoryResultPremiumNeeded));
                break;
            case "canSendStoryResultBoostNeeded":
                out_obj = (CanSendStoryResultBoostNeeded) jsoner.deserialize_object (typeof (CanSendStoryResultBoostNeeded));
                break;
            case "canSendStoryResultActiveStoryLimitExceeded":
                out_obj = (CanSendStoryResultActiveStoryLimitExceeded) jsoner.deserialize_object (typeof (CanSendStoryResultActiveStoryLimitExceeded));
                break;
            case "canSendStoryResultWeeklyLimitExceeded":
                out_obj = (CanSendStoryResultWeeklyLimitExceeded) jsoner.deserialize_object (typeof (CanSendStoryResultWeeklyLimitExceeded));
                break;
            case "canSendStoryResultMonthlyLimitExceeded":
                out_obj = (CanSendStoryResultMonthlyLimitExceeded) jsoner.deserialize_object (typeof (CanSendStoryResultMonthlyLimitExceeded));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends a new story to a chat; requires can_post_stories right for
     * supergroup and channel chats. Returns a temporary story
     * @param chat_id Identifier of the chat that will post the story. Pass
     * Saved Messages chat identifier when posting a story on behalf of the
     * current user
     * @param content Content of the story
     * @param areas Clickable rectangle areas to be shown on the story media;
     * pass null if none
     * @param caption Story caption; pass null to use an empty caption;
     * 0-getOption("story_caption_length_max") characters; can have entities
     * only if getOption("can_use_text_entities_in_story_caption")
     * @param privacy_settings The privacy settings for the story; ignored
     * for stories sent to supergroup and channel chats
     * @param active_period Period after which the story is moved to archive,
     * in seconds; must be one of 6 * 3600, 12 * 3600, 86400, or 2 * 86400
     * for Telegram Premium users, and 86400 otherwise
     * @param from_story_full_id Full identifier of the original story, which
     * content was used to create the story; pass null if the story isn't
     * repost of another story
     * @param is_posted_to_chat_page Pass true to keep the story accessible
     * after expiration
     * @param protect_content Pass true if the content of the story must be
     * protected from forwarding and screenshotting
     */
    public async Story send_story (
        int64 chat_id,
        InputStoryContent content,
        InputStoryAreas areas,
        FormattedText caption,
        StoryPrivacySettings privacy_settings,
        int32 active_period,
        StoryFullId from_story_full_id,
        bool is_posted_to_chat_page,
        bool protect_content
    ) throws BadStatusCodeError {
        var obj = new SendStory (
            chat_id,
            content,
            areas,
            caption,
            privacy_settings,
            active_period,
            from_story_full_id,
            is_posted_to_chat_page,
            protect_content
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_story.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Story out_obj;
        switch (tdlib_type) {
            case "story":
                out_obj = (Story) jsoner.deserialize_object (typeof (Story));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes content and caption of a story. Can be called only if
     * story.can_be_edited == true
     * @param story_sender_chat_id Identifier of the chat that posted the
     * story
     * @param story_id Identifier of the story to edit
     * @param content New content of the story; pass null to keep the current
     * content
     * @param areas New clickable rectangle areas to be shown on the story
     * media; pass null to keep the current areas. Areas can't be edited if
     * story content isn't changed
     * @param caption New story caption; pass null to keep the current
     * caption
     */
    public async Ok edit_story (
        int64 story_sender_chat_id,
        int32 story_id,
        InputStoryContent content,
        InputStoryAreas areas,
        FormattedText caption
    ) throws BadStatusCodeError {
        var obj = new EditStory (
            story_sender_chat_id,
            story_id,
            content,
            areas,
            caption
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_story.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes cover of a video story. Can be called only if
     * story.can_be_edited == true and the story isn't being edited now
     * @param story_sender_chat_id Identifier of the chat that posted the
     * story
     * @param story_id Identifier of the story to edit
     * @param cover_frame_timestamp New timestamp of the frame, which will be
     * used as video thumbnail
     */
    public async Ok edit_story_cover (
        int64 story_sender_chat_id,
        int32 story_id,
        double cover_frame_timestamp
    ) throws BadStatusCodeError {
        var obj = new EditStoryCover (
            story_sender_chat_id,
            story_id,
            cover_frame_timestamp
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_story_cover.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes privacy settings of a story. The method can be called only for
     * stories posted on behalf of the current user and if
     * story.can_be_edited == true
     * @param story_id Identifier of the story
     * @param privacy_settings The new privacy settigs for the story
     */
    public async Ok set_story_privacy_settings (
        int32 story_id,
        StoryPrivacySettings privacy_settings
    ) throws BadStatusCodeError {
        var obj = new SetStoryPrivacySettings (
            story_id,
            privacy_settings
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_story_privacy_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether a story is accessible after expiration. Can be called
     * only if story.can_toggle_is_posted_to_chat_page == true
     * @param story_sender_chat_id Identifier of the chat that posted the
     * story
     * @param story_id Identifier of the story
     * @param is_posted_to_chat_page Pass true to make the story accessible
     * after expiration; pass false to make it private
     */
    public async Ok toggle_story_is_posted_to_chat_page (
        int64 story_sender_chat_id,
        int32 story_id,
        bool is_posted_to_chat_page
    ) throws BadStatusCodeError {
        var obj = new ToggleStoryIsPostedToChatPage (
            story_sender_chat_id,
            story_id,
            is_posted_to_chat_page
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_story_is_posted_to_chat_page.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes a previously sent story. Can be called only if
     * story.can_be_deleted == true
     * @param story_sender_chat_id Identifier of the chat that posted the
     * story
     * @param story_id Identifier of the story to delete
     */
    public async Ok delete_story (
        int64 story_sender_chat_id,
        int32 story_id
    ) throws BadStatusCodeError {
        var obj = new DeleteStory (
            story_sender_chat_id,
            story_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_story.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of chats with non-default notification settings for
     * stories
     */
    public async Chats get_story_notification_settings_exceptions () throws BadStatusCodeError {
        var obj = new GetStoryNotificationSettingsExceptions ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_story_notification_settings_exceptions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chats out_obj;
        switch (tdlib_type) {
            case "chats":
                out_obj = (Chats) jsoner.deserialize_object (typeof (Chats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Loads more active stories from a story list. The loaded stories will
     * be sent through updates. Active stories are sorted by
     * the pair (active_stories.order, active_stories.story_sender_chat_id)
     * in descending order. Returns a 404 error if all active stories have
     * been loaded
     * @param story_list The story list in which to load active stories
     */
    public async Ok load_active_stories (
        StoryList story_list
    ) throws BadStatusCodeError {
        var obj = new LoadActiveStories (
            story_list
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (load_active_stories.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes story list in which stories from the chat are shown
     * @param chat_id Identifier of the chat that posted stories
     * @param story_list New list for active stories posted by the chat
     */
    public async Ok set_chat_active_stories_list (
        int64 chat_id,
        StoryList story_list
    ) throws BadStatusCodeError {
        var obj = new SetChatActiveStoriesList (
            chat_id,
            story_list
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_active_stories_list.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of active stories posted by the given chat
     * @param chat_id Chat identifier
     */
    public async ChatActiveStories get_chat_active_stories (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new GetChatActiveStories (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_active_stories.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatActiveStories out_obj;
        switch (tdlib_type) {
            case "chatActiveStories":
                out_obj = (ChatActiveStories) jsoner.deserialize_object (typeof (ChatActiveStories));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of stories that posted by the given chat to its chat
     * page. If from_story_id == 0, then pinned stories are returned first.
     * Then, stories are returned in reverse chronological order (i.e., in
     * order of decreasing story_id). For optimal performance, the number of
     * returned stories is chosen by TDLib
     * @param chat_id Chat identifier
     * @param from_story_id Identifier of the story starting from which
     * stories must be returned; use 0 to get results from pinned and the
     * newest story
     * @param limit The maximum number of stories to be returned. For optimal
     * performance, the number of returned stories is chosen by TDLib and can
     * be smaller than the specified limit
     */
    public async Stories get_chat_posted_to_chat_page_stories (
        int64 chat_id,
        int32 from_story_id,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetChatPostedToChatPageStories (
            chat_id,
            from_story_id,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_posted_to_chat_page_stories.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Stories out_obj;
        switch (tdlib_type) {
            case "stories":
                out_obj = (Stories) jsoner.deserialize_object (typeof (Stories));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of all stories posted by the given chat; requires
     * can_edit_stories right in the chat.
     * The stories are returned in reverse chronological order (i.e., in
     * order of decreasing story_id). For optimal performance, the number of
     * returned stories is chosen by TDLib
     * @param chat_id Chat identifier
     * @param from_story_id Identifier of the story starting from which
     * stories must be returned; use 0 to get results from the last story
     * @param limit The maximum number of stories to be returned. For optimal
     * performance, the number of returned stories is chosen by TDLib and can
     * be smaller than the specified limit
     */
    public async Stories get_chat_archived_stories (
        int64 chat_id,
        int32 from_story_id,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetChatArchivedStories (
            chat_id,
            from_story_id,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_archived_stories.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Stories out_obj;
        switch (tdlib_type) {
            case "stories":
                out_obj = (Stories) jsoner.deserialize_object (typeof (Stories));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the list of pinned stories on a chat page; requires
     * can_edit_stories right in the chat
     * @param chat_id Identifier of the chat that posted the stories
     * @param story_ids New list of pinned stories. All stories must be
     * posted to the chat page first. There can be up to
     * getOption("pinned_story_count_max") pinned stories on a chat page
     */
    public async Ok set_chat_pinned_stories (
        int64 chat_id,
        Gee.ArrayList<int32?> story_ids
    ) throws BadStatusCodeError {
        var obj = new SetChatPinnedStories (
            chat_id,
            story_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_pinned_stories.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs TDLib that a story is opened and is being viewed by the user
     * @param story_sender_chat_id The identifier of the sender of the opened
     * story
     * @param story_id The identifier of the story
     */
    public async Ok open_story (
        int64 story_sender_chat_id,
        int32 story_id
    ) throws BadStatusCodeError {
        var obj = new OpenStory (
            story_sender_chat_id,
            story_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (open_story.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs TDLib that a story is closed by the user
     * @param story_sender_chat_id The identifier of the sender of the story
     * to close
     * @param story_id The identifier of the story
     */
    public async Ok close_story (
        int64 story_sender_chat_id,
        int32 story_id
    ) throws BadStatusCodeError {
        var obj = new CloseStory (
            story_sender_chat_id,
            story_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (close_story.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns reactions, which can be chosen for a story
     * @param row_size Number of reaction per row, 5-25
     */
    public async AvailableReactions get_story_available_reactions (
        int32 row_size
    ) throws BadStatusCodeError {
        var obj = new GetStoryAvailableReactions (
            row_size
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_story_available_reactions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        AvailableReactions out_obj;
        switch (tdlib_type) {
            case "availableReactions":
                out_obj = (AvailableReactions) jsoner.deserialize_object (typeof (AvailableReactions));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes chosen reaction on a story that has already been sent
     * @param story_sender_chat_id The identifier of the sender of the story
     * @param story_id The identifier of the story
     * @param reaction_type Type of the reaction to set; pass null to remove
     * the reaction. Custom emoji reactions can be used only by Telegram
     * Premium users. Paid reactions can't be set
     * @param update_recent_reactions Pass true if the reaction needs to be
     * added to recent reactions
     */
    public async Ok set_story_reaction (
        int64 story_sender_chat_id,
        int32 story_id,
        ReactionType reaction_type,
        bool update_recent_reactions
    ) throws BadStatusCodeError {
        var obj = new SetStoryReaction (
            story_sender_chat_id,
            story_id,
            reaction_type,
            update_recent_reactions
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_story_reaction.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns interactions with a story. The method can be called only for
     * stories posted on behalf of the current user
     * @param story_id Story identifier
     * @param query Query to search for in names, usernames and titles; may
     * be empty to get all relevant interactions
     * @param only_contacts Pass true to get only interactions by contacts;
     * pass false to get all relevant interactions
     * @param prefer_forwards Pass true to get forwards and reposts first,
     * then reactions, then other views; pass false to get interactions
     * sorted just by interaction date
     * @param prefer_with_reaction Pass true to get interactions with
     * reaction first; pass false to get interactions sorted just by
     * interaction date. Ignored if prefer_forwards == true
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of story interactions to return
     */
    public async StoryInteractions get_story_interactions (
        int32 story_id,
        string query,
        bool only_contacts,
        bool prefer_forwards,
        bool prefer_with_reaction,
        string offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetStoryInteractions (
            story_id,
            query,
            only_contacts,
            prefer_forwards,
            prefer_with_reaction,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_story_interactions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StoryInteractions out_obj;
        switch (tdlib_type) {
            case "storyInteractions":
                out_obj = (StoryInteractions) jsoner.deserialize_object (typeof (StoryInteractions));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns interactions with a story posted in a chat. Can be used only
     * if story is posted on behalf of a chat and the user is an
     * administrator in the chat
     * @param story_sender_chat_id The identifier of the sender of the story
     * @param story_id Story identifier
     * @param reaction_type Pass the default heart reaction or a suggested
     * reaction type to receive only interactions with the specified reaction
     * type; pass null to receive all interactions; reactionTypePaid isn't
     * supported
     * @param prefer_forwards Pass true to get forwards and reposts first,
     * then reactions, then other views; pass false to get interactions
     * sorted just by interaction date
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of story interactions to return
     */
    public async StoryInteractions get_chat_story_interactions (
        int64 story_sender_chat_id,
        int32 story_id,
        ReactionType reaction_type,
        bool prefer_forwards,
        string offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetChatStoryInteractions (
            story_sender_chat_id,
            story_id,
            reaction_type,
            prefer_forwards,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_story_interactions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StoryInteractions out_obj;
        switch (tdlib_type) {
            case "storyInteractions":
                out_obj = (StoryInteractions) jsoner.deserialize_object (typeof (StoryInteractions));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Reports a story to the Telegram moderators
     * @param story_sender_chat_id The identifier of the sender of the story
     * to report
     * @param story_id The identifier of the story to report
     * @param option_id Option identifier chosen by the user; leave empty for
     * the initial request
     * @param text Additional report details; 0-1024 characters; leave empty
     * for the initial request
     */
    public async ReportStoryResult report_story (
        int64 story_sender_chat_id,
        int32 story_id,
        Bytes option_id,
        string text
    ) throws BadStatusCodeError {
        var obj = new ReportStory (
            story_sender_chat_id,
            story_id,
            option_id,
            text
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_story.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ReportStoryResult out_obj;
        switch (tdlib_type) {
            case "reportStoryResultOk":
                out_obj = (ReportStoryResultOk) jsoner.deserialize_object (typeof (ReportStoryResultOk));
                break;
            case "reportStoryResultOptionRequired":
                out_obj = (ReportStoryResultOptionRequired) jsoner.deserialize_object (typeof (ReportStoryResultOptionRequired));
                break;
            case "reportStoryResultTextRequired":
                out_obj = (ReportStoryResultTextRequired) jsoner.deserialize_object (typeof (ReportStoryResultTextRequired));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Activates stealth mode for stories, which hides all views of stories
     * from the current user in the last "story_stealth_mode_past_period"
     * seconds
     * and for the next "story_stealth_mode_future_period" seconds; for
     * Telegram Premium users only
     */
    public async Ok activate_story_stealth_mode () throws BadStatusCodeError {
        var obj = new ActivateStoryStealthMode ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (activate_story_stealth_mode.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns forwards of a story as a message to public chats and reposts
     * by public channels. Can be used only if the story is posted on behalf
     * of the current user or story.can_get_statistics == true.
     * For optimal performance, the number of returned messages and stories
     * is chosen by TDLib
     * @param story_sender_chat_id The identifier of the sender of the story
     * @param story_id The identifier of the story
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of messages and stories to be
     * returned; must be positive and can't be greater than 100. For optimal
     * performance, the number of returned objects is chosen by TDLib and can
     * be smaller than the specified limit
     */
    public async PublicForwards get_story_public_forwards (
        int64 story_sender_chat_id,
        int32 story_id,
        string offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetStoryPublicForwards (
            story_sender_chat_id,
            story_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_story_public_forwards.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PublicForwards out_obj;
        switch (tdlib_type) {
            case "publicForwards":
                out_obj = (PublicForwards) jsoner.deserialize_object (typeof (PublicForwards));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of features available on the specific chat boost
     * level; this is an offline request
     * @param is_channel Pass true to get the list of features for channels;
     * pass false to get the list of features for supergroups
     * @param level Chat boost level
     */
    public async ChatBoostLevelFeatures get_chat_boost_level_features (
        bool is_channel,
        int32 level
    ) throws BadStatusCodeError {
        var obj = new GetChatBoostLevelFeatures (
            is_channel,
            level
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_boost_level_features.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatBoostLevelFeatures out_obj;
        switch (tdlib_type) {
            case "chatBoostLevelFeatures":
                out_obj = (ChatBoostLevelFeatures) jsoner.deserialize_object (typeof (ChatBoostLevelFeatures));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of features available for different chat boost
     * levels; this is an offline request
     * @param is_channel Pass true to get the list of features for channels;
     * pass false to get the list of features for supergroups
     */
    public async ChatBoostFeatures get_chat_boost_features (
        bool is_channel
    ) throws BadStatusCodeError {
        var obj = new GetChatBoostFeatures (
            is_channel
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_boost_features.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatBoostFeatures out_obj;
        switch (tdlib_type) {
            case "chatBoostFeatures":
                out_obj = (ChatBoostFeatures) jsoner.deserialize_object (typeof (ChatBoostFeatures));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of available chat boost slots for the current user
     */
    public async ChatBoostSlots get_available_chat_boost_slots () throws BadStatusCodeError {
        var obj = new GetAvailableChatBoostSlots ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_available_chat_boost_slots.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatBoostSlots out_obj;
        switch (tdlib_type) {
            case "chatBoostSlots":
                out_obj = (ChatBoostSlots) jsoner.deserialize_object (typeof (ChatBoostSlots));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the current boost status for a supergroup or a channel chat
     * @param chat_id Identifier of the chat
     */
    public async ChatBoostStatus get_chat_boost_status (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new GetChatBoostStatus (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_boost_status.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatBoostStatus out_obj;
        switch (tdlib_type) {
            case "chatBoostStatus":
                out_obj = (ChatBoostStatus) jsoner.deserialize_object (typeof (ChatBoostStatus));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Boosts a chat and returns the list of available chat boost slots for
     * the current user after the boost
     * @param chat_id Identifier of the chat
     * @param slot_ids Identifiers of boost slots of the current user from
     * which to apply boosts to the chat
     */
    public async ChatBoostSlots boost_chat (
        int64 chat_id,
        Gee.ArrayList<int32?> slot_ids
    ) throws BadStatusCodeError {
        var obj = new BoostChat (
            chat_id,
            slot_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (boost_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatBoostSlots out_obj;
        switch (tdlib_type) {
            case "chatBoostSlots":
                out_obj = (ChatBoostSlots) jsoner.deserialize_object (typeof (ChatBoostSlots));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an HTTPS link to boost the specified supergroup or channel
     * chat
     * @param chat_id Identifier of the chat
     */
    public async ChatBoostLink get_chat_boost_link (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new GetChatBoostLink (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_boost_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatBoostLink out_obj;
        switch (tdlib_type) {
            case "chatBoostLink":
                out_obj = (ChatBoostLink) jsoner.deserialize_object (typeof (ChatBoostLink));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a link to boost a chat. Can be called for
     * any internal link of the type internalLinkTypeChatBoost
     * @param url The link to boost a chat
     */
    public async ChatBoostLinkInfo get_chat_boost_link_info (
        string url
    ) throws BadStatusCodeError {
        var obj = new GetChatBoostLinkInfo (
            url
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_boost_link_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatBoostLinkInfo out_obj;
        switch (tdlib_type) {
            case "chatBoostLinkInfo":
                out_obj = (ChatBoostLinkInfo) jsoner.deserialize_object (typeof (ChatBoostLinkInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of boosts applied to a chat; requires administrator
     * rights in the chat
     * @param chat_id Identifier of the chat
     * @param only_gift_codes Pass true to receive only boosts received from
     * gift codes and giveaways created by the chat
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of boosts to be returned; up to 100.
     * For optimal performance, the number of returned boosts can be smaller
     * than the specified limit
     */
    public async FoundChatBoosts get_chat_boosts (
        int64 chat_id,
        bool only_gift_codes,
        string offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetChatBoosts (
            chat_id,
            only_gift_codes,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_boosts.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundChatBoosts out_obj;
        switch (tdlib_type) {
            case "foundChatBoosts":
                out_obj = (FoundChatBoosts) jsoner.deserialize_object (typeof (FoundChatBoosts));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of boosts applied to a chat by a given user; requires
     * administrator rights in the chat; for bots only
     * @param chat_id Identifier of the chat
     * @param user_id Identifier of the user
     */
    public async FoundChatBoosts get_user_chat_boosts (
        int64 chat_id,
        int64 user_id
    ) throws BadStatusCodeError {
        var obj = new GetUserChatBoosts (
            chat_id,
            user_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_user_chat_boosts.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundChatBoosts out_obj;
        switch (tdlib_type) {
            case "foundChatBoosts":
                out_obj = (FoundChatBoosts) jsoner.deserialize_object (typeof (FoundChatBoosts));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a bot that can be added to attachment or
     * side menu
     * @param bot_user_id Bot's user identifier
     */
    public async AttachmentMenuBot get_attachment_menu_bot (
        int64 bot_user_id
    ) throws BadStatusCodeError {
        var obj = new GetAttachmentMenuBot (
            bot_user_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_attachment_menu_bot.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        AttachmentMenuBot out_obj;
        switch (tdlib_type) {
            case "attachmentMenuBot":
                out_obj = (AttachmentMenuBot) jsoner.deserialize_object (typeof (AttachmentMenuBot));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds or removes a bot to attachment and side menu. Bot can be added to
     * the menu, only if userTypeBot.can_be_added_to_attachment_menu == true
     * @param bot_user_id Bot's user identifier
     * @param is_added Pass true to add the bot to attachment menu; pass
     * false to remove the bot from attachment menu
     * @param allow_write_access Pass true if the current user allowed the
     * bot to send them messages. Ignored if is_added is false
     */
    public async Ok toggle_bot_is_added_to_attachment_menu (
        int64 bot_user_id,
        bool is_added,
        bool allow_write_access
    ) throws BadStatusCodeError {
        var obj = new ToggleBotIsAddedToAttachmentMenu (
            bot_user_id,
            is_added,
            allow_write_access
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_bot_is_added_to_attachment_menu.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns up to 8 emoji statuses, which must be shown right after the
     * default Premium Badge in the emoji status list for self status
     */
    public async EmojiStatuses get_themed_emoji_statuses () throws BadStatusCodeError {
        var obj = new GetThemedEmojiStatuses ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_themed_emoji_statuses.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        EmojiStatuses out_obj;
        switch (tdlib_type) {
            case "emojiStatuses":
                out_obj = (EmojiStatuses) jsoner.deserialize_object (typeof (EmojiStatuses));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns recent emoji statuses for self status
     */
    public async EmojiStatuses get_recent_emoji_statuses () throws BadStatusCodeError {
        var obj = new GetRecentEmojiStatuses ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_recent_emoji_statuses.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        EmojiStatuses out_obj;
        switch (tdlib_type) {
            case "emojiStatuses":
                out_obj = (EmojiStatuses) jsoner.deserialize_object (typeof (EmojiStatuses));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns default emoji statuses for self status
     */
    public async EmojiStatuses get_default_emoji_statuses () throws BadStatusCodeError {
        var obj = new GetDefaultEmojiStatuses ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_default_emoji_statuses.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        EmojiStatuses out_obj;
        switch (tdlib_type) {
            case "emojiStatuses":
                out_obj = (EmojiStatuses) jsoner.deserialize_object (typeof (EmojiStatuses));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Clears the list of recently used emoji statuses for self status
     */
    public async Ok clear_recent_emoji_statuses () throws BadStatusCodeError {
        var obj = new ClearRecentEmojiStatuses ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clear_recent_emoji_statuses.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns up to 8 emoji statuses, which must be shown in the emoji
     * status list for chats
     */
    public async EmojiStatuses get_themed_chat_emoji_statuses () throws BadStatusCodeError {
        var obj = new GetThemedChatEmojiStatuses ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_themed_chat_emoji_statuses.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        EmojiStatuses out_obj;
        switch (tdlib_type) {
            case "emojiStatuses":
                out_obj = (EmojiStatuses) jsoner.deserialize_object (typeof (EmojiStatuses));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns default emoji statuses for chats
     */
    public async EmojiStatuses get_default_chat_emoji_statuses () throws BadStatusCodeError {
        var obj = new GetDefaultChatEmojiStatuses ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_default_chat_emoji_statuses.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        EmojiStatuses out_obj;
        switch (tdlib_type) {
            case "emojiStatuses":
                out_obj = (EmojiStatuses) jsoner.deserialize_object (typeof (EmojiStatuses));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of emoji statuses, which can't be used as chat emoji
     * status, even they are from a sticker set with
     * is_allowed_as_chat_emoji_status == true
     */
    public async EmojiStatuses get_disallowed_chat_emoji_statuses () throws BadStatusCodeError {
        var obj = new GetDisallowedChatEmojiStatuses ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_disallowed_chat_emoji_statuses.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        EmojiStatuses out_obj;
        switch (tdlib_type) {
            case "emojiStatuses":
                out_obj = (EmojiStatuses) jsoner.deserialize_object (typeof (EmojiStatuses));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Downloads a file from the cloud. Download progress and completion of
     * the download will be notified through updateFile updates
     * @param file_id Identifier of the file to download
     * @param priority Priority of the download (1-32). The higher the
     * priority, the earlier the file will be downloaded. If the priorities
     * of two files are equal, then the last one for which
     * downloadFile/addFileToDownloads was called will be downloaded first
     * @param offset The starting position from which the file needs to be
     * downloaded
     * @param limit Number of bytes which need to be downloaded starting from
     * the "offset" position before the download will automatically be
     * canceled; use 0 to download without a limit
     * @param synchronous Pass true to return response only after the file
     * download has succeeded, has failed, has been canceled, or a new
     * downloadFile request with different offset/limit parameters was sent;
     * pass false to return file state immediately, just after the download
     * has been started
     */
    public async File download_file (
        int32 file_id,
        int32 priority,
        int64 offset,
        int64 limit,
        bool synchronous
    ) throws BadStatusCodeError {
        var obj = new DownloadFile (
            file_id,
            priority,
            offset,
            limit,
            synchronous
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (download_file.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        File out_obj;
        switch (tdlib_type) {
            case "file":
                out_obj = (File) jsoner.deserialize_object (typeof (File));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns file downloaded prefix size from a given offset, in bytes
     * @param file_id Identifier of the file
     * @param offset Offset from which downloaded prefix size needs to be
     * calculated
     */
    public async FileDownloadedPrefixSize get_file_downloaded_prefix_size (
        int32 file_id,
        int64 offset
    ) throws BadStatusCodeError {
        var obj = new GetFileDownloadedPrefixSize (
            file_id,
            offset
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_file_downloaded_prefix_size.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FileDownloadedPrefixSize out_obj;
        switch (tdlib_type) {
            case "fileDownloadedPrefixSize":
                out_obj = (FileDownloadedPrefixSize) jsoner.deserialize_object (typeof (FileDownloadedPrefixSize));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Stops the downloading of a file. If a file has already been
     * downloaded, does nothing
     * @param file_id Identifier of a file to stop downloading
     * @param only_if_pending Pass true to stop downloading only if it hasn't
     * been started, i.e. request hasn't been sent to server
     */
    public async Ok cancel_download_file (
        int32 file_id,
        bool only_if_pending
    ) throws BadStatusCodeError {
        var obj = new CancelDownloadFile (
            file_id,
            only_if_pending
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (cancel_download_file.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns suggested name for saving a file in a given directory
     * @param file_id Identifier of the file
     * @param directory Directory in which the file is expected to be saved
     */
    public async Text get_suggested_file_name (
        int32 file_id,
        string directory
    ) throws BadStatusCodeError {
        var obj = new GetSuggestedFileName (
            file_id,
            directory
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_suggested_file_name.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Preliminary uploads a file to the cloud before sending it in a
     * message, which can be useful for uploading of being recorded voice and
     * video notes.
     * In all other cases there is no need to preliminary upload a file.
     * Updates updateFile will be used to notify about upload progress.
     * The upload will not be completed until the file is sent in a message
     * @param file File to upload
     * @param file_type File type; pass null if unknown
     * @param priority Priority of the upload (1-32). The higher the
     * priority, the earlier the file will be uploaded. If the priorities of
     * two files are equal, then the first one for which
     * preliminaryUploadFile was called will be uploaded first
     */
    public async File preliminary_upload_file (
        InputFile file,
        FileType file_type,
        int32 priority
    ) throws BadStatusCodeError {
        var obj = new PreliminaryUploadFile (
            file,
            file_type,
            priority
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (preliminary_upload_file.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        File out_obj;
        switch (tdlib_type) {
            case "file":
                out_obj = (File) jsoner.deserialize_object (typeof (File));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Stops the preliminary uploading of a file. Supported only for files
     * uploaded by using preliminaryUploadFile
     * @param file_id Identifier of the file to stop uploading
     */
    public async Ok cancel_preliminary_upload_file (
        int32 file_id
    ) throws BadStatusCodeError {
        var obj = new CancelPreliminaryUploadFile (
            file_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (cancel_preliminary_upload_file.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Writes a part of a generated file. This method is intended to be used
     * only if the application has no direct access to TDLib's file system,
     * because it is usually slower than a direct write to the destination
     * file
     * @param generation_id The identifier of the generation process
     * @param offset The offset from which to write the data to the file
     * @param data The data to write
     */
    public async Ok write_generated_file_part (
        int64 generation_id,
        int64 offset,
        Bytes data
    ) throws BadStatusCodeError {
        var obj = new WriteGeneratedFilePart (
            generation_id,
            offset,
            data
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (write_generated_file_part.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs TDLib on a file generation progress
     * @param generation_id The identifier of the generation process
     * @param expected_size Expected size of the generated file, in bytes; 0
     * if unknown
     * @param local_prefix_size The number of bytes already generated
     */
    public async Ok set_file_generation_progress (
        int64 generation_id,
        int64 expected_size,
        int64 local_prefix_size
    ) throws BadStatusCodeError {
        var obj = new SetFileGenerationProgress (
            generation_id,
            expected_size,
            local_prefix_size
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_file_generation_progress.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Finishes the file generation
     * @param generation_id The identifier of the generation process
     * @param error If passed, the file generation has failed and must be
     * terminated; pass null if the file generation succeeded
     */
    public async Ok finish_file_generation (
        int64 generation_id,
        Error error
    ) throws BadStatusCodeError {
        var obj = new FinishFileGeneration (
            generation_id,
            error
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (finish_file_generation.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Reads a part of a file from the TDLib file cache and returns read
     * bytes. This method is intended to be used only if the application has
     * no direct access to TDLib's file system, because it is usually slower
     * than a direct read from the file
     * @param file_id Identifier of the file. The file must be located in the
     * TDLib file cache
     * @param offset The offset from which to read the file
     * @param count Number of bytes to read. An error will be returned if
     * there are not enough bytes available in the file from the specified
     * position. Pass 0 to read all available data from the specified
     * position
     */
    public async FilePart read_file_part (
        int32 file_id,
        int64 offset,
        int64 count
    ) throws BadStatusCodeError {
        var obj = new ReadFilePart (
            file_id,
            offset,
            count
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (read_file_part.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FilePart out_obj;
        switch (tdlib_type) {
            case "filePart":
                out_obj = (FilePart) jsoner.deserialize_object (typeof (FilePart));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes a file from the TDLib file cache
     * @param file_id Identifier of the file to delete
     */
    public async Ok delete_file (
        int32 file_id
    ) throws BadStatusCodeError {
        var obj = new DeleteFile (
            file_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_file.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a file from a message to the list of file downloads. Download
     * progress and completion of the download will be notified through
     * updateFile updates.
     * If message database is used, the list of file downloads is persistent
     * across application restarts. The downloading is independent of
     * download using downloadFile, i.e. it continues if downloadFile is
     * canceled or is used to download a part of the file
     * @param file_id Identifier of the file to download
     * @param chat_id Chat identifier of the message with the file
     * @param message_id Message identifier
     * @param priority Priority of the download (1-32). The higher the
     * priority, the earlier the file will be downloaded. If the priorities
     * of two files are equal, then the last one for which
     * downloadFile/addFileToDownloads was called will be downloaded first
     */
    public async File add_file_to_downloads (
        int32 file_id,
        int64 chat_id,
        int64 message_id,
        int32 priority
    ) throws BadStatusCodeError {
        var obj = new AddFileToDownloads (
            file_id,
            chat_id,
            message_id,
            priority
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_file_to_downloads.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        File out_obj;
        switch (tdlib_type) {
            case "file":
                out_obj = (File) jsoner.deserialize_object (typeof (File));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes pause state of a file in the file download list
     * @param file_id Identifier of the downloaded file
     * @param is_paused Pass true if the download is paused
     */
    public async Ok toggle_download_is_paused (
        int32 file_id,
        bool is_paused
    ) throws BadStatusCodeError {
        var obj = new ToggleDownloadIsPaused (
            file_id,
            is_paused
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_download_is_paused.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes pause state of all files in the file download list
     * @param are_paused Pass true to pause all downloads; pass false to
     * unpause them
     */
    public async Ok toggle_all_downloads_are_paused (
        bool are_paused
    ) throws BadStatusCodeError {
        var obj = new ToggleAllDownloadsArePaused (
            are_paused
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_all_downloads_are_paused.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes a file from the file download list
     * @param file_id Identifier of the downloaded file
     * @param delete_from_cache Pass true to delete the file from the TDLib
     * file cache
     */
    public async Ok remove_file_from_downloads (
        int32 file_id,
        bool delete_from_cache
    ) throws BadStatusCodeError {
        var obj = new RemoveFileFromDownloads (
            file_id,
            delete_from_cache
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_file_from_downloads.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes all files from the file download list
     * @param only_active Pass true to remove only active downloads,
     * including paused
     * @param only_completed Pass true to remove only completed downloads
     * @param delete_from_cache Pass true to delete the file from the TDLib
     * file cache
     */
    public async Ok remove_all_files_from_downloads (
        bool only_active,
        bool only_completed,
        bool delete_from_cache
    ) throws BadStatusCodeError {
        var obj = new RemoveAllFilesFromDownloads (
            only_active,
            only_completed,
            delete_from_cache
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_all_files_from_downloads.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for files in the file download list or recently downloaded
     * files from the list
     * @param query Query to search for; may be empty to return all
     * downloaded files
     * @param only_active Pass true to search only for active downloads,
     * including paused
     * @param only_completed Pass true to search only for completed downloads
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of files to be returned
     */
    public async FoundFileDownloads search_file_downloads (
        string query,
        bool only_active,
        bool only_completed,
        string offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new SearchFileDownloads (
            query,
            only_active,
            only_completed,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_file_downloads.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundFileDownloads out_obj;
        switch (tdlib_type) {
            case "foundFileDownloads":
                out_obj = (FoundFileDownloads) jsoner.deserialize_object (typeof (FoundFileDownloads));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Application verification has been completed. Can be called before
     * authorization
     * @param verification_id Unique identifier for the verification process
     * as received from updateApplicationVerificationRequired
     * @param token Play Integrity API token for the Android application, or
     * secret from push notification for the iOS application; pass an empty
     * string to abort verification and receive error VERIFICATION_FAILED for
     * the request
     */
    public async Ok set_application_verification_token (
        int64 verification_id,
        string token
    ) throws BadStatusCodeError {
        var obj = new SetApplicationVerificationToken (
            verification_id,
            token
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_application_verification_token.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a file with messages exported from another
     * application
     * @param message_file_head Beginning of the message file; up to 100
     * first lines
     */
    public async MessageFileType get_message_file_type (
        string message_file_head
    ) throws BadStatusCodeError {
        var obj = new GetMessageFileType (
            message_file_head
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_file_type.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        MessageFileType out_obj;
        switch (tdlib_type) {
            case "messageFileTypePrivate":
                out_obj = (MessageFileTypePrivate) jsoner.deserialize_object (typeof (MessageFileTypePrivate));
                break;
            case "messageFileTypeGroup":
                out_obj = (MessageFileTypeGroup) jsoner.deserialize_object (typeof (MessageFileTypeGroup));
                break;
            case "messageFileTypeUnknown":
                out_obj = (MessageFileTypeUnknown) jsoner.deserialize_object (typeof (MessageFileTypeUnknown));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a confirmation text to be shown to the user before starting
     * message import
     * @param chat_id Identifier of a chat to which the messages will be
     * imported. It must be an identifier of a private chat with a mutual
     * contact or an identifier of a supergroup chat with can_change_info
     * member right
     */
    public async Text get_message_import_confirmation_text (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new GetMessageImportConfirmationText (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_import_confirmation_text.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Imports messages exported from another app
     * @param chat_id Identifier of a chat to which the messages will be
     * imported. It must be an identifier of a private chat with a mutual
     * contact or an identifier of a supergroup chat with can_change_info
     * member right
     * @param message_file File with messages to import. Only inputFileLocal
     * and inputFileGenerated are supported. The file must not be previously
     * uploaded
     * @param attached_files Files used in the imported messages. Only
     * inputFileLocal and inputFileGenerated are supported. The files must
     * not be previously uploaded
     */
    public async Ok import_messages (
        int64 chat_id,
        InputFile message_file,
        Gee.ArrayList<InputFile?> attached_files
    ) throws BadStatusCodeError {
        var obj = new ImportMessages (
            chat_id,
            message_file,
            attached_files
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (import_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Replaces current primary invite link for a chat with a new primary
     * invite link. Available for basic groups, supergroups, and channels.
     * Requires administrator privileges and can_invite_users right
     * @param chat_id Chat identifier
     */
    public async ChatInviteLink replace_primary_chat_invite_link (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new ReplacePrimaryChatInviteLink (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (replace_primary_chat_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatInviteLink out_obj;
        switch (tdlib_type) {
            case "chatInviteLink":
                out_obj = (ChatInviteLink) jsoner.deserialize_object (typeof (ChatInviteLink));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Creates a new invite link for a chat. Available for basic groups,
     * supergroups, and channels. Requires administrator privileges and
     * can_invite_users right in the chat
     * @param chat_id Chat identifier
     * @param name Invite link name; 0-32 characters
     * @param expiration_date Point in time (Unix timestamp) when the link
     * will expire; pass 0 if never
     * @param member_limit The maximum number of chat members that can join
     * the chat via the link simultaneously; 0-99999; pass 0 if not limited
     * @param creates_join_request Pass true if users joining the chat via
     * the link need to be approved by chat administrators. In this case,
     * member_limit must be 0
     */
    public async ChatInviteLink create_chat_invite_link (
        int64 chat_id,
        string name,
        int32 expiration_date,
        int32 member_limit,
        bool creates_join_request
    ) throws BadStatusCodeError {
        var obj = new CreateChatInviteLink (
            chat_id,
            name,
            expiration_date,
            member_limit,
            creates_join_request
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_chat_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatInviteLink out_obj;
        switch (tdlib_type) {
            case "chatInviteLink":
                out_obj = (ChatInviteLink) jsoner.deserialize_object (typeof (ChatInviteLink));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Creates a new subscription invite link for a channel chat. Requires
     * can_invite_users right in the chat
     * @param chat_id Chat identifier
     * @param name Invite link name; 0-32 characters
     * @param subscription_pricing Information about subscription plan that
     * will be applied to the users joining the chat via the link.
     * Subscription period must be 2592000 in production environment, and 60
     * or 300 if Telegram test environment is used
     */
    public async ChatInviteLink create_chat_subscription_invite_link (
        int64 chat_id,
        string name,
        StarSubscriptionPricing subscription_pricing
    ) throws BadStatusCodeError {
        var obj = new CreateChatSubscriptionInviteLink (
            chat_id,
            name,
            subscription_pricing
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_chat_subscription_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatInviteLink out_obj;
        switch (tdlib_type) {
            case "chatInviteLink":
                out_obj = (ChatInviteLink) jsoner.deserialize_object (typeof (ChatInviteLink));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits a non-primary invite link for a chat. Available for basic
     * groups, supergroups, and channels.
     * If the link creates a subscription, then expiration_date, member_limit
     * and creates_join_request must not be used.
     * Requires administrator privileges and can_invite_users right in the
     * chat for own links and owner privileges for other links
     * @param chat_id Chat identifier
     * @param invite_link Invite link to be edited
     * @param name Invite link name; 0-32 characters
     * @param expiration_date Point in time (Unix timestamp) when the link
     * will expire; pass 0 if never
     * @param member_limit The maximum number of chat members that can join
     * the chat via the link simultaneously; 0-99999; pass 0 if not limited
     * @param creates_join_request Pass true if users joining the chat via
     * the link need to be approved by chat administrators. In this case,
     * member_limit must be 0
     */
    public async ChatInviteLink edit_chat_invite_link (
        int64 chat_id,
        string invite_link,
        string name,
        int32 expiration_date,
        int32 member_limit,
        bool creates_join_request
    ) throws BadStatusCodeError {
        var obj = new EditChatInviteLink (
            chat_id,
            invite_link,
            name,
            expiration_date,
            member_limit,
            creates_join_request
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_chat_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatInviteLink out_obj;
        switch (tdlib_type) {
            case "chatInviteLink":
                out_obj = (ChatInviteLink) jsoner.deserialize_object (typeof (ChatInviteLink));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits a subscription invite link for a channel chat. Requires
     * can_invite_users right in the chat for own links and owner privileges
     * for other links
     * @param chat_id Chat identifier
     * @param invite_link Invite link to be edited
     * @param name Invite link name; 0-32 characters
     */
    public async ChatInviteLink edit_chat_subscription_invite_link (
        int64 chat_id,
        string invite_link,
        string name
    ) throws BadStatusCodeError {
        var obj = new EditChatSubscriptionInviteLink (
            chat_id,
            invite_link,
            name
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_chat_subscription_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatInviteLink out_obj;
        switch (tdlib_type) {
            case "chatInviteLink":
                out_obj = (ChatInviteLink) jsoner.deserialize_object (typeof (ChatInviteLink));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about an invite link. Requires administrator
     * privileges and can_invite_users right in the chat to get own links and
     * owner privileges to get other links
     * @param chat_id Chat identifier
     * @param invite_link Invite link to get
     */
    public async ChatInviteLink get_chat_invite_link (
        int64 chat_id,
        string invite_link
    ) throws BadStatusCodeError {
        var obj = new GetChatInviteLink (
            chat_id,
            invite_link
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatInviteLink out_obj;
        switch (tdlib_type) {
            case "chatInviteLink":
                out_obj = (ChatInviteLink) jsoner.deserialize_object (typeof (ChatInviteLink));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of chat administrators with number of their invite
     * links. Requires owner privileges in the chat
     * @param chat_id Chat identifier
     */
    public async ChatInviteLinkCounts get_chat_invite_link_counts (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new GetChatInviteLinkCounts (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_invite_link_counts.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatInviteLinkCounts out_obj;
        switch (tdlib_type) {
            case "chatInviteLinkCounts":
                out_obj = (ChatInviteLinkCounts) jsoner.deserialize_object (typeof (ChatInviteLinkCounts));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns invite links for a chat created by specified administrator.
     * Requires administrator privileges and can_invite_users right in the
     * chat to get own links and owner privileges to get other links
     * @param chat_id Chat identifier
     * @param creator_user_id User identifier of a chat administrator. Must
     * be an identifier of the current user for non-owner
     * @param is_revoked Pass true if revoked links needs to be returned
     * instead of active or expired
     * @param offset_date Creation date of an invite link starting after
     * which to return invite links; use 0 to get results from the beginning
     * @param offset_invite_link Invite link starting after which to return
     * invite links; use empty string to get results from the beginning
     * @param limit The maximum number of invite links to return; up to 100
     */
    public async ChatInviteLinks get_chat_invite_links (
        int64 chat_id,
        int64 creator_user_id,
        bool is_revoked,
        int32 offset_date,
        string offset_invite_link,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetChatInviteLinks (
            chat_id,
            creator_user_id,
            is_revoked,
            offset_date,
            offset_invite_link,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_invite_links.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatInviteLinks out_obj;
        switch (tdlib_type) {
            case "chatInviteLinks":
                out_obj = (ChatInviteLinks) jsoner.deserialize_object (typeof (ChatInviteLinks));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns chat members joined a chat via an invite link. Requires
     * administrator privileges and can_invite_users right in the chat for
     * own links and owner privileges for other links
     * @param chat_id Chat identifier
     * @param invite_link Invite link for which to return chat members
     * @param only_with_expired_subscription Pass true if the link is a
     * subscription link and only members with expired subscription must be
     * returned
     * @param offset_member A chat member from which to return next chat
     * members; pass null to get results from the beginning
     * @param limit The maximum number of chat members to return; up to 100
     */
    public async ChatInviteLinkMembers get_chat_invite_link_members (
        int64 chat_id,
        string invite_link,
        bool only_with_expired_subscription,
        ChatInviteLinkMember offset_member,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetChatInviteLinkMembers (
            chat_id,
            invite_link,
            only_with_expired_subscription,
            offset_member,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_invite_link_members.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatInviteLinkMembers out_obj;
        switch (tdlib_type) {
            case "chatInviteLinkMembers":
                out_obj = (ChatInviteLinkMembers) jsoner.deserialize_object (typeof (ChatInviteLinkMembers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Revokes invite link for a chat. Available for basic groups,
     * supergroups, and channels. Requires administrator privileges and
     * can_invite_users right in the chat for own links and owner privileges
     * for other links.
     * If a primary link is revoked, then additionally to the revoked link
     * returns new primary link
     * @param chat_id Chat identifier
     * @param invite_link Invite link to be revoked
     */
    public async ChatInviteLinks revoke_chat_invite_link (
        int64 chat_id,
        string invite_link
    ) throws BadStatusCodeError {
        var obj = new RevokeChatInviteLink (
            chat_id,
            invite_link
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (revoke_chat_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatInviteLinks out_obj;
        switch (tdlib_type) {
            case "chatInviteLinks":
                out_obj = (ChatInviteLinks) jsoner.deserialize_object (typeof (ChatInviteLinks));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes revoked chat invite links. Requires administrator privileges
     * and can_invite_users right in the chat for own links and owner
     * privileges for other links
     * @param chat_id Chat identifier
     * @param invite_link Invite link to revoke
     */
    public async Ok delete_revoked_chat_invite_link (
        int64 chat_id,
        string invite_link
    ) throws BadStatusCodeError {
        var obj = new DeleteRevokedChatInviteLink (
            chat_id,
            invite_link
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_revoked_chat_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes all revoked chat invite links created by a given chat
     * administrator. Requires administrator privileges and can_invite_users
     * right in the chat for own links and owner privileges for other links
     * @param chat_id Chat identifier
     * @param creator_user_id User identifier of a chat administrator, which
     * links will be deleted. Must be an identifier of the current user for
     * non-owner
     */
    public async Ok delete_all_revoked_chat_invite_links (
        int64 chat_id,
        int64 creator_user_id
    ) throws BadStatusCodeError {
        var obj = new DeleteAllRevokedChatInviteLinks (
            chat_id,
            creator_user_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_all_revoked_chat_invite_links.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks the validity of an invite link for a chat and returns
     * information about the corresponding chat
     * @param invite_link Invite link to be checked
     */
    public async ChatInviteLinkInfo check_chat_invite_link (
        string invite_link
    ) throws BadStatusCodeError {
        var obj = new CheckChatInviteLink (
            invite_link
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_chat_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatInviteLinkInfo out_obj;
        switch (tdlib_type) {
            case "chatInviteLinkInfo":
                out_obj = (ChatInviteLinkInfo) jsoner.deserialize_object (typeof (ChatInviteLinkInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Uses an invite link to add the current user to the chat if possible.
     * May return an error with a message "INVITE_REQUEST_SENT" if only a
     * join request was created
     * @param invite_link Invite link to use
     */
    public async Chat join_chat_by_invite_link (
        string invite_link
    ) throws BadStatusCodeError {
        var obj = new JoinChatByInviteLink (
            invite_link
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (join_chat_by_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Chat out_obj;
        switch (tdlib_type) {
            case "chat":
                out_obj = (Chat) jsoner.deserialize_object (typeof (Chat));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns pending join requests in a chat
     * @param chat_id Chat identifier
     * @param invite_link Invite link for which to return join requests. If
     * empty, all join requests will be returned. Requires administrator
     * privileges and can_invite_users right in the chat for own links and
     * owner privileges for other links
     * @param query A query to search for in the first names, last names and
     * usernames of the users to return
     * @param offset_request A chat join request from which to return next
     * requests; pass null to get results from the beginning
     * @param limit The maximum number of requests to join the chat to return
     */
    public async ChatJoinRequests get_chat_join_requests (
        int64 chat_id,
        string invite_link,
        string query,
        ChatJoinRequest offset_request,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetChatJoinRequests (
            chat_id,
            invite_link,
            query,
            offset_request,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_join_requests.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatJoinRequests out_obj;
        switch (tdlib_type) {
            case "chatJoinRequests":
                out_obj = (ChatJoinRequests) jsoner.deserialize_object (typeof (ChatJoinRequests));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Handles a pending join request in a chat
     * @param chat_id Chat identifier
     * @param user_id Identifier of the user that sent the request
     * @param approve Pass true to approve the request; pass false to decline
     * it
     */
    public async Ok process_chat_join_request (
        int64 chat_id,
        int64 user_id,
        bool approve
    ) throws BadStatusCodeError {
        var obj = new ProcessChatJoinRequest (
            chat_id,
            user_id,
            approve
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (process_chat_join_request.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Handles all pending join requests for a given link in a chat
     * @param chat_id Chat identifier
     * @param invite_link Invite link for which to process join requests. If
     * empty, all join requests will be processed. Requires administrator
     * privileges and can_invite_users right in the chat for own links and
     * owner privileges for other links
     * @param approve Pass true to approve all requests; pass false to
     * decline them
     */
    public async Ok process_chat_join_requests (
        int64 chat_id,
        string invite_link,
        bool approve
    ) throws BadStatusCodeError {
        var obj = new ProcessChatJoinRequests (
            chat_id,
            invite_link,
            approve
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (process_chat_join_requests.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Creates a new call
     * @param user_id Identifier of the user to be called
     * @param protocol The call protocols supported by the application
     * @param is_video Pass true to create a video call
     */
    public async CallId create_call (
        int64 user_id,
        CallProtocol protocol,
        bool is_video
    ) throws BadStatusCodeError {
        var obj = new CreateCall (
            user_id,
            protocol,
            is_video
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_call.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        CallId out_obj;
        switch (tdlib_type) {
            case "callId":
                out_obj = (CallId) jsoner.deserialize_object (typeof (CallId));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Accepts an incoming call
     * @param call_id Call identifier
     * @param protocol The call protocols supported by the application
     */
    public async Ok accept_call (
        int32 call_id,
        CallProtocol protocol
    ) throws BadStatusCodeError {
        var obj = new AcceptCall (
            call_id,
            protocol
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (accept_call.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends call signaling data
     * @param call_id Call identifier
     * @param data The data
     */
    public async Ok send_call_signaling_data (
        int32 call_id,
        Bytes data
    ) throws BadStatusCodeError {
        var obj = new SendCallSignalingData (
            call_id,
            data
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_call_signaling_data.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Discards a call
     * @param call_id Call identifier
     * @param is_disconnected Pass true if the user was disconnected
     * @param duration The call duration, in seconds
     * @param is_video Pass true if the call was a video call
     * @param connection_id Identifier of the connection used during the call
     */
    public async Ok discard_call (
        int32 call_id,
        bool is_disconnected,
        int32 duration,
        bool is_video,
        int64 connection_id
    ) throws BadStatusCodeError {
        var obj = new DiscardCall (
            call_id,
            is_disconnected,
            duration,
            is_video,
            connection_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (discard_call.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends a call rating
     * @param call_id Call identifier
     * @param rating Call rating; 1-5
     * @param comment An optional user comment if the rating is less than 5
     * @param problems List of the exact types of problems with the call,
     * specified by the user
     */
    public async Ok send_call_rating (
        int32 call_id,
        int32 rating,
        string comment,
        Gee.ArrayList<CallProblem?> problems
    ) throws BadStatusCodeError {
        var obj = new SendCallRating (
            call_id,
            rating,
            comment,
            problems
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_call_rating.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends debug information for a call to Telegram servers
     * @param call_id Call identifier
     * @param debug_information Debug information in application-specific
     * format
     */
    public async Ok send_call_debug_information (
        int32 call_id,
        string debug_information
    ) throws BadStatusCodeError {
        var obj = new SendCallDebugInformation (
            call_id,
            debug_information
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_call_debug_information.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends log file for a call to Telegram servers
     * @param call_id Call identifier
     * @param log_file Call log file. Only inputFileLocal and
     * inputFileGenerated are supported
     */
    public async Ok send_call_log (
        int32 call_id,
        InputFile log_file
    ) throws BadStatusCodeError {
        var obj = new SendCallLog (
            call_id,
            log_file
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_call_log.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of participant identifiers, on whose behalf a video
     * chat in the chat can be joined
     * @param chat_id Chat identifier
     */
    public async MessageSenders get_video_chat_available_participants (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new GetVideoChatAvailableParticipants (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_video_chat_available_participants.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        MessageSenders out_obj;
        switch (tdlib_type) {
            case "messageSenders":
                out_obj = (MessageSenders) jsoner.deserialize_object (typeof (MessageSenders));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes default participant identifier, on whose behalf a video chat
     * in the chat will be joined
     * @param chat_id Chat identifier
     * @param default_participant_id Default group call participant
     * identifier to join the video chats
     */
    public async Ok set_video_chat_default_participant (
        int64 chat_id,
        MessageSender default_participant_id
    ) throws BadStatusCodeError {
        var obj = new SetVideoChatDefaultParticipant (
            chat_id,
            default_participant_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_video_chat_default_participant.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Creates a video chat (a group call bound to a chat). Available only
     * for basic groups, supergroups and channels; requires
     * can_manage_video_chats administrator right
     * @param chat_id Identifier of a chat in which the video chat will be
     * created
     * @param title Group call title; if empty, chat title will be used
     * @param start_date Point in time (Unix timestamp) when the group call
     * is expected to be started by an administrator; 0 to start the video
     * chat immediately. The date must be at least 10 seconds and at most 8
     * days in the future
     * @param is_rtmp_stream Pass true to create an RTMP stream instead of an
     * ordinary video chat; requires owner privileges
     */
    public async GroupCallId create_video_chat (
        int64 chat_id,
        string title,
        int32 start_date,
        bool is_rtmp_stream
    ) throws BadStatusCodeError {
        var obj = new CreateVideoChat (
            chat_id,
            title,
            start_date,
            is_rtmp_stream
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_video_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        GroupCallId out_obj;
        switch (tdlib_type) {
            case "groupCallId":
                out_obj = (GroupCallId) jsoner.deserialize_object (typeof (GroupCallId));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns RTMP URL for streaming to the chat; requires
     * can_manage_video_chats administrator right
     * @param chat_id Chat identifier
     */
    public async RtmpUrl get_video_chat_rtmp_url (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new GetVideoChatRtmpUrl (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_video_chat_rtmp_url.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        RtmpUrl out_obj;
        switch (tdlib_type) {
            case "rtmpUrl":
                out_obj = (RtmpUrl) jsoner.deserialize_object (typeof (RtmpUrl));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Replaces the current RTMP URL for streaming to the chat; requires
     * owner privileges
     * @param chat_id Chat identifier
     */
    public async RtmpUrl replace_video_chat_rtmp_url (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new ReplaceVideoChatRtmpUrl (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (replace_video_chat_rtmp_url.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        RtmpUrl out_obj;
        switch (tdlib_type) {
            case "rtmpUrl":
                out_obj = (RtmpUrl) jsoner.deserialize_object (typeof (RtmpUrl));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a group call
     * @param group_call_id Group call identifier
     */
    public async GroupCall get_group_call (
        int32 group_call_id
    ) throws BadStatusCodeError {
        var obj = new GetGroupCall (
            group_call_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_group_call.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        GroupCall out_obj;
        switch (tdlib_type) {
            case "groupCall":
                out_obj = (GroupCall) jsoner.deserialize_object (typeof (GroupCall));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Starts a scheduled group call
     * @param group_call_id Group call identifier
     */
    public async Ok start_scheduled_group_call (
        int32 group_call_id
    ) throws BadStatusCodeError {
        var obj = new StartScheduledGroupCall (
            group_call_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (start_scheduled_group_call.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether the current user will receive a notification when the
     * group call starts; scheduled group calls only
     * @param group_call_id Group call identifier
     * @param enabled_start_notification New value of the
     * enabled_start_notification setting
     */
    public async Ok toggle_group_call_enabled_start_notification (
        int32 group_call_id,
        bool enabled_start_notification
    ) throws BadStatusCodeError {
        var obj = new ToggleGroupCallEnabledStartNotification (
            group_call_id,
            enabled_start_notification
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_group_call_enabled_start_notification.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Joins an active group call. Returns join response payload for tgcalls
     * @param group_call_id Group call identifier
     * @param participant_id Identifier of a group call participant, which
     * will be used to join the call; pass null to join as self; video chats
     * only
     * @param audio_source_id Caller audio channel synchronization source
     * identifier; received from tgcalls
     * @param payload Group call join payload; received from tgcalls
     * @param is_muted Pass true to join the call with muted microphone
     * @param is_my_video_enabled Pass true if the user's video is enabled
     * @param invite_hash If non-empty, invite hash to be used to join the
     * group call without being muted by administrators
     */
    public async Text join_group_call (
        int32 group_call_id,
        MessageSender participant_id,
        int32 audio_source_id,
        string payload,
        bool is_muted,
        bool is_my_video_enabled,
        string invite_hash
    ) throws BadStatusCodeError {
        var obj = new JoinGroupCall (
            group_call_id,
            participant_id,
            audio_source_id,
            payload,
            is_muted,
            is_my_video_enabled,
            invite_hash
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (join_group_call.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Starts screen sharing in a joined group call. Returns join response
     * payload for tgcalls
     * @param group_call_id Group call identifier
     * @param audio_source_id Screen sharing audio channel synchronization
     * source identifier; received from tgcalls
     * @param payload Group call join payload; received from tgcalls
     */
    public async Text start_group_call_screen_sharing (
        int32 group_call_id,
        int32 audio_source_id,
        string payload
    ) throws BadStatusCodeError {
        var obj = new StartGroupCallScreenSharing (
            group_call_id,
            audio_source_id,
            payload
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (start_group_call_screen_sharing.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Pauses or unpauses screen sharing in a joined group call
     * @param group_call_id Group call identifier
     * @param is_paused Pass true to pause screen sharing; pass false to
     * unpause it
     */
    public async Ok toggle_group_call_screen_sharing_is_paused (
        int32 group_call_id,
        bool is_paused
    ) throws BadStatusCodeError {
        var obj = new ToggleGroupCallScreenSharingIsPaused (
            group_call_id,
            is_paused
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_group_call_screen_sharing_is_paused.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Ends screen sharing in a joined group call
     * @param group_call_id Group call identifier
     */
    public async Ok end_group_call_screen_sharing (
        int32 group_call_id
    ) throws BadStatusCodeError {
        var obj = new EndGroupCallScreenSharing (
            group_call_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (end_group_call_screen_sharing.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets group call title. Requires groupCall.can_be_managed group call
     * flag
     * @param group_call_id Group call identifier
     * @param title New group call title; 1-64 characters
     */
    public async Ok set_group_call_title (
        int32 group_call_id,
        string title
    ) throws BadStatusCodeError {
        var obj = new SetGroupCallTitle (
            group_call_id,
            title
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_group_call_title.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether new participants of a group call can be unmuted only
     * by administrators of the group call. Requires
     * groupCall.can_toggle_mute_new_participants group call flag
     * @param group_call_id Group call identifier
     * @param mute_new_participants New value of the mute_new_participants
     * setting
     */
    public async Ok toggle_group_call_mute_new_participants (
        int32 group_call_id,
        bool mute_new_participants
    ) throws BadStatusCodeError {
        var obj = new ToggleGroupCallMuteNewParticipants (
            group_call_id,
            mute_new_participants
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_group_call_mute_new_participants.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Invites users to an active group call. Sends a service message of type
     * messageInviteVideoChatParticipants for video chats
     * @param group_call_id Group call identifier
     * @param user_ids User identifiers. At most 10 users can be invited
     * simultaneously
     */
    public async Ok invite_group_call_participants (
        int32 group_call_id,
        Gee.ArrayList<int64?> user_ids
    ) throws BadStatusCodeError {
        var obj = new InviteGroupCallParticipants (
            group_call_id,
            user_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (invite_group_call_participants.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns invite link to a video chat in a public chat
     * @param group_call_id Group call identifier
     * @param can_self_unmute Pass true if the invite link needs to contain
     * an invite hash, passing which to joinGroupCall would allow the invited
     * user to unmute themselves. Requires groupCall.can_be_managed group
     * call flag
     */
    public async HttpUrl get_group_call_invite_link (
        int32 group_call_id,
        bool can_self_unmute
    ) throws BadStatusCodeError {
        var obj = new GetGroupCallInviteLink (
            group_call_id,
            can_self_unmute
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_group_call_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        HttpUrl out_obj;
        switch (tdlib_type) {
            case "httpUrl":
                out_obj = (HttpUrl) jsoner.deserialize_object (typeof (HttpUrl));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Revokes invite link for a group call. Requires
     * groupCall.can_be_managed group call flag
     * @param group_call_id Group call identifier
     */
    public async Ok revoke_group_call_invite_link (
        int32 group_call_id
    ) throws BadStatusCodeError {
        var obj = new RevokeGroupCallInviteLink (
            group_call_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (revoke_group_call_invite_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Starts recording of an active group call. Requires
     * groupCall.can_be_managed group call flag
     * @param group_call_id Group call identifier
     * @param title Group call recording title; 0-64 characters
     * @param record_video Pass true to record a video file instead of an
     * audio file
     * @param use_portrait_orientation Pass true to use portrait orientation
     * for video instead of landscape one
     */
    public async Ok start_group_call_recording (
        int32 group_call_id,
        string title,
        bool record_video,
        bool use_portrait_orientation
    ) throws BadStatusCodeError {
        var obj = new StartGroupCallRecording (
            group_call_id,
            title,
            record_video,
            use_portrait_orientation
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (start_group_call_recording.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Ends recording of an active group call. Requires
     * groupCall.can_be_managed group call flag
     * @param group_call_id Group call identifier
     */
    public async Ok end_group_call_recording (
        int32 group_call_id
    ) throws BadStatusCodeError {
        var obj = new EndGroupCallRecording (
            group_call_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (end_group_call_recording.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether current user's video is paused
     * @param group_call_id Group call identifier
     * @param is_my_video_paused Pass true if the current user's video is
     * paused
     */
    public async Ok toggle_group_call_is_my_video_paused (
        int32 group_call_id,
        bool is_my_video_paused
    ) throws BadStatusCodeError {
        var obj = new ToggleGroupCallIsMyVideoPaused (
            group_call_id,
            is_my_video_paused
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_group_call_is_my_video_paused.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether current user's video is enabled
     * @param group_call_id Group call identifier
     * @param is_my_video_enabled Pass true if the current user's video is
     * enabled
     */
    public async Ok toggle_group_call_is_my_video_enabled (
        int32 group_call_id,
        bool is_my_video_enabled
    ) throws BadStatusCodeError {
        var obj = new ToggleGroupCallIsMyVideoEnabled (
            group_call_id,
            is_my_video_enabled
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_group_call_is_my_video_enabled.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs TDLib that speaking state of a participant of an active group
     * has changed
     * @param group_call_id Group call identifier
     * @param audio_source Group call participant's synchronization audio
     * source identifier, or 0 for the current user
     * @param is_speaking Pass true if the user is speaking
     */
    public async Ok set_group_call_participant_is_speaking (
        int32 group_call_id,
        int32 audio_source,
        bool is_speaking
    ) throws BadStatusCodeError {
        var obj = new SetGroupCallParticipantIsSpeaking (
            group_call_id,
            audio_source,
            is_speaking
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_group_call_participant_is_speaking.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether a participant of an active group call is muted,
     * unmuted, or allowed to unmute themselves
     * @param group_call_id Group call identifier
     * @param participant_id Participant identifier
     * @param is_muted Pass true to mute the user; pass false to unmute them
     */
    public async Ok toggle_group_call_participant_is_muted (
        int32 group_call_id,
        MessageSender participant_id,
        bool is_muted
    ) throws BadStatusCodeError {
        var obj = new ToggleGroupCallParticipantIsMuted (
            group_call_id,
            participant_id,
            is_muted
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_group_call_participant_is_muted.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes volume level of a participant of an active group call. If the
     * current user can manage the group call, then the participant's volume
     * level will be changed for all users with the default volume level
     * @param group_call_id Group call identifier
     * @param participant_id Participant identifier
     * @param volume_level New participant's volume level; 1-20000 in
     * hundreds of percents
     */
    public async Ok set_group_call_participant_volume_level (
        int32 group_call_id,
        MessageSender participant_id,
        int32 volume_level
    ) throws BadStatusCodeError {
        var obj = new SetGroupCallParticipantVolumeLevel (
            group_call_id,
            participant_id,
            volume_level
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_group_call_participant_volume_level.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether a group call participant hand is rased
     * @param group_call_id Group call identifier
     * @param participant_id Participant identifier
     * @param is_hand_raised Pass true if the user's hand needs to be raised.
     * Only self hand can be raised. Requires groupCall.can_be_managed group
     * call flag to lower other's hand
     */
    public async Ok toggle_group_call_participant_is_hand_raised (
        int32 group_call_id,
        MessageSender participant_id,
        bool is_hand_raised
    ) throws BadStatusCodeError {
        var obj = new ToggleGroupCallParticipantIsHandRaised (
            group_call_id,
            participant_id,
            is_hand_raised
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_group_call_participant_is_hand_raised.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Loads more participants of a group call. The loaded participants will
     * be received through updates. Use the field
     * groupCall.loaded_all_participants to check whether all participants
     * have already been loaded
     * @param group_call_id Group call identifier. The group call must be
     * previously received through getGroupCall and must be joined or being
     * joined
     * @param limit The maximum number of participants to load; up to 100
     */
    public async Ok load_group_call_participants (
        int32 group_call_id,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new LoadGroupCallParticipants (
            group_call_id,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (load_group_call_participants.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Leaves a group call
     * @param group_call_id Group call identifier
     */
    public async Ok leave_group_call (
        int32 group_call_id
    ) throws BadStatusCodeError {
        var obj = new LeaveGroupCall (
            group_call_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (leave_group_call.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Ends a group call. Requires groupCall.can_be_managed
     * @param group_call_id Group call identifier
     */
    public async Ok end_group_call (
        int32 group_call_id
    ) throws BadStatusCodeError {
        var obj = new EndGroupCall (
            group_call_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (end_group_call.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about available group call streams
     * @param group_call_id Group call identifier
     */
    public async GroupCallStreams get_group_call_streams (
        int32 group_call_id
    ) throws BadStatusCodeError {
        var obj = new GetGroupCallStreams (
            group_call_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_group_call_streams.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        GroupCallStreams out_obj;
        switch (tdlib_type) {
            case "groupCallStreams":
                out_obj = (GroupCallStreams) jsoner.deserialize_object (typeof (GroupCallStreams));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a file with a segment of a group call stream in a modified OGG
     * format for audio or MPEG-4 format for video
     * @param group_call_id Group call identifier
     * @param time_offset Point in time when the stream segment begins; Unix
     * timestamp in milliseconds
     * @param scale Segment duration scale; 0-1. Segment's duration is
     * 1000/(2**scale) milliseconds
     * @param channel_id Identifier of an audio/video channel to get as
     * received from tgcalls
     * @param video_quality Video quality as received from tgcalls; pass null
     * to get the worst available quality
     */
    public async FilePart get_group_call_stream_segment (
        int32 group_call_id,
        int64 time_offset,
        int32 scale,
        int32 channel_id,
        GroupCallVideoQuality video_quality
    ) throws BadStatusCodeError {
        var obj = new GetGroupCallStreamSegment (
            group_call_id,
            time_offset,
            scale,
            channel_id,
            video_quality
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_group_call_stream_segment.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FilePart out_obj;
        switch (tdlib_type) {
            case "filePart":
                out_obj = (FilePart) jsoner.deserialize_object (typeof (FilePart));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the block list of a message sender. Currently, only users and
     * supergroup chats can be blocked
     * @param sender_id Identifier of a message sender to block/unblock
     * @param block_list New block list for the message sender; pass null to
     * unblock the message sender
     */
    public async Ok set_message_sender_block_list (
        MessageSender sender_id,
        BlockList block_list
    ) throws BadStatusCodeError {
        var obj = new SetMessageSenderBlockList (
            sender_id,
            block_list
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_message_sender_block_list.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Blocks an original sender of a message in the Replies chat
     * @param message_id The identifier of an incoming message in the Replies
     * chat
     * @param delete_message Pass true to delete the message
     * @param delete_all_messages Pass true to delete all messages from the
     * same sender
     * @param report_spam Pass true to report the sender to the Telegram
     * moderators
     */
    public async Ok block_message_sender_from_replies (
        int64 message_id,
        bool delete_message,
        bool delete_all_messages,
        bool report_spam
    ) throws BadStatusCodeError {
        var obj = new BlockMessageSenderFromReplies (
            message_id,
            delete_message,
            delete_all_messages,
            report_spam
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (block_message_sender_from_replies.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns users and chats that were blocked by the current user
     * @param block_list Block list from which to return users
     * @param offset Number of users and chats to skip in the result; must be
     * non-negative
     * @param limit The maximum number of users and chats to return; up to
     * 100
     */
    public async MessageSenders get_blocked_message_senders (
        BlockList block_list,
        int32 offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetBlockedMessageSenders (
            block_list,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_blocked_message_senders.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        MessageSenders out_obj;
        switch (tdlib_type) {
            case "messageSenders":
                out_obj = (MessageSenders) jsoner.deserialize_object (typeof (MessageSenders));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a user to the contact list or edits an existing contact by their
     * user identifier
     * @param contact The contact to add or edit; phone number may be empty
     * and needs to be specified only if known, vCard is ignored
     * @param share_phone_number Pass true to share the current user's phone
     * number with the new contact. A corresponding rule to
     * userPrivacySettingShowPhoneNumber will be added if needed. Use the
     * field userFullInfo.need_phone_number_privacy_exception to check
     * whether the current user needs to be asked to share their phone number
     */
    public async Ok add_contact (
        Contact contact,
        bool share_phone_number
    ) throws BadStatusCodeError {
        var obj = new AddContact (
            contact,
            share_phone_number
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_contact.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds new contacts or edits existing contacts by their phone numbers;
     * contacts' user identifiers are ignored
     * @param contacts The list of contacts to import or edit; contacts'
     * vCard are ignored and are not imported
     */
    public async ImportedContacts import_contacts (
        Gee.ArrayList<Contact?> contacts
    ) throws BadStatusCodeError {
        var obj = new ImportContacts (
            contacts
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (import_contacts.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ImportedContacts out_obj;
        switch (tdlib_type) {
            case "importedContacts":
                out_obj = (ImportedContacts) jsoner.deserialize_object (typeof (ImportedContacts));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns all contacts of the user
     */
    public async Users get_contacts () throws BadStatusCodeError {
        var obj = new GetContacts ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_contacts.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Users out_obj;
        switch (tdlib_type) {
            case "users":
                out_obj = (Users) jsoner.deserialize_object (typeof (Users));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for the specified query in the first names, last names and
     * usernames of the known user contacts
     * @param query Query to search for; may be empty to return all contacts
     * @param limit The maximum number of users to be returned
     */
    public async Users search_contacts (
        string query,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new SearchContacts (
            query,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_contacts.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Users out_obj;
        switch (tdlib_type) {
            case "users":
                out_obj = (Users) jsoner.deserialize_object (typeof (Users));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes users from the contact list
     * @param user_ids Identifiers of users to be deleted
     */
    public async Ok remove_contacts (
        Gee.ArrayList<int64?> user_ids
    ) throws BadStatusCodeError {
        var obj = new RemoveContacts (
            user_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_contacts.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the total number of imported contacts
     */
    public async Count get_imported_contact_count () throws BadStatusCodeError {
        var obj = new GetImportedContactCount ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_imported_contact_count.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Count out_obj;
        switch (tdlib_type) {
            case "count":
                out_obj = (Count) jsoner.deserialize_object (typeof (Count));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes imported contacts using the list of contacts saved on the
     * device. Imports newly added contacts and, if at least the file
     * database is enabled, deletes recently deleted contacts.
     * Query result depends on the result of the previous query, so only one
     * query is possible at the same time
     * @param contacts The new list of contacts, contact's vCard are ignored
     * and are not imported
     */
    public async ImportedContacts change_imported_contacts (
        Gee.ArrayList<Contact?> contacts
    ) throws BadStatusCodeError {
        var obj = new ChangeImportedContacts (
            contacts
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (change_imported_contacts.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ImportedContacts out_obj;
        switch (tdlib_type) {
            case "importedContacts":
                out_obj = (ImportedContacts) jsoner.deserialize_object (typeof (ImportedContacts));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Clears all imported contacts, contact list remains unchanged
     */
    public async Ok clear_imported_contacts () throws BadStatusCodeError {
        var obj = new ClearImportedContacts ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clear_imported_contacts.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the list of close friends of the current user
     * @param user_ids User identifiers of close friends; the users must be
     * contacts of the current user
     */
    public async Ok set_close_friends (
        Gee.ArrayList<int64?> user_ids
    ) throws BadStatusCodeError {
        var obj = new SetCloseFriends (
            user_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_close_friends.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns all close friends of the current user
     */
    public async Users get_close_friends () throws BadStatusCodeError {
        var obj = new GetCloseFriends ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_close_friends.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Users out_obj;
        switch (tdlib_type) {
            case "users":
                out_obj = (Users) jsoner.deserialize_object (typeof (Users));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes a personal profile photo of a contact user
     * @param user_id User identifier
     * @param photo Profile photo to set; pass null to delete the photo;
     * inputChatPhotoPrevious isn't supported in this function
     */
    public async Ok set_user_personal_profile_photo (
        int64 user_id,
        InputChatPhoto photo
    ) throws BadStatusCodeError {
        var obj = new SetUserPersonalProfilePhoto (
            user_id,
            photo
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_user_personal_profile_photo.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Suggests a profile photo to another regular user with common messages
     * @param user_id User identifier
     * @param photo Profile photo to suggest; inputChatPhotoPrevious isn't
     * supported in this function
     */
    public async Ok suggest_user_profile_photo (
        int64 user_id,
        InputChatPhoto photo
    ) throws BadStatusCodeError {
        var obj = new SuggestUserProfilePhoto (
            user_id,
            photo
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (suggest_user_profile_photo.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether the bot can manage emoji status of the current user
     * @param bot_user_id User identifier of the bot
     * @param can_manage_emoji_status Pass true if the bot is allowed to
     * change emoji status of the user; pass false otherwise
     */
    public async Ok toggle_bot_can_manage_emoji_status (
        int64 bot_user_id,
        bool can_manage_emoji_status
    ) throws BadStatusCodeError {
        var obj = new ToggleBotCanManageEmojiStatus (
            bot_user_id,
            can_manage_emoji_status
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_bot_can_manage_emoji_status.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the emoji status of a user; for bots only
     * @param user_id Identifier of the user
     * @param emoji_status New emoji status; pass null to switch to the
     * default badge
     */
    public async Ok set_user_emoji_status (
        int64 user_id,
        EmojiStatus emoji_status
    ) throws BadStatusCodeError {
        var obj = new SetUserEmojiStatus (
            user_id,
            emoji_status
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_user_emoji_status.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches a user by their phone number. Returns a 404 error if the user
     * can't be found
     * @param phone_number Phone number to search for
     * @param only_local Pass true to get only locally available information
     * without sending network requests
     */
    public async User search_user_by_phone_number (
        string phone_number,
        bool only_local
    ) throws BadStatusCodeError {
        var obj = new SearchUserByPhoneNumber (
            phone_number,
            only_local
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_user_by_phone_number.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        User out_obj;
        switch (tdlib_type) {
            case "user":
                out_obj = (User) jsoner.deserialize_object (typeof (User));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Shares the phone number of the current user with a mutual contact.
     * Supposed to be called when the user clicks on
     * chatActionBarSharePhoneNumber
     * @param user_id Identifier of the user with whom to share the phone
     * number. The user must be a mutual contact
     */
    public async Ok share_phone_number (
        int64 user_id
    ) throws BadStatusCodeError {
        var obj = new SharePhoneNumber (
            user_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (share_phone_number.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the profile photos of a user. Personal and public photo aren't
     * returned
     * @param user_id User identifier
     * @param offset The number of photos to skip; must be non-negative
     * @param limit The maximum number of photos to be returned; up to 100
     */
    public async ChatPhotos get_user_profile_photos (
        int64 user_id,
        int32 offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetUserProfilePhotos (
            user_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_user_profile_photos.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatPhotos out_obj;
        switch (tdlib_type) {
            case "chatPhotos":
                out_obj = (ChatPhotos) jsoner.deserialize_object (typeof (ChatPhotos));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns outline of a sticker; this is an offline request. Returns a
     * 404 error if the outline isn't known
     * @param sticker_file_id File identifier of the sticker
     * @param for_animated_emoji Pass true to get the outline scaled for
     * animated emoji
     * @param for_clicked_animated_emoji_message Pass true to get the outline
     * scaled for clicked animated emoji message
     */
    public async Outline get_sticker_outline (
        int32 sticker_file_id,
        bool for_animated_emoji,
        bool for_clicked_animated_emoji_message
    ) throws BadStatusCodeError {
        var obj = new GetStickerOutline (
            sticker_file_id,
            for_animated_emoji,
            for_clicked_animated_emoji_message
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_sticker_outline.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Outline out_obj;
        switch (tdlib_type) {
            case "outline":
                out_obj = (Outline) jsoner.deserialize_object (typeof (Outline));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns stickers from the installed sticker sets that correspond to
     * any of the given emoji or can be found by sticker-specific keywords.
     * If the query is non-empty, then favorite, recently used or trending
     * stickers may also be returned
     * @param sticker_type Type of the stickers to return
     * @param query Search query; a space-separated list of emojis or a
     * keyword prefix. If empty, returns all known installed stickers
     * @param limit The maximum number of stickers to be returned
     * @param chat_id Chat identifier for which to return stickers. Available
     * custom emoji stickers may be different for different chats
     */
    public async Stickers get_stickers (
        StickerType sticker_type,
        string query,
        int32 limit,
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new GetStickers (
            sticker_type,
            query,
            limit,
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_stickers.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Stickers out_obj;
        switch (tdlib_type) {
            case "stickers":
                out_obj = (Stickers) jsoner.deserialize_object (typeof (Stickers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns unique emoji that correspond to stickers to be found by the
     * getStickers(sticker_type, query, 1000000, chat_id)
     * @param sticker_type Type of the stickers to search for
     * @param query Search query
     * @param chat_id Chat identifier for which to find stickers
     * @param return_only_main_emoji Pass true if only main emoji for each
     * found sticker must be included in the result
     */
    public async Emojis get_all_sticker_emojis (
        StickerType sticker_type,
        string query,
        int64 chat_id,
        bool return_only_main_emoji
    ) throws BadStatusCodeError {
        var obj = new GetAllStickerEmojis (
            sticker_type,
            query,
            chat_id,
            return_only_main_emoji
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_all_sticker_emojis.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Emojis out_obj;
        switch (tdlib_type) {
            case "emojis":
                out_obj = (Emojis) jsoner.deserialize_object (typeof (Emojis));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for stickers from public sticker sets that correspond to any
     * of the given emoji
     * @param sticker_type Type of the stickers to return
     * @param emojis Space-separated list of emojis to search for; must be
     * non-empty
     * @param limit The maximum number of stickers to be returned; 0-100
     */
    public async Stickers search_stickers (
        StickerType sticker_type,
        string emojis,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new SearchStickers (
            sticker_type,
            emojis,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_stickers.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Stickers out_obj;
        switch (tdlib_type) {
            case "stickers":
                out_obj = (Stickers) jsoner.deserialize_object (typeof (Stickers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns greeting stickers from regular sticker sets that can be used
     * for the start page of other users
     */
    public async Stickers get_greeting_stickers () throws BadStatusCodeError {
        var obj = new GetGreetingStickers ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_greeting_stickers.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Stickers out_obj;
        switch (tdlib_type) {
            case "stickers":
                out_obj = (Stickers) jsoner.deserialize_object (typeof (Stickers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns premium stickers from regular sticker sets
     * @param limit The maximum number of stickers to be returned; 0-100
     */
    public async Stickers get_premium_stickers (
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetPremiumStickers (
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_premium_stickers.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Stickers out_obj;
        switch (tdlib_type) {
            case "stickers":
                out_obj = (Stickers) jsoner.deserialize_object (typeof (Stickers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a list of installed sticker sets
     * @param sticker_type Type of the sticker sets to return
     */
    public async StickerSets get_installed_sticker_sets (
        StickerType sticker_type
    ) throws BadStatusCodeError {
        var obj = new GetInstalledStickerSets (
            sticker_type
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_installed_sticker_sets.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StickerSets out_obj;
        switch (tdlib_type) {
            case "stickerSets":
                out_obj = (StickerSets) jsoner.deserialize_object (typeof (StickerSets));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a list of archived sticker sets
     * @param sticker_type Type of the sticker sets to return
     * @param offset_sticker_set_id Identifier of the sticker set from which
     * to return the result; use 0 to get results from the beginning
     * @param limit The maximum number of sticker sets to return; up to 100
     */
    public async StickerSets get_archived_sticker_sets (
        StickerType sticker_type,
        int64 offset_sticker_set_id,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetArchivedStickerSets (
            sticker_type,
            offset_sticker_set_id,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_archived_sticker_sets.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StickerSets out_obj;
        switch (tdlib_type) {
            case "stickerSets":
                out_obj = (StickerSets) jsoner.deserialize_object (typeof (StickerSets));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a list of trending sticker sets. For optimal performance, the
     * number of returned sticker sets is chosen by TDLib
     * @param sticker_type Type of the sticker sets to return
     * @param offset The offset from which to return the sticker sets; must
     * be non-negative
     * @param limit The maximum number of sticker sets to be returned; up to
     * 100. For optimal performance, the number of returned sticker sets is
     * chosen by TDLib and can be smaller than the specified limit, even if
     * the end of the list has not been reached
     */
    public async TrendingStickerSets get_trending_sticker_sets (
        StickerType sticker_type,
        int32 offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetTrendingStickerSets (
            sticker_type,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_trending_sticker_sets.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        TrendingStickerSets out_obj;
        switch (tdlib_type) {
            case "trendingStickerSets":
                out_obj = (TrendingStickerSets) jsoner.deserialize_object (typeof (TrendingStickerSets));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a list of sticker sets attached to a file, including regular,
     * mask, and emoji sticker sets. Currently, only animations, photos, and
     * videos can have attached sticker sets
     * @param file_id File identifier
     */
    public async StickerSets get_attached_sticker_sets (
        int32 file_id
    ) throws BadStatusCodeError {
        var obj = new GetAttachedStickerSets (
            file_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_attached_sticker_sets.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StickerSets out_obj;
        switch (tdlib_type) {
            case "stickerSets":
                out_obj = (StickerSets) jsoner.deserialize_object (typeof (StickerSets));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a sticker set by its identifier
     * @param set_id Identifier of the sticker set
     */
    public async StickerSet get_sticker_set (
        int64 set_id
    ) throws BadStatusCodeError {
        var obj = new GetStickerSet (
            set_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_sticker_set.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StickerSet out_obj;
        switch (tdlib_type) {
            case "stickerSet":
                out_obj = (StickerSet) jsoner.deserialize_object (typeof (StickerSet));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns name of a sticker set by its identifier
     * @param set_id Identifier of the sticker set
     */
    public async Text get_sticker_set_name (
        int64 set_id
    ) throws BadStatusCodeError {
        var obj = new GetStickerSetName (
            set_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_sticker_set_name.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for a sticker set by its name
     * @param name Name of the sticker set
     * @param ignore_cache Pass true to ignore local cache of sticker sets
     * and always send a network request
     */
    public async StickerSet search_sticker_set (
        string name,
        bool ignore_cache
    ) throws BadStatusCodeError {
        var obj = new SearchStickerSet (
            name,
            ignore_cache
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_sticker_set.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StickerSet out_obj;
        switch (tdlib_type) {
            case "stickerSet":
                out_obj = (StickerSet) jsoner.deserialize_object (typeof (StickerSet));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for installed sticker sets by looking for specified query in
     * their title and name
     * @param sticker_type Type of the sticker sets to search for
     * @param query Query to search for
     * @param limit The maximum number of sticker sets to return
     */
    public async StickerSets search_installed_sticker_sets (
        StickerType sticker_type,
        string query,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new SearchInstalledStickerSets (
            sticker_type,
            query,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_installed_sticker_sets.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StickerSets out_obj;
        switch (tdlib_type) {
            case "stickerSets":
                out_obj = (StickerSets) jsoner.deserialize_object (typeof (StickerSets));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for sticker sets by looking for specified query in their
     * title and name. Excludes installed sticker sets from the results
     * @param sticker_type Type of the sticker sets to return
     * @param query Query to search for
     */
    public async StickerSets search_sticker_sets (
        StickerType sticker_type,
        string query
    ) throws BadStatusCodeError {
        var obj = new SearchStickerSets (
            sticker_type,
            query
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_sticker_sets.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StickerSets out_obj;
        switch (tdlib_type) {
            case "stickerSets":
                out_obj = (StickerSets) jsoner.deserialize_object (typeof (StickerSets));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Installs/uninstalls or activates/archives a sticker set
     * @param set_id Identifier of the sticker set
     * @param is_installed The new value of is_installed
     * @param is_archived The new value of is_archived. A sticker set can't
     * be installed and archived simultaneously
     */
    public async Ok change_sticker_set (
        int64 set_id,
        bool is_installed,
        bool is_archived
    ) throws BadStatusCodeError {
        var obj = new ChangeStickerSet (
            set_id,
            is_installed,
            is_archived
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (change_sticker_set.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs the server that some trending sticker sets have been viewed by
     * the user
     * @param sticker_set_ids Identifiers of viewed trending sticker sets
     */
    public async Ok view_trending_sticker_sets (
        Gee.ArrayList<int64?> sticker_set_ids
    ) throws BadStatusCodeError {
        var obj = new ViewTrendingStickerSets (
            sticker_set_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (view_trending_sticker_sets.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the order of installed sticker sets
     * @param sticker_type Type of the sticker sets to reorder
     * @param sticker_set_ids Identifiers of installed sticker sets in the
     * new correct order
     */
    public async Ok reorder_installed_sticker_sets (
        StickerType sticker_type,
        Gee.ArrayList<int64?> sticker_set_ids
    ) throws BadStatusCodeError {
        var obj = new ReorderInstalledStickerSets (
            sticker_type,
            sticker_set_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reorder_installed_sticker_sets.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a list of recently used stickers
     * @param is_attached Pass true to return stickers and masks that were
     * recently attached to photos or video files; pass false to return
     * recently sent stickers
     */
    public async Stickers get_recent_stickers (
        bool is_attached
    ) throws BadStatusCodeError {
        var obj = new GetRecentStickers (
            is_attached
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_recent_stickers.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Stickers out_obj;
        switch (tdlib_type) {
            case "stickers":
                out_obj = (Stickers) jsoner.deserialize_object (typeof (Stickers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Manually adds a new sticker to the list of recently used stickers. The
     * new sticker is added to the top of the list. If the sticker was
     * already in the list, it is removed from the list first.
     * Only stickers belonging to a sticker set or in WEBP or WEBM format can
     * be added to this list. Emoji stickers can't be added to recent
     * stickers
     * @param is_attached Pass true to add the sticker to the list of
     * stickers recently attached to photo or video files; pass false to add
     * the sticker to the list of recently sent stickers
     * @param sticker Sticker file to add
     */
    public async Stickers add_recent_sticker (
        bool is_attached,
        InputFile sticker
    ) throws BadStatusCodeError {
        var obj = new AddRecentSticker (
            is_attached,
            sticker
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_recent_sticker.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Stickers out_obj;
        switch (tdlib_type) {
            case "stickers":
                out_obj = (Stickers) jsoner.deserialize_object (typeof (Stickers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes a sticker from the list of recently used stickers
     * @param is_attached Pass true to remove the sticker from the list of
     * stickers recently attached to photo or video files; pass false to
     * remove the sticker from the list of recently sent stickers
     * @param sticker Sticker file to delete
     */
    public async Ok remove_recent_sticker (
        bool is_attached,
        InputFile sticker
    ) throws BadStatusCodeError {
        var obj = new RemoveRecentSticker (
            is_attached,
            sticker
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_recent_sticker.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Clears the list of recently used stickers
     * @param is_attached Pass true to clear the list of stickers recently
     * attached to photo or video files; pass false to clear the list of
     * recently sent stickers
     */
    public async Ok clear_recent_stickers (
        bool is_attached
    ) throws BadStatusCodeError {
        var obj = new ClearRecentStickers (
            is_attached
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clear_recent_stickers.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns favorite stickers
     */
    public async Stickers get_favorite_stickers () throws BadStatusCodeError {
        var obj = new GetFavoriteStickers ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_favorite_stickers.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Stickers out_obj;
        switch (tdlib_type) {
            case "stickers":
                out_obj = (Stickers) jsoner.deserialize_object (typeof (Stickers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a new sticker to the list of favorite stickers. The new sticker
     * is added to the top of the list. If the sticker was already in the
     * list, it is removed from the list first.
     * Only stickers belonging to a sticker set or in WEBP or WEBM format can
     * be added to this list. Emoji stickers can't be added to favorite
     * stickers
     * @param sticker Sticker file to add
     */
    public async Ok add_favorite_sticker (
        InputFile sticker
    ) throws BadStatusCodeError {
        var obj = new AddFavoriteSticker (
            sticker
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_favorite_sticker.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes a sticker from the list of favorite stickers
     * @param sticker Sticker file to delete from the list
     */
    public async Ok remove_favorite_sticker (
        InputFile sticker
    ) throws BadStatusCodeError {
        var obj = new RemoveFavoriteSticker (
            sticker
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_favorite_sticker.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns emoji corresponding to a sticker. The list is only for
     * informational purposes, because a sticker is always sent with a fixed
     * emoji from the corresponding Sticker object
     * @param sticker Sticker file identifier
     */
    public async Emojis get_sticker_emojis (
        InputFile sticker
    ) throws BadStatusCodeError {
        var obj = new GetStickerEmojis (
            sticker
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_sticker_emojis.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Emojis out_obj;
        switch (tdlib_type) {
            case "emojis":
                out_obj = (Emojis) jsoner.deserialize_object (typeof (Emojis));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for emojis by keywords. Supported only if the file database
     * is enabled. Order of results is unspecified
     * @param text Text to search for
     * @param input_language_codes List of possible IETF language tags of the
     * user's input language; may be empty if unknown
     */
    public async EmojiKeywords search_emojis (
        string text,
        Gee.ArrayList<string?> input_language_codes
    ) throws BadStatusCodeError {
        var obj = new SearchEmojis (
            text,
            input_language_codes
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_emojis.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        EmojiKeywords out_obj;
        switch (tdlib_type) {
            case "emojiKeywords":
                out_obj = (EmojiKeywords) jsoner.deserialize_object (typeof (EmojiKeywords));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Return emojis matching the keyword. Supported only if the file
     * database is enabled. Order of results is unspecified
     * @param text Text to search for
     * @param input_language_codes List of possible IETF language tags of the
     * user's input language; may be empty if unknown
     */
    public async Emojis get_keyword_emojis (
        string text,
        Gee.ArrayList<string?> input_language_codes
    ) throws BadStatusCodeError {
        var obj = new GetKeywordEmojis (
            text,
            input_language_codes
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_keyword_emojis.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Emojis out_obj;
        switch (tdlib_type) {
            case "emojis":
                out_obj = (Emojis) jsoner.deserialize_object (typeof (Emojis));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns available emoji categories
     * @param type_ Type of emoji categories to return; pass null to get
     * default emoji categories
     */
    public async EmojiCategories get_emoji_categories (
        EmojiCategoryType type_
    ) throws BadStatusCodeError {
        var obj = new GetEmojiCategories (
            type_
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_emoji_categories.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        EmojiCategories out_obj;
        switch (tdlib_type) {
            case "emojiCategories":
                out_obj = (EmojiCategories) jsoner.deserialize_object (typeof (EmojiCategories));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an animated emoji corresponding to a given emoji. Returns a
     * 404 error if the emoji has no animated emoji
     * @param emoji The emoji
     */
    public async AnimatedEmoji get_animated_emoji (
        string emoji
    ) throws BadStatusCodeError {
        var obj = new GetAnimatedEmoji (
            emoji
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_animated_emoji.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        AnimatedEmoji out_obj;
        switch (tdlib_type) {
            case "animatedEmoji":
                out_obj = (AnimatedEmoji) jsoner.deserialize_object (typeof (AnimatedEmoji));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an HTTP URL which can be used to automatically log in to the
     * translation platform and suggest new emoji replacements. The URL will
     * be valid for 30 seconds after generation
     * @param language_code Language code for which the emoji replacements
     * will be suggested
     */
    public async HttpUrl get_emoji_suggestions_url (
        string language_code
    ) throws BadStatusCodeError {
        var obj = new GetEmojiSuggestionsUrl (
            language_code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_emoji_suggestions_url.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        HttpUrl out_obj;
        switch (tdlib_type) {
            case "httpUrl":
                out_obj = (HttpUrl) jsoner.deserialize_object (typeof (HttpUrl));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of custom emoji stickers by their identifiers.
     * Stickers are returned in arbitrary order. Only found stickers are
     * returned
     * @param custom_emoji_ids Identifiers of custom emoji stickers. At most
     * 200 custom emoji stickers can be received simultaneously
     */
    public async Stickers get_custom_emoji_stickers (
        Gee.ArrayList<int64?> custom_emoji_ids
    ) throws BadStatusCodeError {
        var obj = new GetCustomEmojiStickers (
            custom_emoji_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_custom_emoji_stickers.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Stickers out_obj;
        switch (tdlib_type) {
            case "stickers":
                out_obj = (Stickers) jsoner.deserialize_object (typeof (Stickers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns default list of custom emoji stickers for placing on a chat
     * photo
     */
    public async Stickers get_default_chat_photo_custom_emoji_stickers () throws BadStatusCodeError {
        var obj = new GetDefaultChatPhotoCustomEmojiStickers ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_default_chat_photo_custom_emoji_stickers.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Stickers out_obj;
        switch (tdlib_type) {
            case "stickers":
                out_obj = (Stickers) jsoner.deserialize_object (typeof (Stickers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns default list of custom emoji stickers for placing on a profile
     * photo
     */
    public async Stickers get_default_profile_photo_custom_emoji_stickers () throws BadStatusCodeError {
        var obj = new GetDefaultProfilePhotoCustomEmojiStickers ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_default_profile_photo_custom_emoji_stickers.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Stickers out_obj;
        switch (tdlib_type) {
            case "stickers":
                out_obj = (Stickers) jsoner.deserialize_object (typeof (Stickers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns default list of custom emoji stickers for reply background
     */
    public async Stickers get_default_background_custom_emoji_stickers () throws BadStatusCodeError {
        var obj = new GetDefaultBackgroundCustomEmojiStickers ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_default_background_custom_emoji_stickers.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Stickers out_obj;
        switch (tdlib_type) {
            case "stickers":
                out_obj = (Stickers) jsoner.deserialize_object (typeof (Stickers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns saved animations
     */
    public async Animations get_saved_animations () throws BadStatusCodeError {
        var obj = new GetSavedAnimations ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_saved_animations.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Animations out_obj;
        switch (tdlib_type) {
            case "animations":
                out_obj = (Animations) jsoner.deserialize_object (typeof (Animations));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Manually adds a new animation to the list of saved animations. The new
     * animation is added to the beginning of the list. If the animation was
     * already in the list, it is removed first.
     * Only non-secret video animations with MIME type "video/mp4" can be
     * added to the list
     * @param animation The animation file to be added. Only animations known
     * to the server (i.e., successfully sent via a message) can be added to
     * the list
     */
    public async Ok add_saved_animation (
        InputFile animation
    ) throws BadStatusCodeError {
        var obj = new AddSavedAnimation (
            animation
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_saved_animation.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes an animation from the list of saved animations
     * @param animation Animation file to be removed
     */
    public async Ok remove_saved_animation (
        InputFile animation
    ) throws BadStatusCodeError {
        var obj = new RemoveSavedAnimation (
            animation
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_saved_animation.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns up to 20 recently used inline bots in the order of their last
     * usage
     */
    public async Users get_recent_inline_bots () throws BadStatusCodeError {
        var obj = new GetRecentInlineBots ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_recent_inline_bots.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Users out_obj;
        switch (tdlib_type) {
            case "users":
                out_obj = (Users) jsoner.deserialize_object (typeof (Users));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for recently used hashtags by their prefix
     * @param prefix Hashtag prefix to search for
     * @param limit The maximum number of hashtags to be returned
     */
    public async Hashtags search_hashtags (
        string prefix,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new SearchHashtags (
            prefix,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_hashtags.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Hashtags out_obj;
        switch (tdlib_type) {
            case "hashtags":
                out_obj = (Hashtags) jsoner.deserialize_object (typeof (Hashtags));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes a hashtag from the list of recently used hashtags
     * @param hashtag Hashtag to delete
     */
    public async Ok remove_recent_hashtag (
        string hashtag
    ) throws BadStatusCodeError {
        var obj = new RemoveRecentHashtag (
            hashtag
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_recent_hashtag.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a link preview by the text of a message. Do not call this
     * function too often. Returns a 404 error if the text has no link
     * preview
     * @param text Message text with formatting
     * @param link_preview_options Options to be used for generation of the
     * link preview; pass null to use default link preview options
     */
    public async LinkPreview get_link_preview (
        FormattedText text,
        LinkPreviewOptions link_preview_options
    ) throws BadStatusCodeError {
        var obj = new GetLinkPreview (
            text,
            link_preview_options
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_link_preview.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        LinkPreview out_obj;
        switch (tdlib_type) {
            case "linkPreview":
                out_obj = (LinkPreview) jsoner.deserialize_object (typeof (LinkPreview));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an instant view version of a web page if available. Returns a
     * 404 error if the web page has no instant view page
     * @param url The web page URL
     * @param force_full Pass true to get full instant view for the web page
     */
    public async WebPageInstantView get_web_page_instant_view (
        string url,
        bool force_full
    ) throws BadStatusCodeError {
        var obj = new GetWebPageInstantView (
            url,
            force_full
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_web_page_instant_view.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        WebPageInstantView out_obj;
        switch (tdlib_type) {
            case "webPageInstantView":
                out_obj = (WebPageInstantView) jsoner.deserialize_object (typeof (WebPageInstantView));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes a profile photo for the current user
     * @param photo Profile photo to set
     * @param is_public Pass true to set a public photo, which will be
     * visible even the main photo is hidden by privacy settings
     */
    public async Ok set_profile_photo (
        InputChatPhoto photo,
        bool is_public
    ) throws BadStatusCodeError {
        var obj = new SetProfilePhoto (
            photo,
            is_public
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_profile_photo.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes a profile photo
     * @param profile_photo_id Identifier of the profile photo to delete
     */
    public async Ok delete_profile_photo (
        int64 profile_photo_id
    ) throws BadStatusCodeError {
        var obj = new DeleteProfilePhoto (
            profile_photo_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_profile_photo.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes accent color and background custom emoji for the current user;
     * for Telegram Premium users only
     * @param accent_color_id Identifier of the accent color to use
     * @param background_custom_emoji_id Identifier of a custom emoji to be
     * shown on the reply header and link preview background; 0 if none
     */
    public async Ok set_accent_color (
        int32 accent_color_id,
        int64 background_custom_emoji_id
    ) throws BadStatusCodeError {
        var obj = new SetAccentColor (
            accent_color_id,
            background_custom_emoji_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_accent_color.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes accent color and background custom emoji for profile of the
     * current user; for Telegram Premium users only
     * @param profile_accent_color_id Identifier of the accent color to use
     * for profile; pass -1 if none
     * @param profile_background_custom_emoji_id Identifier of a custom emoji
     * to be shown on the user's profile photo background; 0 if none
     */
    public async Ok set_profile_accent_color (
        int32 profile_accent_color_id,
        int64 profile_background_custom_emoji_id
    ) throws BadStatusCodeError {
        var obj = new SetProfileAccentColor (
            profile_accent_color_id,
            profile_background_custom_emoji_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_profile_accent_color.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the first and last name of the current user
     * @param first_name The new value of the first name for the current
     * user; 1-64 characters
     * @param last_name The new value of the optional last name for the
     * current user; 0-64 characters
     */
    public async Ok set_name (
        string first_name,
        string last_name
    ) throws BadStatusCodeError {
        var obj = new SetName (
            first_name,
            last_name
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_name.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the bio of the current user
     * @param bio The new value of the user bio;
     * 0-getOption("bio_length_max") characters without line feeds
     */
    public async Ok set_bio (
        string bio
    ) throws BadStatusCodeError {
        var obj = new SetBio (
            bio
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_bio.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the editable username of the current user
     * @param username The new value of the username. Use an empty string to
     * remove the username. The username can't be completely removed if there
     * is another active or disabled username
     */
    public async Ok set_username (
        string username
    ) throws BadStatusCodeError {
        var obj = new SetUsername (
            username
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_username.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes active state for a username of the current user. The editable
     * username can't be disabled. May return an error with a message
     * "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames
     * has been reached
     * @param username The username to change
     * @param is_active Pass true to activate the username; pass false to
     * disable it
     */
    public async Ok toggle_username_is_active (
        string username,
        bool is_active
    ) throws BadStatusCodeError {
        var obj = new ToggleUsernameIsActive (
            username,
            is_active
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_username_is_active.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes order of active usernames of the current user
     * @param usernames The new order of active usernames. All currently
     * active usernames must be specified
     */
    public async Ok reorder_active_usernames (
        Gee.ArrayList<string?> usernames
    ) throws BadStatusCodeError {
        var obj = new ReorderActiveUsernames (
            usernames
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reorder_active_usernames.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the birthdate of the current user
     * @param birthdate The new value of the current user's birthdate; pass
     * null to remove the birthdate
     */
    public async Ok set_birthdate (
        Birthdate birthdate
    ) throws BadStatusCodeError {
        var obj = new SetBirthdate (
            birthdate
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_birthdate.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the personal chat of the current user
     * @param chat_id Identifier of the new personal chat; pass 0 to remove
     * the chat. Use getSuitablePersonalChats to get suitable chats
     */
    public async Ok set_personal_chat (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new SetPersonalChat (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_personal_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the emoji status of the current user; for Telegram Premium
     * users only
     * @param emoji_status New emoji status; pass null to switch to the
     * default badge
     */
    public async Ok set_emoji_status (
        EmojiStatus emoji_status
    ) throws BadStatusCodeError {
        var obj = new SetEmojiStatus (
            emoji_status
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_emoji_status.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether the current user has sponsored messages enabled. The
     * setting has no effect for users without Telegram Premium for which
     * sponsored messages are always enabled
     * @param has_sponsored_messages_enabled Pass true to enable sponsored
     * messages for the current user; false to disable them
     */
    public async Ok toggle_has_sponsored_messages_enabled (
        bool has_sponsored_messages_enabled
    ) throws BadStatusCodeError {
        var obj = new ToggleHasSponsoredMessagesEnabled (
            has_sponsored_messages_enabled
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_has_sponsored_messages_enabled.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the business location of the current user. Requires Telegram
     * Business subscription
     * @param location The new location of the business; pass null to remove
     * the location
     */
    public async Ok set_business_location (
        BusinessLocation location
    ) throws BadStatusCodeError {
        var obj = new SetBusinessLocation (
            location
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_business_location.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the business opening hours of the current user. Requires
     * Telegram Business subscription
     * @param opening_hours The new opening hours of the business; pass null
     * to remove the opening hours; up to 28 time intervals can be specified
     */
    public async Ok set_business_opening_hours (
        BusinessOpeningHours opening_hours
    ) throws BadStatusCodeError {
        var obj = new SetBusinessOpeningHours (
            opening_hours
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_business_opening_hours.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the business greeting message settings of the current user.
     * Requires Telegram Business subscription
     * @param greeting_message_settings The new settings for the greeting
     * message of the business; pass null to disable the greeting message
     */
    public async Ok set_business_greeting_message_settings (
        BusinessGreetingMessageSettings greeting_message_settings
    ) throws BadStatusCodeError {
        var obj = new SetBusinessGreetingMessageSettings (
            greeting_message_settings
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_business_greeting_message_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the business away message settings of the current user.
     * Requires Telegram Business subscription
     * @param away_message_settings The new settings for the away message of
     * the business; pass null to disable the away message
     */
    public async Ok set_business_away_message_settings (
        BusinessAwayMessageSettings away_message_settings
    ) throws BadStatusCodeError {
        var obj = new SetBusinessAwayMessageSettings (
            away_message_settings
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_business_away_message_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the business start page of the current user. Requires Telegram
     * Business subscription
     * @param start_page The new start page of the business; pass null to
     * remove custom start page
     */
    public async Ok set_business_start_page (
        InputBusinessStartPage start_page
    ) throws BadStatusCodeError {
        var obj = new SetBusinessStartPage (
            start_page
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_business_start_page.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends a code to the specified phone number. Aborts previous phone
     * number verification if there was one. On success, returns information
     * about the sent code
     * @param phone_number The phone number, in international format
     * @param settings Settings for the authentication of the user's phone
     * number; pass null to use default settings
     * @param type_ Type of the request for which the code is sent
     */
    public async AuthenticationCodeInfo send_phone_number_code (
        string phone_number,
        PhoneNumberAuthenticationSettings settings,
        PhoneNumberCodeType type_
    ) throws BadStatusCodeError {
        var obj = new SendPhoneNumberCode (
            phone_number,
            settings,
            type_
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_phone_number_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        AuthenticationCodeInfo out_obj;
        switch (tdlib_type) {
            case "authenticationCodeInfo":
                out_obj = (AuthenticationCodeInfo) jsoner.deserialize_object (typeof (AuthenticationCodeInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends Firebase Authentication SMS to the specified phone number. Works
     * only when received a code of the type
     * authenticationCodeTypeFirebaseAndroid or
     * authenticationCodeTypeFirebaseIos
     * @param token Play Integrity API or SafetyNet Attestation API token for
     * the Android application, or secret from push notification for the iOS
     * application
     */
    public async Ok send_phone_number_firebase_sms (
        string token
    ) throws BadStatusCodeError {
        var obj = new SendPhoneNumberFirebaseSms (
            token
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_phone_number_firebase_sms.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Reports that authentication code wasn't delivered via SMS to the
     * specified phone number; for official mobile applications only
     * @param mobile_network_code Current mobile network code
     */
    public async Ok report_phone_number_code_missing (
        string mobile_network_code
    ) throws BadStatusCodeError {
        var obj = new ReportPhoneNumberCodeMissing (
            mobile_network_code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_phone_number_code_missing.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Resends the authentication code sent to a phone number. Works only if
     * the previously received authenticationCodeInfo next_code_type was not
     * null and the server-specified timeout has passed
     * @param reason Reason of code resending; pass null if unknown
     */
    public async AuthenticationCodeInfo resend_phone_number_code (
        ResendCodeReason reason
    ) throws BadStatusCodeError {
        var obj = new ResendPhoneNumberCode (
            reason
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (resend_phone_number_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        AuthenticationCodeInfo out_obj;
        switch (tdlib_type) {
            case "authenticationCodeInfo":
                out_obj = (AuthenticationCodeInfo) jsoner.deserialize_object (typeof (AuthenticationCodeInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Check the authentication code and completes the request for which the
     * code was sent if appropriate
     * @param code Authentication code to check
     */
    public async Ok check_phone_number_code (
        string code
    ) throws BadStatusCodeError {
        var obj = new CheckPhoneNumberCode (
            code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_phone_number_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the business bot that is connected to the current user
     * account. Returns a 404 error if there is no connected bot
     */
    public async BusinessConnectedBot get_business_connected_bot () throws BadStatusCodeError {
        var obj = new GetBusinessConnectedBot ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_business_connected_bot.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BusinessConnectedBot out_obj;
        switch (tdlib_type) {
            case "businessConnectedBot":
                out_obj = (BusinessConnectedBot) jsoner.deserialize_object (typeof (BusinessConnectedBot));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds or changes business bot that is connected to the current user
     * account
     * @param bot Connection settings for the bot
     */
    public async Ok set_business_connected_bot (
        BusinessConnectedBot bot
    ) throws BadStatusCodeError {
        var obj = new SetBusinessConnectedBot (
            bot
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_business_connected_bot.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes the business bot that is connected to the current user account
     * @param bot_user_id Unique user identifier for the bot
     */
    public async Ok delete_business_connected_bot (
        int64 bot_user_id
    ) throws BadStatusCodeError {
        var obj = new DeleteBusinessConnectedBot (
            bot_user_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_business_connected_bot.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Pauses or resumes the connected business bot in a specific chat
     * @param chat_id Chat identifier
     * @param is_paused Pass true to pause the connected bot in the chat;
     * pass false to resume the bot
     */
    public async Ok toggle_business_connected_bot_chat_is_paused (
        int64 chat_id,
        bool is_paused
    ) throws BadStatusCodeError {
        var obj = new ToggleBusinessConnectedBotChatIsPaused (
            chat_id,
            is_paused
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_business_connected_bot_chat_is_paused.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes the connected business bot from a specific chat by adding the
     * chat to businessRecipients.excluded_chat_ids
     * @param chat_id Chat identifier
     */
    public async Ok remove_business_connected_bot_from_chat (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new RemoveBusinessConnectedBotFromChat (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_business_connected_bot_from_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns business chat links created for the current account
     */
    public async BusinessChatLinks get_business_chat_links () throws BadStatusCodeError {
        var obj = new GetBusinessChatLinks ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_business_chat_links.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BusinessChatLinks out_obj;
        switch (tdlib_type) {
            case "businessChatLinks":
                out_obj = (BusinessChatLinks) jsoner.deserialize_object (typeof (BusinessChatLinks));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Creates a business chat link for the current account. Requires
     * Telegram Business subscription. There can be up to
     * getOption("business_chat_link_count_max") links created. Returns the
     * created link
     * @param link_info Information about the link to create
     */
    public async BusinessChatLink create_business_chat_link (
        InputBusinessChatLink link_info
    ) throws BadStatusCodeError {
        var obj = new CreateBusinessChatLink (
            link_info
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_business_chat_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BusinessChatLink out_obj;
        switch (tdlib_type) {
            case "businessChatLink":
                out_obj = (BusinessChatLink) jsoner.deserialize_object (typeof (BusinessChatLink));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits a business chat link of the current account. Requires Telegram
     * Business subscription. Returns the edited link
     * @param link The link to edit
     * @param link_info New description of the link
     */
    public async BusinessChatLink edit_business_chat_link (
        string link,
        InputBusinessChatLink link_info
    ) throws BadStatusCodeError {
        var obj = new EditBusinessChatLink (
            link,
            link_info
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_business_chat_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BusinessChatLink out_obj;
        switch (tdlib_type) {
            case "businessChatLink":
                out_obj = (BusinessChatLink) jsoner.deserialize_object (typeof (BusinessChatLink));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes a business chat link of the current account
     * @param link The link to delete
     */
    public async Ok delete_business_chat_link (
        string link
    ) throws BadStatusCodeError {
        var obj = new DeleteBusinessChatLink (
            link
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_business_chat_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a business chat link
     * @param link_name Name of the link
     */
    public async BusinessChatLinkInfo get_business_chat_link_info (
        string link_name
    ) throws BadStatusCodeError {
        var obj = new GetBusinessChatLinkInfo (
            link_name
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_business_chat_link_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BusinessChatLinkInfo out_obj;
        switch (tdlib_type) {
            case "businessChatLinkInfo":
                out_obj = (BusinessChatLinkInfo) jsoner.deserialize_object (typeof (BusinessChatLinkInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an HTTPS link, which can be used to get information about the
     * current user
     */
    public async UserLink get_user_link () throws BadStatusCodeError {
        var obj = new GetUserLink ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_user_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        UserLink out_obj;
        switch (tdlib_type) {
            case "userLink":
                out_obj = (UserLink) jsoner.deserialize_object (typeof (UserLink));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches a user by a token from the user's link
     * @param token Token to search for
     */
    public async User search_user_by_token (
        string token
    ) throws BadStatusCodeError {
        var obj = new SearchUserByToken (
            token
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_user_by_token.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        User out_obj;
        switch (tdlib_type) {
            case "user":
                out_obj = (User) jsoner.deserialize_object (typeof (User));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the list of commands supported by the bot for the given user
     * scope and language; for bots only
     * @param scope The scope to which the commands are relevant; pass null
     * to change commands in the default bot command scope
     * @param language_code A two-letter ISO 639-1 language code. If empty,
     * the commands will be applied to all users from the given scope, for
     * which language there are no dedicated commands
     * @param commands List of the bot's commands
     */
    public async Ok set_commands (
        BotCommandScope scope,
        string language_code,
        Gee.ArrayList<BotCommand?> commands
    ) throws BadStatusCodeError {
        var obj = new SetCommands (
            scope,
            language_code,
            commands
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_commands.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes commands supported by the bot for the given user scope and
     * language; for bots only
     * @param scope The scope to which the commands are relevant; pass null
     * to delete commands in the default bot command scope
     * @param language_code A two-letter ISO 639-1 language code or an empty
     * string
     */
    public async Ok delete_commands (
        BotCommandScope scope,
        string language_code
    ) throws BadStatusCodeError {
        var obj = new DeleteCommands (
            scope,
            language_code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_commands.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of commands supported by the bot for the given user
     * scope and language; for bots only
     * @param scope The scope to which the commands are relevant; pass null
     * to get commands in the default bot command scope
     * @param language_code A two-letter ISO 639-1 language code or an empty
     * string
     */
    public async BotCommands get_commands (
        BotCommandScope scope,
        string language_code
    ) throws BadStatusCodeError {
        var obj = new GetCommands (
            scope,
            language_code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_commands.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BotCommands out_obj;
        switch (tdlib_type) {
            case "botCommands":
                out_obj = (BotCommands) jsoner.deserialize_object (typeof (BotCommands));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets menu button for the given user or for all users; for bots only
     * @param user_id Identifier of the user or 0 to set menu button for all
     * users
     * @param menu_button New menu button
     */
    public async Ok set_menu_button (
        int64 user_id,
        BotMenuButton menu_button
    ) throws BadStatusCodeError {
        var obj = new SetMenuButton (
            user_id,
            menu_button
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_menu_button.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns menu button set by the bot for the given user; for bots only
     * @param user_id Identifier of the user or 0 to get the default menu
     * button
     */
    public async BotMenuButton get_menu_button (
        int64 user_id
    ) throws BadStatusCodeError {
        var obj = new GetMenuButton (
            user_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_menu_button.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BotMenuButton out_obj;
        switch (tdlib_type) {
            case "botMenuButton":
                out_obj = (BotMenuButton) jsoner.deserialize_object (typeof (BotMenuButton));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets default administrator rights for adding the bot to basic group
     * and supergroup chats; for bots only
     * @param default_group_administrator_rights Default administrator rights
     * for adding the bot to basic group and supergroup chats; pass null to
     * remove default rights
     */
    public async Ok set_default_group_administrator_rights (
        ChatAdministratorRights default_group_administrator_rights
    ) throws BadStatusCodeError {
        var obj = new SetDefaultGroupAdministratorRights (
            default_group_administrator_rights
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_default_group_administrator_rights.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets default administrator rights for adding the bot to channel chats;
     * for bots only
     * @param default_channel_administrator_rights Default administrator
     * rights for adding the bot to channels; pass null to remove default
     * rights
     */
    public async Ok set_default_channel_administrator_rights (
        ChatAdministratorRights default_channel_administrator_rights
    ) throws BadStatusCodeError {
        var obj = new SetDefaultChannelAdministratorRights (
            default_channel_administrator_rights
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_default_channel_administrator_rights.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks whether the specified bot can send messages to the user.
     * Returns a 404 error if can't and the access can be granted by call to
     * allowBotToSendMessages
     * @param bot_user_id Identifier of the target bot
     */
    public async Ok can_bot_send_messages (
        int64 bot_user_id
    ) throws BadStatusCodeError {
        var obj = new CanBotSendMessages (
            bot_user_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (can_bot_send_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Allows the specified bot to send messages to the user
     * @param bot_user_id Identifier of the target bot
     */
    public async Ok allow_bot_to_send_messages (
        int64 bot_user_id
    ) throws BadStatusCodeError {
        var obj = new AllowBotToSendMessages (
            bot_user_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (allow_bot_to_send_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends a custom request from a Web App
     * @param bot_user_id Identifier of the bot
     * @param method The method name
     * @param parameters JSON-serialized method parameters
     */
    public async CustomRequestResult send_web_app_custom_request (
        int64 bot_user_id,
        string method,
        string parameters
    ) throws BadStatusCodeError {
        var obj = new SendWebAppCustomRequest (
            bot_user_id,
            method,
            parameters
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_web_app_custom_request.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        CustomRequestResult out_obj;
        switch (tdlib_type) {
            case "customRequestResult":
                out_obj = (CustomRequestResult) jsoner.deserialize_object (typeof (CustomRequestResult));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of media previews of a bot
     * @param bot_user_id Identifier of the target bot. The bot must have the
     * main Web App
     */
    public async BotMediaPreviews get_bot_media_previews (
        int64 bot_user_id
    ) throws BadStatusCodeError {
        var obj = new GetBotMediaPreviews (
            bot_user_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_bot_media_previews.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BotMediaPreviews out_obj;
        switch (tdlib_type) {
            case "botMediaPreviews":
                out_obj = (BotMediaPreviews) jsoner.deserialize_object (typeof (BotMediaPreviews));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of media previews for the given language and the list
     * of languages for which the bot has dedicated previews
     * @param bot_user_id Identifier of the target bot. The bot must be owned
     * and must have the main Web App
     * @param language_code A two-letter ISO 639-1 language code for which to
     * get previews. If empty, then default previews are returned
     */
    public async BotMediaPreviewInfo get_bot_media_preview_info (
        int64 bot_user_id,
        string language_code
    ) throws BadStatusCodeError {
        var obj = new GetBotMediaPreviewInfo (
            bot_user_id,
            language_code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_bot_media_preview_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BotMediaPreviewInfo out_obj;
        switch (tdlib_type) {
            case "botMediaPreviewInfo":
                out_obj = (BotMediaPreviewInfo) jsoner.deserialize_object (typeof (BotMediaPreviewInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a new media preview to the beginning of the list of media
     * previews of a bot. Returns the added preview after addition is
     * completed server-side. The total number of previews must not exceed
     * getOption("bot_media_preview_count_max") for the given language
     * @param bot_user_id Identifier of the target bot. The bot must be owned
     * and must have the main Web App
     * @param language_code A two-letter ISO 639-1 language code for which
     * preview is added. If empty, then the preview will be shown to all
     * users for whose languages there are no dedicated previews. If
     * non-empty, then there must be an official language pack of the same
     * name, which is returned by getLocalizationTargetInfo
     * @param content Content of the added preview
     */
    public async BotMediaPreview add_bot_media_preview (
        int64 bot_user_id,
        string language_code,
        InputStoryContent content
    ) throws BadStatusCodeError {
        var obj = new AddBotMediaPreview (
            bot_user_id,
            language_code,
            content
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_bot_media_preview.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BotMediaPreview out_obj;
        switch (tdlib_type) {
            case "botMediaPreview":
                out_obj = (BotMediaPreview) jsoner.deserialize_object (typeof (BotMediaPreview));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Replaces media preview in the list of media previews of a bot. Returns
     * the new preview after edit is completed server-side
     * @param bot_user_id Identifier of the target bot. The bot must be owned
     * and must have the main Web App
     * @param language_code Language code of the media preview to edit
     * @param file_id File identifier of the media to replace
     * @param content Content of the new preview
     */
    public async BotMediaPreview edit_bot_media_preview (
        int64 bot_user_id,
        string language_code,
        int32 file_id,
        InputStoryContent content
    ) throws BadStatusCodeError {
        var obj = new EditBotMediaPreview (
            bot_user_id,
            language_code,
            file_id,
            content
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_bot_media_preview.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BotMediaPreview out_obj;
        switch (tdlib_type) {
            case "botMediaPreview":
                out_obj = (BotMediaPreview) jsoner.deserialize_object (typeof (BotMediaPreview));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes order of media previews in the list of media previews of a bot
     * @param bot_user_id Identifier of the target bot. The bot must be owned
     * and must have the main Web App
     * @param language_code Language code of the media previews to reorder
     * @param file_ids File identifiers of the media in the new order
     */
    public async Ok reorder_bot_media_previews (
        int64 bot_user_id,
        string language_code,
        Gee.ArrayList<int32?> file_ids
    ) throws BadStatusCodeError {
        var obj = new ReorderBotMediaPreviews (
            bot_user_id,
            language_code,
            file_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reorder_bot_media_previews.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Delete media previews from the list of media previews of a bot
     * @param bot_user_id Identifier of the target bot. The bot must be owned
     * and must have the main Web App
     * @param language_code Language code of the media previews to delete
     * @param file_ids File identifiers of the media to delete
     */
    public async Ok delete_bot_media_previews (
        int64 bot_user_id,
        string language_code,
        Gee.ArrayList<int32?> file_ids
    ) throws BadStatusCodeError {
        var obj = new DeleteBotMediaPreviews (
            bot_user_id,
            language_code,
            file_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_bot_media_previews.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the name of a bot. Can be called only if
     * userTypeBot.can_be_edited == true
     * @param bot_user_id Identifier of the target bot
     * @param language_code A two-letter ISO 639-1 language code. If empty,
     * the name will be shown to all users for whose languages there is no
     * dedicated name
     * @param name New bot's name on the specified language; 0-64 characters;
     * must be non-empty if language code is empty
     */
    public async Ok set_bot_name (
        int64 bot_user_id,
        string language_code,
        string name
    ) throws BadStatusCodeError {
        var obj = new SetBotName (
            bot_user_id,
            language_code,
            name
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_bot_name.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the name of a bot in the given language. Can be called only if
     * userTypeBot.can_be_edited == true
     * @param bot_user_id Identifier of the target bot
     * @param language_code A two-letter ISO 639-1 language code or an empty
     * string
     */
    public async Text get_bot_name (
        int64 bot_user_id,
        string language_code
    ) throws BadStatusCodeError {
        var obj = new GetBotName (
            bot_user_id,
            language_code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_bot_name.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes a profile photo for a bot
     * @param bot_user_id Identifier of the target bot
     * @param photo Profile photo to set; pass null to delete the chat photo
     */
    public async Ok set_bot_profile_photo (
        int64 bot_user_id,
        InputChatPhoto photo
    ) throws BadStatusCodeError {
        var obj = new SetBotProfilePhoto (
            bot_user_id,
            photo
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_bot_profile_photo.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes active state for a username of a bot. The editable username
     * can't be disabled. May return an error with a message
     * "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames
     * has been reached. Can be called only if userTypeBot.can_be_edited ==
     * true
     * @param bot_user_id Identifier of the target bot
     * @param username The username to change
     * @param is_active Pass true to activate the username; pass false to
     * disable it
     */
    public async Ok toggle_bot_username_is_active (
        int64 bot_user_id,
        string username,
        bool is_active
    ) throws BadStatusCodeError {
        var obj = new ToggleBotUsernameIsActive (
            bot_user_id,
            username,
            is_active
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_bot_username_is_active.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes order of active usernames of a bot. Can be called only if
     * userTypeBot.can_be_edited == true
     * @param bot_user_id Identifier of the target bot
     * @param usernames The new order of active usernames. All currently
     * active usernames must be specified
     */
    public async Ok reorder_bot_active_usernames (
        int64 bot_user_id,
        Gee.ArrayList<string?> usernames
    ) throws BadStatusCodeError {
        var obj = new ReorderBotActiveUsernames (
            bot_user_id,
            usernames
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reorder_bot_active_usernames.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the text shown in the chat with a bot if the chat is empty. Can
     * be called only if userTypeBot.can_be_edited == true
     * @param bot_user_id Identifier of the target bot
     * @param language_code A two-letter ISO 639-1 language code. If empty,
     * the description will be shown to all users for whose languages there
     * is no dedicated description
     * @param description New bot's description on the specified language
     */
    public async Ok set_bot_info_description (
        int64 bot_user_id,
        string language_code,
        string description
    ) throws BadStatusCodeError {
        var obj = new SetBotInfoDescription (
            bot_user_id,
            language_code,
            description
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_bot_info_description.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the text shown in the chat with a bot if the chat is empty in
     * the given language. Can be called only if userTypeBot.can_be_edited ==
     * true
     * @param bot_user_id Identifier of the target bot
     * @param language_code A two-letter ISO 639-1 language code or an empty
     * string
     */
    public async Text get_bot_info_description (
        int64 bot_user_id,
        string language_code
    ) throws BadStatusCodeError {
        var obj = new GetBotInfoDescription (
            bot_user_id,
            language_code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_bot_info_description.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the text shown on a bot's profile page and sent together with the
     * link when users share the bot. Can be called only if
     * userTypeBot.can_be_edited == true
     * @param bot_user_id Identifier of the target bot
     * @param language_code A two-letter ISO 639-1 language code. If empty,
     * the short description will be shown to all users for whose languages
     * there is no dedicated description
     * @param short_description New bot's short description on the specified
     * language
     */
    public async Ok set_bot_info_short_description (
        int64 bot_user_id,
        string language_code,
        string short_description
    ) throws BadStatusCodeError {
        var obj = new SetBotInfoShortDescription (
            bot_user_id,
            language_code,
            short_description
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_bot_info_short_description.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the text shown on a bot's profile page and sent together with
     * the link when users share the bot in the given language. Can be called
     * only if userTypeBot.can_be_edited == true
     * @param bot_user_id Identifier of the target bot
     * @param language_code A two-letter ISO 639-1 language code or an empty
     * string
     */
    public async Text get_bot_info_short_description (
        int64 bot_user_id,
        string language_code
    ) throws BadStatusCodeError {
        var obj = new GetBotInfoShortDescription (
            bot_user_id,
            language_code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_bot_info_short_description.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns all active sessions of the current user
     */
    public async Sessions get_active_sessions () throws BadStatusCodeError {
        var obj = new GetActiveSessions ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_active_sessions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Sessions out_obj;
        switch (tdlib_type) {
            case "sessions":
                out_obj = (Sessions) jsoner.deserialize_object (typeof (Sessions));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Terminates a session of the current user
     * @param session_id Session identifier
     */
    public async Ok terminate_session (
        int64 session_id
    ) throws BadStatusCodeError {
        var obj = new TerminateSession (
            session_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (terminate_session.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Terminates all other sessions of the current user
     */
    public async Ok terminate_all_other_sessions () throws BadStatusCodeError {
        var obj = new TerminateAllOtherSessions ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (terminate_all_other_sessions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Confirms an unconfirmed session of the current user from another
     * device
     * @param session_id Session identifier
     */
    public async Ok confirm_session (
        int64 session_id
    ) throws BadStatusCodeError {
        var obj = new ConfirmSession (
            session_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (confirm_session.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether a session can accept incoming calls
     * @param session_id Session identifier
     * @param can_accept_calls Pass true to allow accepting incoming calls by
     * the session; pass false otherwise
     */
    public async Ok toggle_session_can_accept_calls (
        int64 session_id,
        bool can_accept_calls
    ) throws BadStatusCodeError {
        var obj = new ToggleSessionCanAcceptCalls (
            session_id,
            can_accept_calls
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_session_can_accept_calls.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether a session can accept incoming secret chats
     * @param session_id Session identifier
     * @param can_accept_secret_chats Pass true to allow accepting secret
     * chats by the session; pass false otherwise
     */
    public async Ok toggle_session_can_accept_secret_chats (
        int64 session_id,
        bool can_accept_secret_chats
    ) throws BadStatusCodeError {
        var obj = new ToggleSessionCanAcceptSecretChats (
            session_id,
            can_accept_secret_chats
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_session_can_accept_secret_chats.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the period of inactivity after which sessions will
     * automatically be terminated
     * @param inactive_session_ttl_days New number of days of inactivity
     * before sessions will be automatically terminated; 1-366 days
     */
    public async Ok set_inactive_session_ttl (
        int32 inactive_session_ttl_days
    ) throws BadStatusCodeError {
        var obj = new SetInactiveSessionTtl (
            inactive_session_ttl_days
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_inactive_session_ttl.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns all website where the current user used Telegram to log in
     */
    public async ConnectedWebsites get_connected_websites () throws BadStatusCodeError {
        var obj = new GetConnectedWebsites ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_connected_websites.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ConnectedWebsites out_obj;
        switch (tdlib_type) {
            case "connectedWebsites":
                out_obj = (ConnectedWebsites) jsoner.deserialize_object (typeof (ConnectedWebsites));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Disconnects website from the current user's Telegram account
     * @param website_id Website identifier
     */
    public async Ok disconnect_website (
        int64 website_id
    ) throws BadStatusCodeError {
        var obj = new DisconnectWebsite (
            website_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (disconnect_website.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Disconnects all websites from the current user's Telegram account
     */
    public async Ok disconnect_all_websites () throws BadStatusCodeError {
        var obj = new DisconnectAllWebsites ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (disconnect_all_websites.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the editable username of a supergroup or channel, requires
     * owner privileges in the supergroup or channel
     * @param supergroup_id Identifier of the supergroup or channel
     * @param username New value of the username. Use an empty string to
     * remove the username. The username can't be completely removed if there
     * is another active or disabled username
     */
    public async Ok set_supergroup_username (
        int64 supergroup_id,
        string username
    ) throws BadStatusCodeError {
        var obj = new SetSupergroupUsername (
            supergroup_id,
            username
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_supergroup_username.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes active state for a username of a supergroup or channel,
     * requires owner privileges in the supergroup or channel. The editable
     * username can't be disabled.
     * May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the
     * maximum number of active usernames has been reached
     * @param supergroup_id Identifier of the supergroup or channel
     * @param username The username to change
     * @param is_active Pass true to activate the username; pass false to
     * disable it
     */
    public async Ok toggle_supergroup_username_is_active (
        int64 supergroup_id,
        string username,
        bool is_active
    ) throws BadStatusCodeError {
        var obj = new ToggleSupergroupUsernameIsActive (
            supergroup_id,
            username,
            is_active
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_username_is_active.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Disables all active non-editable usernames of a supergroup or channel,
     * requires owner privileges in the supergroup or channel
     * @param supergroup_id Identifier of the supergroup or channel
     */
    public async Ok disable_all_supergroup_usernames (
        int64 supergroup_id
    ) throws BadStatusCodeError {
        var obj = new DisableAllSupergroupUsernames (
            supergroup_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (disable_all_supergroup_usernames.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes order of active usernames of a supergroup or channel, requires
     * owner privileges in the supergroup or channel
     * @param supergroup_id Identifier of the supergroup or channel
     * @param usernames The new order of active usernames. All currently
     * active usernames must be specified
     */
    public async Ok reorder_supergroup_active_usernames (
        int64 supergroup_id,
        Gee.ArrayList<string?> usernames
    ) throws BadStatusCodeError {
        var obj = new ReorderSupergroupActiveUsernames (
            supergroup_id,
            usernames
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reorder_supergroup_active_usernames.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the sticker set of a supergroup; requires can_change_info
     * administrator right
     * @param supergroup_id Identifier of the supergroup
     * @param sticker_set_id New value of the supergroup sticker set
     * identifier. Use 0 to remove the supergroup sticker set
     */
    public async Ok set_supergroup_sticker_set (
        int64 supergroup_id,
        int64 sticker_set_id
    ) throws BadStatusCodeError {
        var obj = new SetSupergroupStickerSet (
            supergroup_id,
            sticker_set_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_supergroup_sticker_set.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the custom emoji sticker set of a supergroup; requires
     * can_change_info administrator right. The chat must have at least
     * chatBoostFeatures.min_custom_emoji_sticker_set_boost_level boost level
     * to pass the corresponding color
     * @param supergroup_id Identifier of the supergroup
     * @param custom_emoji_sticker_set_id New value of the custom emoji
     * sticker set identifier for the supergroup. Use 0 to remove the custom
     * emoji sticker set in the supergroup
     */
    public async Ok set_supergroup_custom_emoji_sticker_set (
        int64 supergroup_id,
        int64 custom_emoji_sticker_set_id
    ) throws BadStatusCodeError {
        var obj = new SetSupergroupCustomEmojiStickerSet (
            supergroup_id,
            custom_emoji_sticker_set_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_supergroup_custom_emoji_sticker_set.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the number of times the supergroup must be boosted by a user
     * to ignore slow mode and chat permission restrictions; requires
     * can_restrict_members administrator right
     * @param supergroup_id Identifier of the supergroup
     * @param unrestrict_boost_count New value of the unrestrict_boost_count
     * supergroup setting; 0-8. Use 0 to remove the setting
     */
    public async Ok set_supergroup_unrestrict_boost_count (
        int64 supergroup_id,
        int32 unrestrict_boost_count
    ) throws BadStatusCodeError {
        var obj = new SetSupergroupUnrestrictBoostCount (
            supergroup_id,
            unrestrict_boost_count
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_supergroup_unrestrict_boost_count.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether sender signature or link to the account is added to
     * sent messages in a channel; requires can_change_info member right
     * @param supergroup_id Identifier of the channel
     * @param sign_messages New value of sign_messages
     * @param show_message_sender New value of show_message_sender
     */
    public async Ok toggle_supergroup_sign_messages (
        int64 supergroup_id,
        bool sign_messages,
        bool show_message_sender
    ) throws BadStatusCodeError {
        var obj = new ToggleSupergroupSignMessages (
            supergroup_id,
            sign_messages,
            show_message_sender
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_sign_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether joining is mandatory to send messages to a discussion
     * supergroup; requires can_restrict_members administrator right
     * @param supergroup_id Identifier of the supergroup that isn't a
     * broadcast group
     * @param join_to_send_messages New value of join_to_send_messages
     */
    public async Ok toggle_supergroup_join_to_send_messages (
        int64 supergroup_id,
        bool join_to_send_messages
    ) throws BadStatusCodeError {
        var obj = new ToggleSupergroupJoinToSendMessages (
            supergroup_id,
            join_to_send_messages
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_join_to_send_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether all users directly joining the supergroup need to be
     * approved by supergroup administrators; requires can_restrict_members
     * administrator right
     * @param supergroup_id Identifier of the supergroup that isn't a
     * broadcast group
     * @param join_by_request New value of join_by_request
     */
    public async Ok toggle_supergroup_join_by_request (
        int64 supergroup_id,
        bool join_by_request
    ) throws BadStatusCodeError {
        var obj = new ToggleSupergroupJoinByRequest (
            supergroup_id,
            join_by_request
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_join_by_request.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether the message history of a supergroup is available to
     * new members; requires can_change_info member right
     * @param supergroup_id The identifier of the supergroup
     * @param is_all_history_available The new value of
     * is_all_history_available
     */
    public async Ok toggle_supergroup_is_all_history_available (
        int64 supergroup_id,
        bool is_all_history_available
    ) throws BadStatusCodeError {
        var obj = new ToggleSupergroupIsAllHistoryAvailable (
            supergroup_id,
            is_all_history_available
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_is_all_history_available.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether sponsored messages are shown in the channel chat;
     * requires owner privileges in the channel. The chat must have at least
     * chatBoostFeatures.min_sponsored_message_disable_boost_level boost
     * level to disable sponsored messages
     * @param supergroup_id The identifier of the channel
     * @param can_have_sponsored_messages The new value of
     * can_have_sponsored_messages
     */
    public async Ok toggle_supergroup_can_have_sponsored_messages (
        int64 supergroup_id,
        bool can_have_sponsored_messages
    ) throws BadStatusCodeError {
        var obj = new ToggleSupergroupCanHaveSponsoredMessages (
            supergroup_id,
            can_have_sponsored_messages
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_can_have_sponsored_messages.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether non-administrators can receive only administrators and
     * bots using getSupergroupMembers or searchChatMembers. Can be called
     * only if supergroupFullInfo.can_hide_members == true
     * @param supergroup_id Identifier of the supergroup
     * @param has_hidden_members New value of has_hidden_members
     */
    public async Ok toggle_supergroup_has_hidden_members (
        int64 supergroup_id,
        bool has_hidden_members
    ) throws BadStatusCodeError {
        var obj = new ToggleSupergroupHasHiddenMembers (
            supergroup_id,
            has_hidden_members
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_has_hidden_members.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether aggressive anti-spam checks are enabled in the
     * supergroup. Can be called only if
     * supergroupFullInfo.can_toggle_aggressive_anti_spam == true
     * @param supergroup_id The identifier of the supergroup, which isn't a
     * broadcast group
     * @param has_aggressive_anti_spam_enabled The new value of
     * has_aggressive_anti_spam_enabled
     */
    public async Ok toggle_supergroup_has_aggressive_anti_spam_enabled (
        int64 supergroup_id,
        bool has_aggressive_anti_spam_enabled
    ) throws BadStatusCodeError {
        var obj = new ToggleSupergroupHasAggressiveAntiSpamEnabled (
            supergroup_id,
            has_aggressive_anti_spam_enabled
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_has_aggressive_anti_spam_enabled.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether the supergroup is a forum; requires owner privileges
     * in the supergroup. Discussion supergroups can't be converted to forums
     * @param supergroup_id Identifier of the supergroup
     * @param is_forum New value of is_forum
     */
    public async Ok toggle_supergroup_is_forum (
        int64 supergroup_id,
        bool is_forum
    ) throws BadStatusCodeError {
        var obj = new ToggleSupergroupIsForum (
            supergroup_id,
            is_forum
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_is_forum.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Upgrades supergroup to a broadcast group; requires owner privileges in
     * the supergroup
     * @param supergroup_id Identifier of the supergroup
     */
    public async Ok toggle_supergroup_is_broadcast_group (
        int64 supergroup_id
    ) throws BadStatusCodeError {
        var obj = new ToggleSupergroupIsBroadcastGroup (
            supergroup_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_is_broadcast_group.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Reports messages in a supergroup as spam; requires administrator
     * rights in the supergroup
     * @param supergroup_id Supergroup identifier
     * @param message_ids Identifiers of messages to report. Use
     * messageProperties.can_report_supergroup_spam to check whether the
     * message can be reported
     */
    public async Ok report_supergroup_spam (
        int64 supergroup_id,
        Gee.ArrayList<int64?> message_ids
    ) throws BadStatusCodeError {
        var obj = new ReportSupergroupSpam (
            supergroup_id,
            message_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_supergroup_spam.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Reports a false deletion of a message by aggressive anti-spam checks;
     * requires administrator rights in the supergroup. Can be called only
     * for messages from chatEventMessageDeleted with
     * can_report_anti_spam_false_positive == true
     * @param supergroup_id Supergroup identifier
     * @param message_id Identifier of the erroneously deleted message from
     * chatEventMessageDeleted
     */
    public async Ok report_supergroup_anti_spam_false_positive (
        int64 supergroup_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new ReportSupergroupAntiSpamFalsePositive (
            supergroup_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_supergroup_anti_spam_false_positive.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about members or banned users in a supergroup or
     * channel. Can be used only if supergroupFullInfo.can_get_members ==
     * true; additionally, administrator privileges may be required for some
     * filters
     * @param supergroup_id Identifier of the supergroup or channel
     * @param filter The type of users to return; pass null to use
     * supergroupMembersFilterRecent
     * @param offset Number of users to skip
     * @param limit The maximum number of users to be returned; up to 200
     */
    public async ChatMembers get_supergroup_members (
        int64 supergroup_id,
        SupergroupMembersFilter filter,
        int32 offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetSupergroupMembers (
            supergroup_id,
            filter,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_supergroup_members.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatMembers out_obj;
        switch (tdlib_type) {
            case "chatMembers":
                out_obj = (ChatMembers) jsoner.deserialize_object (typeof (ChatMembers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Closes a secret chat, effectively transferring its state to
     * secretChatStateClosed
     * @param secret_chat_id Secret chat identifier
     */
    public async Ok close_secret_chat (
        int32 secret_chat_id
    ) throws BadStatusCodeError {
        var obj = new CloseSecretChat (
            secret_chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (close_secret_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a list of service actions taken by chat members and
     * administrators in the last 48 hours. Available only for supergroups
     * and channels. Requires administrator rights. Returns results in
     * reverse chronological order (i.e., in order of decreasing event_id)
     * @param chat_id Chat identifier
     * @param query Search query by which to filter events
     * @param from_event_id Identifier of an event from which to return
     * results. Use 0 to get results from the latest events
     * @param limit The maximum number of events to return; up to 100
     * @param filters The types of events to return; pass null to get chat
     * events of all types
     * @param user_ids User identifiers by which to filter events. By
     * default, events relating to all users will be returned
     */
    public async ChatEvents get_chat_event_log (
        int64 chat_id,
        string query,
        int64 from_event_id,
        int32 limit,
        ChatEventLogFilters filters,
        Gee.ArrayList<int64?> user_ids
    ) throws BadStatusCodeError {
        var obj = new GetChatEventLog (
            chat_id,
            query,
            from_event_id,
            limit,
            filters,
            user_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_event_log.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatEvents out_obj;
        switch (tdlib_type) {
            case "chatEvents":
                out_obj = (ChatEvents) jsoner.deserialize_object (typeof (ChatEvents));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of supported time zones
     */
    public async TimeZones get_time_zones () throws BadStatusCodeError {
        var obj = new GetTimeZones ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_time_zones.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        TimeZones out_obj;
        switch (tdlib_type) {
            case "timeZones":
                out_obj = (TimeZones) jsoner.deserialize_object (typeof (TimeZones));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an invoice payment form. This method must be called when the
     * user presses inline button of the type inlineKeyboardButtonTypeBuy, or
     * wants to buy access to media in a messagePaidMedia message
     * @param input_invoice The invoice
     * @param theme Preferred payment form theme; pass null to use the
     * default theme
     */
    public async PaymentForm get_payment_form (
        InputInvoice input_invoice,
        ThemeParameters theme
    ) throws BadStatusCodeError {
        var obj = new GetPaymentForm (
            input_invoice,
            theme
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_payment_form.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PaymentForm out_obj;
        switch (tdlib_type) {
            case "paymentForm":
                out_obj = (PaymentForm) jsoner.deserialize_object (typeof (PaymentForm));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Validates the order information provided by a user and returns the
     * available shipping options for a flexible invoice
     * @param input_invoice The invoice
     * @param order_info The order information, provided by the user; pass
     * null if empty
     * @param allow_save Pass true to save the order information
     */
    public async ValidatedOrderInfo validate_order_info (
        InputInvoice input_invoice,
        OrderInfo order_info,
        bool allow_save
    ) throws BadStatusCodeError {
        var obj = new ValidateOrderInfo (
            input_invoice,
            order_info,
            allow_save
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (validate_order_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ValidatedOrderInfo out_obj;
        switch (tdlib_type) {
            case "validatedOrderInfo":
                out_obj = (ValidatedOrderInfo) jsoner.deserialize_object (typeof (ValidatedOrderInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends a filled-out payment form to the bot for final verification
     * @param input_invoice The invoice
     * @param payment_form_id Payment form identifier returned by
     * getPaymentForm
     * @param order_info_id Identifier returned by validateOrderInfo, or an
     * empty string
     * @param shipping_option_id Identifier of a chosen shipping option, if
     * applicable
     * @param credentials The credentials chosen by user for payment; pass
     * null for a payment in Telegram Stars
     * @param tip_amount Chosen by the user amount of tip in the smallest
     * units of the currency
     */
    public async PaymentResult send_payment_form (
        InputInvoice input_invoice,
        int64 payment_form_id,
        string order_info_id,
        string shipping_option_id,
        InputCredentials credentials,
        int64 tip_amount
    ) throws BadStatusCodeError {
        var obj = new SendPaymentForm (
            input_invoice,
            payment_form_id,
            order_info_id,
            shipping_option_id,
            credentials,
            tip_amount
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_payment_form.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PaymentResult out_obj;
        switch (tdlib_type) {
            case "paymentResult":
                out_obj = (PaymentResult) jsoner.deserialize_object (typeof (PaymentResult));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a successful payment
     * @param chat_id Chat identifier of the messagePaymentSuccessful message
     * @param message_id Message identifier
     */
    public async PaymentReceipt get_payment_receipt (
        int64 chat_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new GetPaymentReceipt (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_payment_receipt.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PaymentReceipt out_obj;
        switch (tdlib_type) {
            case "paymentReceipt":
                out_obj = (PaymentReceipt) jsoner.deserialize_object (typeof (PaymentReceipt));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns saved order information. Returns a 404 error if there is no
     * saved order information
     */
    public async OrderInfo get_saved_order_info () throws BadStatusCodeError {
        var obj = new GetSavedOrderInfo ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_saved_order_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        OrderInfo out_obj;
        switch (tdlib_type) {
            case "orderInfo":
                out_obj = (OrderInfo) jsoner.deserialize_object (typeof (OrderInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes saved order information
     */
    public async Ok delete_saved_order_info () throws BadStatusCodeError {
        var obj = new DeleteSavedOrderInfo ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_saved_order_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes saved credentials for all payment provider bots
     */
    public async Ok delete_saved_credentials () throws BadStatusCodeError {
        var obj = new DeleteSavedCredentials ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_saved_credentials.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns gifts that can be sent to other users
     */
    public async Gifts get_available_gifts () throws BadStatusCodeError {
        var obj = new GetAvailableGifts ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_available_gifts.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Gifts out_obj;
        switch (tdlib_type) {
            case "gifts":
                out_obj = (Gifts) jsoner.deserialize_object (typeof (Gifts));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends a gift to another user. May return an error with a message
     * "STARGIFT_USAGE_LIMITED" if the gift was sold out
     * @param gift_id Identifier of the gift to send
     * @param user_id Identifier of the user that will receive the gift
     * @param text Text to show along with the gift;
     * 0-getOption("gift_text_length_max") characters. Only Bold, Italic,
     * Underline, Strikethrough, Spoiler, and CustomEmoji entities are
     * allowed
     * @param is_private Pass true to show the current user as sender and
     * gift text only to the gift receiver; otherwise, everyone will be able
     * to see them
     */
    public async Ok send_gift (
        int64 gift_id,
        int64 user_id,
        FormattedText text,
        bool is_private
    ) throws BadStatusCodeError {
        var obj = new SendGift (
            gift_id,
            user_id,
            text,
            is_private
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_gift.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sells a gift received by the current user for Telegram Stars
     * @param sender_user_id Identifier of the user that sent the gift
     * @param message_id Identifier of the message with the gift in the chat
     * with the user
     */
    public async Ok sell_gift (
        int64 sender_user_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new SellGift (
            sender_user_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (sell_gift.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Toggles whether a gift is shown on the current user's profile page
     * @param sender_user_id Identifier of the user that sent the gift
     * @param message_id Identifier of the message with the gift in the chat
     * with the user
     * @param is_saved Pass true to display the gift on the user's profile
     * page; pass false to remove it from the profile page
     */
    public async Ok toggle_gift_is_saved (
        int64 sender_user_id,
        int64 message_id,
        bool is_saved
    ) throws BadStatusCodeError {
        var obj = new ToggleGiftIsSaved (
            sender_user_id,
            message_id,
            is_saved
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_gift_is_saved.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns gifts saved to profile by the given user
     * @param user_id Identifier of the user
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of gifts to be returned; must be
     * positive and can't be greater than 100. For optimal performance, the
     * number of returned objects is chosen by TDLib and can be smaller than
     * the specified limit
     */
    public async UserGifts get_user_gifts (
        int64 user_id,
        string offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetUserGifts (
            user_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_user_gifts.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        UserGifts out_obj;
        switch (tdlib_type) {
            case "userGifts":
                out_obj = (UserGifts) jsoner.deserialize_object (typeof (UserGifts));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Creates a link for the given invoice; for bots only
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which to send the request
     * @param invoice Information about the invoice of the type
     * inputMessageInvoice
     */
    public async HttpUrl create_invoice_link (
        string business_connection_id,
        InputMessageContent invoice
    ) throws BadStatusCodeError {
        var obj = new CreateInvoiceLink (
            business_connection_id,
            invoice
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_invoice_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        HttpUrl out_obj;
        switch (tdlib_type) {
            case "httpUrl":
                out_obj = (HttpUrl) jsoner.deserialize_object (typeof (HttpUrl));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Refunds a previously done payment in Telegram Stars; for bots only
     * @param user_id Identifier of the user that did the payment
     * @param telegram_payment_charge_id Telegram payment identifier
     */
    public async Ok refund_star_payment (
        int64 user_id,
        string telegram_payment_charge_id
    ) throws BadStatusCodeError {
        var obj = new RefundStarPayment (
            user_id,
            telegram_payment_charge_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (refund_star_payment.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a user that can be contacted to get support
     */
    public async User get_support_user () throws BadStatusCodeError {
        var obj = new GetSupportUser ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_support_user.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        User out_obj;
        switch (tdlib_type) {
            case "user":
                out_obj = (User) jsoner.deserialize_object (typeof (User));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Constructs a persistent HTTP URL for a background
     * @param name Background name
     * @param type_ Background type; backgroundTypeChatTheme isn't supported
     */
    public async HttpUrl get_background_url (
        string name,
        BackgroundType type_
    ) throws BadStatusCodeError {
        var obj = new GetBackgroundUrl (
            name,
            type_
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_background_url.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        HttpUrl out_obj;
        switch (tdlib_type) {
            case "httpUrl":
                out_obj = (HttpUrl) jsoner.deserialize_object (typeof (HttpUrl));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches for a background by its name
     * @param name The name of the background
     */
    public async Background search_background (
        string name
    ) throws BadStatusCodeError {
        var obj = new SearchBackground (
            name
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_background.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Background out_obj;
        switch (tdlib_type) {
            case "background":
                out_obj = (Background) jsoner.deserialize_object (typeof (Background));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets default background for chats; adds the background to the list of
     * installed backgrounds
     * @param background The input background to use; pass null to create a
     * new filled background
     * @param type_ Background type; pass null to use the default type of the
     * remote background; backgroundTypeChatTheme isn't supported
     * @param for_dark_theme Pass true if the background is set for a dark
     * theme
     */
    public async Background set_default_background (
        InputBackground background,
        BackgroundType type_,
        bool for_dark_theme
    ) throws BadStatusCodeError {
        var obj = new SetDefaultBackground (
            background,
            type_,
            for_dark_theme
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_default_background.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Background out_obj;
        switch (tdlib_type) {
            case "background":
                out_obj = (Background) jsoner.deserialize_object (typeof (Background));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes default background for chats
     * @param for_dark_theme Pass true if the background is deleted for a
     * dark theme
     */
    public async Ok delete_default_background (
        bool for_dark_theme
    ) throws BadStatusCodeError {
        var obj = new DeleteDefaultBackground (
            for_dark_theme
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_default_background.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns backgrounds installed by the user
     * @param for_dark_theme Pass true to order returned backgrounds for a
     * dark theme
     */
    public async Backgrounds get_installed_backgrounds (
        bool for_dark_theme
    ) throws BadStatusCodeError {
        var obj = new GetInstalledBackgrounds (
            for_dark_theme
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_installed_backgrounds.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Backgrounds out_obj;
        switch (tdlib_type) {
            case "backgrounds":
                out_obj = (Backgrounds) jsoner.deserialize_object (typeof (Backgrounds));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes background from the list of installed backgrounds
     * @param background_id The background identifier
     */
    public async Ok remove_installed_background (
        int64 background_id
    ) throws BadStatusCodeError {
        var obj = new RemoveInstalledBackground (
            background_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_installed_background.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Resets list of installed backgrounds to its default value
     */
    public async Ok reset_installed_backgrounds () throws BadStatusCodeError {
        var obj = new ResetInstalledBackgrounds ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reset_installed_backgrounds.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about the current localization target. This is an
     * offline request if only_local is true. Can be called before
     * authorization
     * @param only_local Pass true to get only locally available information
     * without sending network requests
     */
    public async LocalizationTargetInfo get_localization_target_info (
        bool only_local
    ) throws BadStatusCodeError {
        var obj = new GetLocalizationTargetInfo (
            only_local
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_localization_target_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        LocalizationTargetInfo out_obj;
        switch (tdlib_type) {
            case "localizationTargetInfo":
                out_obj = (LocalizationTargetInfo) jsoner.deserialize_object (typeof (LocalizationTargetInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a language pack. Returned language pack
     * identifier may be different from a provided one. Can be called before
     * authorization
     * @param language_pack_id Language pack identifier
     */
    public async LanguagePackInfo get_language_pack_info (
        string language_pack_id
    ) throws BadStatusCodeError {
        var obj = new GetLanguagePackInfo (
            language_pack_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_language_pack_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        LanguagePackInfo out_obj;
        switch (tdlib_type) {
            case "languagePackInfo":
                out_obj = (LanguagePackInfo) jsoner.deserialize_object (typeof (LanguagePackInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns strings from a language pack in the current localization
     * target by their keys. Can be called before authorization
     * @param language_pack_id Language pack identifier of the strings to be
     * returned
     * @param keys Language pack keys of the strings to be returned; leave
     * empty to request all available strings
     */
    public async LanguagePackStrings get_language_pack_strings (
        string language_pack_id,
        Gee.ArrayList<string?> keys
    ) throws BadStatusCodeError {
        var obj = new GetLanguagePackStrings (
            language_pack_id,
            keys
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_language_pack_strings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        LanguagePackStrings out_obj;
        switch (tdlib_type) {
            case "languagePackStrings":
                out_obj = (LanguagePackStrings) jsoner.deserialize_object (typeof (LanguagePackStrings));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Fetches the latest versions of all strings from a language pack in the
     * current localization target from the server.
     * This method doesn't need to be called explicitly for the current
     * used/base language packs. Can be called before authorization
     * @param language_pack_id Language pack identifier
     */
    public async Ok synchronize_language_pack (
        string language_pack_id
    ) throws BadStatusCodeError {
        var obj = new SynchronizeLanguagePack (
            language_pack_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (synchronize_language_pack.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a custom server language pack to the list of installed language
     * packs in current localization target. Can be called before
     * authorization
     * @param language_pack_id Identifier of a language pack to be added
     */
    public async Ok add_custom_server_language_pack (
        string language_pack_id
    ) throws BadStatusCodeError {
        var obj = new AddCustomServerLanguagePack (
            language_pack_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_custom_server_language_pack.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds or changes a custom local language pack to the current
     * localization target
     * @param info Information about the language pack. Language pack
     * identifier must start with 'X', consist only of English letters,
     * digits and hyphens, and must not exceed 64 characters. Can be called
     * before authorization
     * @param strings Strings of the new language pack
     */
    public async Ok set_custom_language_pack (
        LanguagePackInfo info,
        Gee.ArrayList<LanguagePackString?> strings
    ) throws BadStatusCodeError {
        var obj = new SetCustomLanguagePack (
            info,
            strings
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_custom_language_pack.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits information about a custom local language pack in the current
     * localization target. Can be called before authorization
     * @param info New information about the custom local language pack
     */
    public async Ok edit_custom_language_pack_info (
        LanguagePackInfo info
    ) throws BadStatusCodeError {
        var obj = new EditCustomLanguagePackInfo (
            info
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_custom_language_pack_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds, edits or deletes a string in a custom local language pack. Can
     * be called before authorization
     * @param language_pack_id Identifier of a previously added custom local
     * language pack in the current localization target
     * @param new_string New language pack string
     */
    public async Ok set_custom_language_pack_string (
        string language_pack_id,
        LanguagePackString new_string
    ) throws BadStatusCodeError {
        var obj = new SetCustomLanguagePackString (
            language_pack_id,
            new_string
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_custom_language_pack_string.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes all information about a language pack in the current
     * localization target. The language pack which is currently in use
     * (including base language pack) or is being synchronized can't be
     * deleted.
     * Can be called before authorization
     * @param language_pack_id Identifier of the language pack to delete
     */
    public async Ok delete_language_pack (
        string language_pack_id
    ) throws BadStatusCodeError {
        var obj = new DeleteLanguagePack (
            language_pack_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_language_pack.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Registers the currently used device for receiving push notifications.
     * Returns a globally unique identifier of the push notification
     * subscription
     * @param device_token Device token
     * @param other_user_ids List of user identifiers of other users
     * currently using the application
     */
    public async PushReceiverId register_device (
        DeviceToken device_token,
        Gee.ArrayList<int64?> other_user_ids
    ) throws BadStatusCodeError {
        var obj = new RegisterDevice (
            device_token,
            other_user_ids
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (register_device.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PushReceiverId out_obj;
        switch (tdlib_type) {
            case "pushReceiverId":
                out_obj = (PushReceiverId) jsoner.deserialize_object (typeof (PushReceiverId));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Handles a push notification. Returns error with code 406 if the push
     * notification is not supported and connection to the server is required
     * to fetch new data. Can be called before authorization
     * @param payload JSON-encoded push notification payload with all fields
     * sent by the server, and "google.sent_time" and
     * "google.notification.sound" fields added
     */
    public async Ok process_push_notification (
        string payload
    ) throws BadStatusCodeError {
        var obj = new ProcessPushNotification (
            payload
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (process_push_notification.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a globally unique push notification subscription identifier
     * for identification of an account, which has received a push
     * notification. Can be called synchronously
     * @param payload JSON-encoded push notification payload
     */
    public PushReceiverId get_push_receiver_id_sync (
        string payload
    ) throws BadStatusCodeError {
        var obj = new GetPushReceiverId (
            payload
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PushReceiverId out_obj;
        switch (tdlib_type) {
            case "pushReceiverId":
                out_obj = (PushReceiverId) jsoner.deserialize_object (typeof (PushReceiverId));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a globally unique push notification subscription identifier
     * for identification of an account, which has received a push
     * notification. Can be called synchronously
     * @param payload JSON-encoded push notification payload
     */
    public async PushReceiverId get_push_receiver_id (
        string payload
    ) throws BadStatusCodeError {
        var obj = new GetPushReceiverId (
            payload
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_push_receiver_id.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PushReceiverId out_obj;
        switch (tdlib_type) {
            case "pushReceiverId":
                out_obj = (PushReceiverId) jsoner.deserialize_object (typeof (PushReceiverId));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns t.me URLs recently visited by a newly registered user
     * @param referrer Google Play referrer to identify the user
     */
    public async TMeUrls get_recently_visited_t_me_urls (
        string referrer
    ) throws BadStatusCodeError {
        var obj = new GetRecentlyVisitedTMeUrls (
            referrer
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_recently_visited_t_me_urls.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        TMeUrls out_obj;
        switch (tdlib_type) {
            case "tMeUrls":
                out_obj = (TMeUrls) jsoner.deserialize_object (typeof (TMeUrls));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes user privacy settings
     * @param setting The privacy setting
     * @param rules The new privacy rules
     */
    public async Ok set_user_privacy_setting_rules (
        UserPrivacySetting setting,
        UserPrivacySettingRules rules
    ) throws BadStatusCodeError {
        var obj = new SetUserPrivacySettingRules (
            setting,
            rules
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_user_privacy_setting_rules.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the current privacy settings
     * @param setting The privacy setting
     */
    public async UserPrivacySettingRules get_user_privacy_setting_rules (
        UserPrivacySetting setting
    ) throws BadStatusCodeError {
        var obj = new GetUserPrivacySettingRules (
            setting
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_user_privacy_setting_rules.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        UserPrivacySettingRules out_obj;
        switch (tdlib_type) {
            case "userPrivacySettingRules":
                out_obj = (UserPrivacySettingRules) jsoner.deserialize_object (typeof (UserPrivacySettingRules));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes privacy settings for message read date
     * @param settings New settings
     */
    public async Ok set_read_date_privacy_settings (
        ReadDatePrivacySettings settings
    ) throws BadStatusCodeError {
        var obj = new SetReadDatePrivacySettings (
            settings
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_read_date_privacy_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns privacy settings for message read date
     */
    public async ReadDatePrivacySettings get_read_date_privacy_settings () throws BadStatusCodeError {
        var obj = new GetReadDatePrivacySettings ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_read_date_privacy_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ReadDatePrivacySettings out_obj;
        switch (tdlib_type) {
            case "readDatePrivacySettings":
                out_obj = (ReadDatePrivacySettings) jsoner.deserialize_object (typeof (ReadDatePrivacySettings));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes privacy settings for new chat creation; can be used only if
     * getOption("can_set_new_chat_privacy_settings")
     * @param settings New settings
     */
    public async Ok set_new_chat_privacy_settings (
        NewChatPrivacySettings settings
    ) throws BadStatusCodeError {
        var obj = new SetNewChatPrivacySettings (
            settings
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_new_chat_privacy_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns privacy settings for new chat creation
     */
    public async NewChatPrivacySettings get_new_chat_privacy_settings () throws BadStatusCodeError {
        var obj = new GetNewChatPrivacySettings ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_new_chat_privacy_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        NewChatPrivacySettings out_obj;
        switch (tdlib_type) {
            case "newChatPrivacySettings":
                out_obj = (NewChatPrivacySettings) jsoner.deserialize_object (typeof (NewChatPrivacySettings));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Check whether the current user can message another user or try to
     * create a chat with them
     * @param user_id Identifier of the other user
     * @param only_local Pass true to get only locally available information
     * without sending network requests
     */
    public async CanSendMessageToUserResult can_send_message_to_user (
        int64 user_id,
        bool only_local
    ) throws BadStatusCodeError {
        var obj = new CanSendMessageToUser (
            user_id,
            only_local
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (can_send_message_to_user.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        CanSendMessageToUserResult out_obj;
        switch (tdlib_type) {
            case "canSendMessageToUserResultOk":
                out_obj = (CanSendMessageToUserResultOk) jsoner.deserialize_object (typeof (CanSendMessageToUserResultOk));
                break;
            case "canSendMessageToUserResultUserIsDeleted":
                out_obj = (CanSendMessageToUserResultUserIsDeleted) jsoner.deserialize_object (typeof (CanSendMessageToUserResultUserIsDeleted));
                break;
            case "canSendMessageToUserResultUserRestrictsNewChats":
                out_obj = (CanSendMessageToUserResultUserRestrictsNewChats) jsoner.deserialize_object (typeof (CanSendMessageToUserResultUserRestrictsNewChats));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the value of an option by its name. (Check the list of
     * available options on https://core.telegram.org/tdlib/options.) Can be
     * called before authorization. Can be called synchronously for options
     * "version" and "commit_hash"
     * @param name The name of the option
     */
    public OptionValue get_option_sync (
        string name
    ) throws BadStatusCodeError {
        var obj = new GetOption (
            name
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        OptionValue out_obj;
        switch (tdlib_type) {
            case "optionValueBoolean":
                out_obj = (OptionValueBoolean) jsoner.deserialize_object (typeof (OptionValueBoolean));
                break;
            case "optionValueEmpty":
                out_obj = (OptionValueEmpty) jsoner.deserialize_object (typeof (OptionValueEmpty));
                break;
            case "optionValueInteger":
                out_obj = (OptionValueInteger) jsoner.deserialize_object (typeof (OptionValueInteger));
                break;
            case "optionValueString":
                out_obj = (OptionValueString) jsoner.deserialize_object (typeof (OptionValueString));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the value of an option by its name. (Check the list of
     * available options on https://core.telegram.org/tdlib/options.) Can be
     * called before authorization. Can be called synchronously for options
     * "version" and "commit_hash"
     * @param name The name of the option
     */
    public async OptionValue get_option (
        string name
    ) throws BadStatusCodeError {
        var obj = new GetOption (
            name
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_option.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        OptionValue out_obj;
        switch (tdlib_type) {
            case "optionValueBoolean":
                out_obj = (OptionValueBoolean) jsoner.deserialize_object (typeof (OptionValueBoolean));
                break;
            case "optionValueEmpty":
                out_obj = (OptionValueEmpty) jsoner.deserialize_object (typeof (OptionValueEmpty));
                break;
            case "optionValueInteger":
                out_obj = (OptionValueInteger) jsoner.deserialize_object (typeof (OptionValueInteger));
                break;
            case "optionValueString":
                out_obj = (OptionValueString) jsoner.deserialize_object (typeof (OptionValueString));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the value of an option. (Check the list of available options on
     * https://core.telegram.org/tdlib/options.) Only writable options can be
     * set. Can be called before authorization
     * @param name The name of the option
     * @param value The new value of the option; pass null to reset option
     * value to a default value
     */
    public async Ok set_option (
        string name,
        OptionValue value
    ) throws BadStatusCodeError {
        var obj = new SetOption (
            name,
            value
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_option.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the period of inactivity after which the account of the
     * current user will automatically be deleted
     * @param ttl New account TTL
     */
    public async Ok set_account_ttl (
        AccountTtl ttl
    ) throws BadStatusCodeError {
        var obj = new SetAccountTtl (
            ttl
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_account_ttl.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the period of inactivity after which the account of the
     * current user will automatically be deleted
     */
    public async AccountTtl get_account_ttl () throws BadStatusCodeError {
        var obj = new GetAccountTtl ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_account_ttl.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        AccountTtl out_obj;
        switch (tdlib_type) {
            case "accountTtl":
                out_obj = (AccountTtl) jsoner.deserialize_object (typeof (AccountTtl));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes the account of the current user, deleting all information
     * associated with the user from the server. The phone number of the
     * account can be used to create a new account.
     * Can be called before authorization when the current authorization
     * state is authorizationStateWaitPassword
     * @param reason The reason why the account was deleted; optional
     * @param password The 2-step verification password of the current user.
     * If the current user isn't authorized, then an empty string can be
     * passed and account deletion can be canceled within one week
     */
    public async Ok delete_account (
        string reason,
        string password
    ) throws BadStatusCodeError {
        var obj = new DeleteAccount (
            reason,
            password
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_account.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the default message auto-delete time for new chats
     * @param message_auto_delete_time New default message auto-delete time;
     * must be from 0 up to 365 * 86400 and be divisible by 86400. If 0, then
     * messages aren't deleted automatically
     */
    public async Ok set_default_message_auto_delete_time (
        MessageAutoDeleteTime message_auto_delete_time
    ) throws BadStatusCodeError {
        var obj = new SetDefaultMessageAutoDeleteTime (
            message_auto_delete_time
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_default_message_auto_delete_time.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns default message auto-delete time setting for new chats
     */
    public async MessageAutoDeleteTime get_default_message_auto_delete_time () throws BadStatusCodeError {
        var obj = new GetDefaultMessageAutoDeleteTime ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_default_message_auto_delete_time.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        MessageAutoDeleteTime out_obj;
        switch (tdlib_type) {
            case "messageAutoDeleteTime":
                out_obj = (MessageAutoDeleteTime) jsoner.deserialize_object (typeof (MessageAutoDeleteTime));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes a chat action bar without any other action
     * @param chat_id Chat identifier
     */
    public async Ok remove_chat_action_bar (
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new RemoveChatActionBar (
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_chat_action_bar.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Reports a chat to the Telegram moderators. A chat can be reported only
     * from the chat action bar, or if chat.can_be_reported
     * @param chat_id Chat identifier
     * @param option_id Option identifier chosen by the user; leave empty for
     * the initial request
     * @param message_ids Identifiers of reported messages. Use
     * messageProperties.can_report_chat to check whether the message can be
     * reported
     * @param text Additional report details if asked by the server; 0-1024
     * characters; leave empty for the initial request
     */
    public async ReportChatResult report_chat (
        int64 chat_id,
        Bytes option_id,
        Gee.ArrayList<int64?> message_ids,
        string text
    ) throws BadStatusCodeError {
        var obj = new ReportChat (
            chat_id,
            option_id,
            message_ids,
            text
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_chat.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ReportChatResult out_obj;
        switch (tdlib_type) {
            case "reportChatResultOk":
                out_obj = (ReportChatResultOk) jsoner.deserialize_object (typeof (ReportChatResultOk));
                break;
            case "reportChatResultOptionRequired":
                out_obj = (ReportChatResultOptionRequired) jsoner.deserialize_object (typeof (ReportChatResultOptionRequired));
                break;
            case "reportChatResultTextRequired":
                out_obj = (ReportChatResultTextRequired) jsoner.deserialize_object (typeof (ReportChatResultTextRequired));
                break;
            case "reportChatResultMessagesRequired":
                out_obj = (ReportChatResultMessagesRequired) jsoner.deserialize_object (typeof (ReportChatResultMessagesRequired));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Reports a chat photo to the Telegram moderators. A chat photo can be
     * reported only if chat.can_be_reported
     * @param chat_id Chat identifier
     * @param file_id Identifier of the photo to report. Only full photos
     * from chatPhoto can be reported
     * @param reason The reason for reporting the chat photo
     * @param text Additional report details; 0-1024 characters
     */
    public async Ok report_chat_photo (
        int64 chat_id,
        int32 file_id,
        ReportReason reason,
        string text
    ) throws BadStatusCodeError {
        var obj = new ReportChatPhoto (
            chat_id,
            file_id,
            reason,
            text
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_chat_photo.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Reports reactions set on a message to the Telegram moderators.
     * Reactions on a message can be reported only if
     * messageProperties.can_report_reactions
     * @param chat_id Chat identifier
     * @param message_id Message identifier
     * @param sender_id Identifier of the sender, which added the reaction
     */
    public async Ok report_message_reactions (
        int64 chat_id,
        int64 message_id,
        MessageSender sender_id
    ) throws BadStatusCodeError {
        var obj = new ReportMessageReactions (
            chat_id,
            message_id,
            sender_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_message_reactions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns detailed revenue statistics about a chat. Currently, this
     * method can be used only
     * for channels if supergroupFullInfo.can_get_revenue_statistics == true
     * or bots if userFullInfo.bot_info.can_get_revenue_statistics == true
     * @param chat_id Chat identifier
     * @param is_dark Pass true if a dark theme is used by the application
     */
    public async ChatRevenueStatistics get_chat_revenue_statistics (
        int64 chat_id,
        bool is_dark
    ) throws BadStatusCodeError {
        var obj = new GetChatRevenueStatistics (
            chat_id,
            is_dark
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_revenue_statistics.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatRevenueStatistics out_obj;
        switch (tdlib_type) {
            case "chatRevenueStatistics":
                out_obj = (ChatRevenueStatistics) jsoner.deserialize_object (typeof (ChatRevenueStatistics));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a URL for chat revenue withdrawal; requires owner privileges
     * in the channel chat or the bot. Currently, this method can be used
     * only
     * if getOption("can_withdraw_chat_revenue") for channels with
     * supergroupFullInfo.can_get_revenue_statistics == true or bots with
     * userFullInfo.bot_info.can_get_revenue_statistics == true
     * @param chat_id Chat identifier
     * @param password The 2-step verification password of the current user
     */
    public async HttpUrl get_chat_revenue_withdrawal_url (
        int64 chat_id,
        string password
    ) throws BadStatusCodeError {
        var obj = new GetChatRevenueWithdrawalUrl (
            chat_id,
            password
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_revenue_withdrawal_url.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        HttpUrl out_obj;
        switch (tdlib_type) {
            case "httpUrl":
                out_obj = (HttpUrl) jsoner.deserialize_object (typeof (HttpUrl));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of revenue transactions for a chat. Currently, this
     * method can be used only
     * for channels if supergroupFullInfo.can_get_revenue_statistics == true
     * or bots if userFullInfo.bot_info.can_get_revenue_statistics == true
     * @param chat_id Chat identifier
     * @param offset Number of transactions to skip
     * @param limit The maximum number of transactions to be returned; up to
     * 200
     */
    public async ChatRevenueTransactions get_chat_revenue_transactions (
        int64 chat_id,
        int32 offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetChatRevenueTransactions (
            chat_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_revenue_transactions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatRevenueTransactions out_obj;
        switch (tdlib_type) {
            case "chatRevenueTransactions":
                out_obj = (ChatRevenueTransactions) jsoner.deserialize_object (typeof (ChatRevenueTransactions));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns detailed Telegram Star revenue statistics
     * @param owner_id Identifier of the owner of the Telegram Stars; can be
     * identifier of an owned bot, or identifier of a channel chat with
     * supergroupFullInfo.can_get_star_revenue_statistics == true
     * @param is_dark Pass true if a dark theme is used by the application
     */
    public async StarRevenueStatistics get_star_revenue_statistics (
        MessageSender owner_id,
        bool is_dark
    ) throws BadStatusCodeError {
        var obj = new GetStarRevenueStatistics (
            owner_id,
            is_dark
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_star_revenue_statistics.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StarRevenueStatistics out_obj;
        switch (tdlib_type) {
            case "starRevenueStatistics":
                out_obj = (StarRevenueStatistics) jsoner.deserialize_object (typeof (StarRevenueStatistics));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a URL for Telegram Star withdrawal
     * @param owner_id Identifier of the owner of the Telegram Stars; can be
     * identifier of an owned bot, or identifier of an owned channel chat
     * @param star_count The number of Telegram Stars to withdraw. Must be at
     * least getOption("star_withdrawal_count_min")
     * @param password The 2-step verification password of the current user
     */
    public async HttpUrl get_star_withdrawal_url (
        MessageSender owner_id,
        int64 star_count,
        string password
    ) throws BadStatusCodeError {
        var obj = new GetStarWithdrawalUrl (
            owner_id,
            star_count,
            password
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_star_withdrawal_url.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        HttpUrl out_obj;
        switch (tdlib_type) {
            case "httpUrl":
                out_obj = (HttpUrl) jsoner.deserialize_object (typeof (HttpUrl));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a URL for a Telegram Ad platform account that can be used to
     * set up advertisements for the chat paid in the owned Telegram Stars
     * @param owner_id Identifier of the owner of the Telegram Stars; can be
     * identifier of an owned bot, or identifier of an owned channel chat
     */
    public async HttpUrl get_star_ad_account_url (
        MessageSender owner_id
    ) throws BadStatusCodeError {
        var obj = new GetStarAdAccountUrl (
            owner_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_star_ad_account_url.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        HttpUrl out_obj;
        switch (tdlib_type) {
            case "httpUrl":
                out_obj = (HttpUrl) jsoner.deserialize_object (typeof (HttpUrl));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns detailed statistics about a chat. Currently, this method can
     * be used only for supergroups and channels. Can be used only if
     * supergroupFullInfo.can_get_statistics == true
     * @param chat_id Chat identifier
     * @param is_dark Pass true if a dark theme is used by the application
     */
    public async ChatStatistics get_chat_statistics (
        int64 chat_id,
        bool is_dark
    ) throws BadStatusCodeError {
        var obj = new GetChatStatistics (
            chat_id,
            is_dark
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_statistics.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        ChatStatistics out_obj;
        switch (tdlib_type) {
            case "chatStatisticsSupergroup":
                out_obj = (ChatStatisticsSupergroup) jsoner.deserialize_object (typeof (ChatStatisticsSupergroup));
                break;
            case "chatStatisticsChannel":
                out_obj = (ChatStatisticsChannel) jsoner.deserialize_object (typeof (ChatStatisticsChannel));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns detailed statistics about a message. Can be used only if
     * messageProperties.can_get_statistics == true
     * @param chat_id Chat identifier
     * @param message_id Message identifier
     * @param is_dark Pass true if a dark theme is used by the application
     */
    public async MessageStatistics get_message_statistics (
        int64 chat_id,
        int64 message_id,
        bool is_dark
    ) throws BadStatusCodeError {
        var obj = new GetMessageStatistics (
            chat_id,
            message_id,
            is_dark
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_statistics.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        MessageStatistics out_obj;
        switch (tdlib_type) {
            case "messageStatistics":
                out_obj = (MessageStatistics) jsoner.deserialize_object (typeof (MessageStatistics));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns forwarded copies of a channel message to different public
     * channels and public reposts as a story. Can be used only if
     * messageProperties.can_get_statistics == true. For optimal performance,
     * the number of returned messages and stories is chosen by TDLib
     * @param chat_id Chat identifier of the message
     * @param message_id Message identifier
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of messages and stories to be
     * returned; must be positive and can't be greater than 100. For optimal
     * performance, the number of returned objects is chosen by TDLib and can
     * be smaller than the specified limit
     */
    public async PublicForwards get_message_public_forwards (
        int64 chat_id,
        int64 message_id,
        string offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetMessagePublicForwards (
            chat_id,
            message_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_public_forwards.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PublicForwards out_obj;
        switch (tdlib_type) {
            case "publicForwards":
                out_obj = (PublicForwards) jsoner.deserialize_object (typeof (PublicForwards));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns detailed statistics about a story. Can be used only if
     * story.can_get_statistics == true
     * @param chat_id Chat identifier
     * @param story_id Story identifier
     * @param is_dark Pass true if a dark theme is used by the application
     */
    public async StoryStatistics get_story_statistics (
        int64 chat_id,
        int32 story_id,
        bool is_dark
    ) throws BadStatusCodeError {
        var obj = new GetStoryStatistics (
            chat_id,
            story_id,
            is_dark
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_story_statistics.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StoryStatistics out_obj;
        switch (tdlib_type) {
            case "storyStatistics":
                out_obj = (StoryStatistics) jsoner.deserialize_object (typeof (StoryStatistics));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Loads an asynchronous or a zoomed in statistical graph
     * @param chat_id Chat identifier
     * @param token The token for graph loading
     * @param x X-value for zoomed in graph or 0 otherwise
     */
    public async StatisticalGraph get_statistical_graph (
        int64 chat_id,
        string token,
        int64 x
    ) throws BadStatusCodeError {
        var obj = new GetStatisticalGraph (
            chat_id,
            token,
            x
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_statistical_graph.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StatisticalGraph out_obj;
        switch (tdlib_type) {
            case "statisticalGraphData":
                out_obj = (StatisticalGraphData) jsoner.deserialize_object (typeof (StatisticalGraphData));
                break;
            case "statisticalGraphAsync":
                out_obj = (StatisticalGraphAsync) jsoner.deserialize_object (typeof (StatisticalGraphAsync));
                break;
            case "statisticalGraphError":
                out_obj = (StatisticalGraphError) jsoner.deserialize_object (typeof (StatisticalGraphError));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns storage usage statistics. Can be called before authorization
     * @param chat_limit The maximum number of chats with the largest storage
     * usage for which separate statistics need to be returned. All other
     * chats will be grouped in entries with chat_id == 0. If the chat info
     * database is not used, the chat_limit is ignored and is always set to 0
     */
    public async StorageStatistics get_storage_statistics (
        int32 chat_limit
    ) throws BadStatusCodeError {
        var obj = new GetStorageStatistics (
            chat_limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_storage_statistics.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StorageStatistics out_obj;
        switch (tdlib_type) {
            case "storageStatistics":
                out_obj = (StorageStatistics) jsoner.deserialize_object (typeof (StorageStatistics));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Quickly returns approximate storage usage statistics. Can be called
     * before authorization
     */
    public async StorageStatisticsFast get_storage_statistics_fast () throws BadStatusCodeError {
        var obj = new GetStorageStatisticsFast ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_storage_statistics_fast.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StorageStatisticsFast out_obj;
        switch (tdlib_type) {
            case "storageStatisticsFast":
                out_obj = (StorageStatisticsFast) jsoner.deserialize_object (typeof (StorageStatisticsFast));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns database statistics
     */
    public async DatabaseStatistics get_database_statistics () throws BadStatusCodeError {
        var obj = new GetDatabaseStatistics ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_database_statistics.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        DatabaseStatistics out_obj;
        switch (tdlib_type) {
            case "databaseStatistics":
                out_obj = (DatabaseStatistics) jsoner.deserialize_object (typeof (DatabaseStatistics));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Optimizes storage usage, i.e. deletes some files and returns new
     * storage usage statistics. Secret thumbnails can't be deleted
     * @param size Limit on the total size of files after deletion, in bytes.
     * Pass -1 to use the default limit
     * @param ttl Limit on the time that has passed since the last time a
     * file was accessed (or creation time for some filesystems). Pass -1 to
     * use the default limit
     * @param count Limit on the total number of files after deletion. Pass
     * -1 to use the default limit
     * @param immunity_delay The amount of time after the creation of a file
     * during which it can't be deleted, in seconds. Pass -1 to use the
     * default value
     * @param file_types If non-empty, only files with the given types are
     * considered. By default, all types except thumbnails, profile photos,
     * stickers and wallpapers are deleted
     * @param chat_ids If non-empty, only files from the given chats are
     * considered. Use 0 as chat identifier to delete files not belonging to
     * any chat (e.g., profile photos)
     * @param exclude_chat_ids If non-empty, files from the given chats are
     * excluded. Use 0 as chat identifier to exclude all files not belonging
     * to any chat (e.g., profile photos)
     * @param return_deleted_file_statistics Pass true if statistics about
     * the files that were deleted must be returned instead of the whole
     * storage usage statistics. Affects only returned statistics
     * @param chat_limit Same as in getStorageStatistics. Affects only
     * returned statistics
     */
    public async StorageStatistics optimize_storage (
        int64 size,
        int32 ttl,
        int32 count,
        int32 immunity_delay,
        Gee.ArrayList<FileType?> file_types,
        Gee.ArrayList<int64?> chat_ids,
        Gee.ArrayList<int64?> exclude_chat_ids,
        bool return_deleted_file_statistics,
        int32 chat_limit
    ) throws BadStatusCodeError {
        var obj = new OptimizeStorage (
            size,
            ttl,
            count,
            immunity_delay,
            file_types,
            chat_ids,
            exclude_chat_ids,
            return_deleted_file_statistics,
            chat_limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (optimize_storage.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StorageStatistics out_obj;
        switch (tdlib_type) {
            case "storageStatistics":
                out_obj = (StorageStatistics) jsoner.deserialize_object (typeof (StorageStatistics));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the current network type. Can be called before authorization.
     * Calling this method forces all network connections to reopen,
     * mitigating the delay in switching between different networks,
     * so it must be called whenever the network is changed, even if the
     * network type remains the same. Network type is used to check whether
     * the library can use the network at all and also for collecting
     * detailed network data usage statistics
     * @param type_ The new network type; pass null to set network type to
     * networkTypeOther
     */
    public async Ok set_network_type (
        NetworkType type_
    ) throws BadStatusCodeError {
        var obj = new SetNetworkType (
            type_
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_network_type.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns network data usage statistics. Can be called before
     * authorization
     * @param only_current Pass true to get statistics only for the current
     * library launch
     */
    public async NetworkStatistics get_network_statistics (
        bool only_current
    ) throws BadStatusCodeError {
        var obj = new GetNetworkStatistics (
            only_current
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_network_statistics.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        NetworkStatistics out_obj;
        switch (tdlib_type) {
            case "networkStatistics":
                out_obj = (NetworkStatistics) jsoner.deserialize_object (typeof (NetworkStatistics));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds the specified data to data usage statistics. Can be called before
     * authorization
     * @param entry The network statistics entry with the data to be added to
     * statistics
     */
    public async Ok add_network_statistics (
        NetworkStatisticsEntry entry
    ) throws BadStatusCodeError {
        var obj = new AddNetworkStatistics (
            entry
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_network_statistics.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Resets all network data usage statistics to zero. Can be called before
     * authorization
     */
    public async Ok reset_network_statistics () throws BadStatusCodeError {
        var obj = new ResetNetworkStatistics ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reset_network_statistics.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns auto-download settings presets for the current user
     */
    public async AutoDownloadSettingsPresets get_auto_download_settings_presets () throws BadStatusCodeError {
        var obj = new GetAutoDownloadSettingsPresets ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_auto_download_settings_presets.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        AutoDownloadSettingsPresets out_obj;
        switch (tdlib_type) {
            case "autoDownloadSettingsPresets":
                out_obj = (AutoDownloadSettingsPresets) jsoner.deserialize_object (typeof (AutoDownloadSettingsPresets));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets auto-download settings
     * @param settings New user auto-download settings
     * @param type_ Type of the network for which the new settings are
     * relevant
     */
    public async Ok set_auto_download_settings (
        AutoDownloadSettings settings,
        NetworkType type_
    ) throws BadStatusCodeError {
        var obj = new SetAutoDownloadSettings (
            settings,
            type_
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_auto_download_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns autosave settings for the current user
     */
    public async AutosaveSettings get_autosave_settings () throws BadStatusCodeError {
        var obj = new GetAutosaveSettings ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_autosave_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        AutosaveSettings out_obj;
        switch (tdlib_type) {
            case "autosaveSettings":
                out_obj = (AutosaveSettings) jsoner.deserialize_object (typeof (AutosaveSettings));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets autosave settings for the given scope. The method is guaranteed
     * to work only after at least one call to getAutosaveSettings
     * @param scope Autosave settings scope
     * @param settings New autosave settings for the scope; pass null to set
     * autosave settings to default
     */
    public async Ok set_autosave_settings (
        AutosaveSettingsScope scope,
        ScopeAutosaveSettings settings
    ) throws BadStatusCodeError {
        var obj = new SetAutosaveSettings (
            scope,
            settings
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_autosave_settings.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Clears the list of all autosave settings exceptions. The method is
     * guaranteed to work only after at least one call to getAutosaveSettings
     */
    public async Ok clear_autosave_settings_exceptions () throws BadStatusCodeError {
        var obj = new ClearAutosaveSettingsExceptions ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clear_autosave_settings_exceptions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a bank card
     * @param bank_card_number The bank card number
     */
    public async BankCardInfo get_bank_card_info (
        string bank_card_number
    ) throws BadStatusCodeError {
        var obj = new GetBankCardInfo (
            bank_card_number
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_bank_card_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BankCardInfo out_obj;
        switch (tdlib_type) {
            case "bankCardInfo":
                out_obj = (BankCardInfo) jsoner.deserialize_object (typeof (BankCardInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns one of the available Telegram Passport elements
     * @param type_ Telegram Passport element type
     * @param password The 2-step verification password of the current user
     */
    public async PassportElement get_passport_element (
        PassportElementType type_,
        string password
    ) throws BadStatusCodeError {
        var obj = new GetPassportElement (
            type_,
            password
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_passport_element.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PassportElement out_obj;
        switch (tdlib_type) {
            case "passportElementPersonalDetails":
                out_obj = (PassportElementPersonalDetails) jsoner.deserialize_object (typeof (PassportElementPersonalDetails));
                break;
            case "passportElementPassport":
                out_obj = (PassportElementPassport) jsoner.deserialize_object (typeof (PassportElementPassport));
                break;
            case "passportElementDriverLicense":
                out_obj = (PassportElementDriverLicense) jsoner.deserialize_object (typeof (PassportElementDriverLicense));
                break;
            case "passportElementIdentityCard":
                out_obj = (PassportElementIdentityCard) jsoner.deserialize_object (typeof (PassportElementIdentityCard));
                break;
            case "passportElementInternalPassport":
                out_obj = (PassportElementInternalPassport) jsoner.deserialize_object (typeof (PassportElementInternalPassport));
                break;
            case "passportElementAddress":
                out_obj = (PassportElementAddress) jsoner.deserialize_object (typeof (PassportElementAddress));
                break;
            case "passportElementUtilityBill":
                out_obj = (PassportElementUtilityBill) jsoner.deserialize_object (typeof (PassportElementUtilityBill));
                break;
            case "passportElementBankStatement":
                out_obj = (PassportElementBankStatement) jsoner.deserialize_object (typeof (PassportElementBankStatement));
                break;
            case "passportElementRentalAgreement":
                out_obj = (PassportElementRentalAgreement) jsoner.deserialize_object (typeof (PassportElementRentalAgreement));
                break;
            case "passportElementPassportRegistration":
                out_obj = (PassportElementPassportRegistration) jsoner.deserialize_object (typeof (PassportElementPassportRegistration));
                break;
            case "passportElementTemporaryRegistration":
                out_obj = (PassportElementTemporaryRegistration) jsoner.deserialize_object (typeof (PassportElementTemporaryRegistration));
                break;
            case "passportElementPhoneNumber":
                out_obj = (PassportElementPhoneNumber) jsoner.deserialize_object (typeof (PassportElementPhoneNumber));
                break;
            case "passportElementEmailAddress":
                out_obj = (PassportElementEmailAddress) jsoner.deserialize_object (typeof (PassportElementEmailAddress));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns all available Telegram Passport elements
     * @param password The 2-step verification password of the current user
     */
    public async PassportElements get_all_passport_elements (
        string password
    ) throws BadStatusCodeError {
        var obj = new GetAllPassportElements (
            password
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_all_passport_elements.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PassportElements out_obj;
        switch (tdlib_type) {
            case "passportElements":
                out_obj = (PassportElements) jsoner.deserialize_object (typeof (PassportElements));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds an element to the user's Telegram Passport. May return an error
     * with a message "PHONE_VERIFICATION_NEEDED" or
     * "EMAIL_VERIFICATION_NEEDED" if the chosen phone number or the chosen
     * email address must be verified first
     * @param element Input Telegram Passport element
     * @param password The 2-step verification password of the current user
     */
    public async PassportElement set_passport_element (
        InputPassportElement element,
        string password
    ) throws BadStatusCodeError {
        var obj = new SetPassportElement (
            element,
            password
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_passport_element.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PassportElement out_obj;
        switch (tdlib_type) {
            case "passportElementPersonalDetails":
                out_obj = (PassportElementPersonalDetails) jsoner.deserialize_object (typeof (PassportElementPersonalDetails));
                break;
            case "passportElementPassport":
                out_obj = (PassportElementPassport) jsoner.deserialize_object (typeof (PassportElementPassport));
                break;
            case "passportElementDriverLicense":
                out_obj = (PassportElementDriverLicense) jsoner.deserialize_object (typeof (PassportElementDriverLicense));
                break;
            case "passportElementIdentityCard":
                out_obj = (PassportElementIdentityCard) jsoner.deserialize_object (typeof (PassportElementIdentityCard));
                break;
            case "passportElementInternalPassport":
                out_obj = (PassportElementInternalPassport) jsoner.deserialize_object (typeof (PassportElementInternalPassport));
                break;
            case "passportElementAddress":
                out_obj = (PassportElementAddress) jsoner.deserialize_object (typeof (PassportElementAddress));
                break;
            case "passportElementUtilityBill":
                out_obj = (PassportElementUtilityBill) jsoner.deserialize_object (typeof (PassportElementUtilityBill));
                break;
            case "passportElementBankStatement":
                out_obj = (PassportElementBankStatement) jsoner.deserialize_object (typeof (PassportElementBankStatement));
                break;
            case "passportElementRentalAgreement":
                out_obj = (PassportElementRentalAgreement) jsoner.deserialize_object (typeof (PassportElementRentalAgreement));
                break;
            case "passportElementPassportRegistration":
                out_obj = (PassportElementPassportRegistration) jsoner.deserialize_object (typeof (PassportElementPassportRegistration));
                break;
            case "passportElementTemporaryRegistration":
                out_obj = (PassportElementTemporaryRegistration) jsoner.deserialize_object (typeof (PassportElementTemporaryRegistration));
                break;
            case "passportElementPhoneNumber":
                out_obj = (PassportElementPhoneNumber) jsoner.deserialize_object (typeof (PassportElementPhoneNumber));
                break;
            case "passportElementEmailAddress":
                out_obj = (PassportElementEmailAddress) jsoner.deserialize_object (typeof (PassportElementEmailAddress));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Deletes a Telegram Passport element
     * @param type_ Element type
     */
    public async Ok delete_passport_element (
        PassportElementType type_
    ) throws BadStatusCodeError {
        var obj = new DeletePassportElement (
            type_
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_passport_element.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs the user that some of the elements in their Telegram Passport
     * contain errors; for bots only. The user will not be able to resend the
     * elements, until the errors are fixed
     * @param user_id User identifier
     * @param errors The errors
     */
    public async Ok set_passport_element_errors (
        int64 user_id,
        Gee.ArrayList<InputPassportElementError?> errors
    ) throws BadStatusCodeError {
        var obj = new SetPassportElementErrors (
            user_id,
            errors
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_passport_element_errors.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an IETF language tag of the language preferred in the country,
     * which must be used to fill native fields in Telegram Passport personal
     * details. Returns a 404 error if unknown
     * @param country_code A two-letter ISO 3166-1 alpha-2 country code
     */
    public async Text get_preferred_country_language (
        string country_code
    ) throws BadStatusCodeError {
        var obj = new GetPreferredCountryLanguage (
            country_code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_preferred_country_language.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends a code to verify an email address to be added to a user's
     * Telegram Passport
     * @param email_address Email address
     */
    public async EmailAddressAuthenticationCodeInfo send_email_address_verification_code (
        string email_address
    ) throws BadStatusCodeError {
        var obj = new SendEmailAddressVerificationCode (
            email_address
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_email_address_verification_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        EmailAddressAuthenticationCodeInfo out_obj;
        switch (tdlib_type) {
            case "emailAddressAuthenticationCodeInfo":
                out_obj = (EmailAddressAuthenticationCodeInfo) jsoner.deserialize_object (typeof (EmailAddressAuthenticationCodeInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Resends the code to verify an email address to be added to a user's
     * Telegram Passport
     */
    public async EmailAddressAuthenticationCodeInfo resend_email_address_verification_code () throws BadStatusCodeError {
        var obj = new ResendEmailAddressVerificationCode ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (resend_email_address_verification_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        EmailAddressAuthenticationCodeInfo out_obj;
        switch (tdlib_type) {
            case "emailAddressAuthenticationCodeInfo":
                out_obj = (EmailAddressAuthenticationCodeInfo) jsoner.deserialize_object (typeof (EmailAddressAuthenticationCodeInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks the email address verification code for Telegram Passport
     * @param code Verification code to check
     */
    public async Ok check_email_address_verification_code (
        string code
    ) throws BadStatusCodeError {
        var obj = new CheckEmailAddressVerificationCode (
            code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_email_address_verification_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a Telegram Passport authorization form for sharing data with a
     * service
     * @param bot_user_id User identifier of the service's bot
     * @param scope Telegram Passport element types requested by the service
     * @param public_key Service's public key
     * @param nonce Unique request identifier provided by the service
     */
    public async PassportAuthorizationForm get_passport_authorization_form (
        int64 bot_user_id,
        string scope,
        string public_key,
        string nonce
    ) throws BadStatusCodeError {
        var obj = new GetPassportAuthorizationForm (
            bot_user_id,
            scope,
            public_key,
            nonce
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_passport_authorization_form.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PassportAuthorizationForm out_obj;
        switch (tdlib_type) {
            case "passportAuthorizationForm":
                out_obj = (PassportAuthorizationForm) jsoner.deserialize_object (typeof (PassportAuthorizationForm));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns already available Telegram Passport elements suitable for
     * completing a Telegram Passport authorization form. Result can be
     * received only once for each authorization form
     * @param authorization_form_id Authorization form identifier
     * @param password The 2-step verification password of the current user
     */
    public async PassportElementsWithErrors get_passport_authorization_form_available_elements (
        int32 authorization_form_id,
        string password
    ) throws BadStatusCodeError {
        var obj = new GetPassportAuthorizationFormAvailableElements (
            authorization_form_id,
            password
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_passport_authorization_form_available_elements.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PassportElementsWithErrors out_obj;
        switch (tdlib_type) {
            case "passportElementsWithErrors":
                out_obj = (PassportElementsWithErrors) jsoner.deserialize_object (typeof (PassportElementsWithErrors));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends a Telegram Passport authorization form, effectively sharing data
     * with the service. This method must be called after
     * getPassportAuthorizationFormAvailableElements if some previously
     * available elements are going to be reused
     * @param authorization_form_id Authorization form identifier
     * @param types Types of Telegram Passport elements chosen by user to
     * complete the authorization form
     */
    public async Ok send_passport_authorization_form (
        int32 authorization_form_id,
        Gee.ArrayList<PassportElementType?> types
    ) throws BadStatusCodeError {
        var obj = new SendPassportAuthorizationForm (
            authorization_form_id,
            types
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_passport_authorization_form.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs the server about the number of pending bot updates if they
     * haven't been processed for a long time; for bots only
     * @param pending_update_count The number of pending updates
     * @param error_message The last error message
     */
    public async Ok set_bot_updates_status (
        int32 pending_update_count,
        string error_message
    ) throws BadStatusCodeError {
        var obj = new SetBotUpdatesStatus (
            pending_update_count,
            error_message
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_bot_updates_status.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Uploads a file with a sticker; returns the uploaded file
     * @param user_id Sticker file owner; ignored for regular users
     * @param sticker_format Sticker format
     * @param sticker File file to upload; must fit in a 512x512 square. For
     * WEBP stickers the file must be in WEBP or PNG format, which will be
     * converted to WEBP server-side. See
     * https://core.telegram.org/animated_stickers#technical-requirements for
     * technical requirements
     */
    public async File upload_sticker_file (
        int64 user_id,
        StickerFormat sticker_format,
        InputFile sticker
    ) throws BadStatusCodeError {
        var obj = new UploadStickerFile (
            user_id,
            sticker_format,
            sticker
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (upload_sticker_file.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        File out_obj;
        switch (tdlib_type) {
            case "file":
                out_obj = (File) jsoner.deserialize_object (typeof (File));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns a suggested name for a new sticker set with a given title
     * @param title Sticker set title; 1-64 characters
     */
    public async Text get_suggested_sticker_set_name (
        string title
    ) throws BadStatusCodeError {
        var obj = new GetSuggestedStickerSetName (
            title
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_suggested_sticker_set_name.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks whether a name can be used for a new sticker set
     * @param name Name to be checked
     */
    public async CheckStickerSetNameResult check_sticker_set_name (
        string name
    ) throws BadStatusCodeError {
        var obj = new CheckStickerSetName (
            name
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_sticker_set_name.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        CheckStickerSetNameResult out_obj;
        switch (tdlib_type) {
            case "checkStickerSetNameResultOk":
                out_obj = (CheckStickerSetNameResultOk) jsoner.deserialize_object (typeof (CheckStickerSetNameResultOk));
                break;
            case "checkStickerSetNameResultNameInvalid":
                out_obj = (CheckStickerSetNameResultNameInvalid) jsoner.deserialize_object (typeof (CheckStickerSetNameResultNameInvalid));
                break;
            case "checkStickerSetNameResultNameOccupied":
                out_obj = (CheckStickerSetNameResultNameOccupied) jsoner.deserialize_object (typeof (CheckStickerSetNameResultNameOccupied));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Creates a new sticker set. Returns the newly created sticker set
     * @param user_id Sticker set owner; ignored for regular users
     * @param title Sticker set title; 1-64 characters
     * @param name Sticker set name. Can contain only English letters, digits
     * and underscores. Must end with *"_by_<bot username>"*
     * (*<bot_username>* is case insensitive) for bots; 0-64 characters. If
     * empty, then the name returned by getSuggestedStickerSetName will be
     * used automatically
     * @param sticker_type Type of the stickers in the set
     * @param needs_repainting Pass true if stickers in the sticker set must
     * be repainted; for custom emoji sticker sets only
     * @param stickers List of stickers to be added to the set; 1-200
     * stickers for custom emoji sticker sets, and 1-120 stickers otherwise.
     * For TGS stickers, uploadStickerFile must be used before the sticker is
     * shown
     * @param source Source of the sticker set; may be empty if unknown
     */
    public async StickerSet create_new_sticker_set (
        int64 user_id,
        string title,
        string name,
        StickerType sticker_type,
        bool needs_repainting,
        Gee.ArrayList<InputSticker?> stickers,
        string source
    ) throws BadStatusCodeError {
        var obj = new CreateNewStickerSet (
            user_id,
            title,
            name,
            sticker_type,
            needs_repainting,
            stickers,
            source
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_new_sticker_set.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StickerSet out_obj;
        switch (tdlib_type) {
            case "stickerSet":
                out_obj = (StickerSet) jsoner.deserialize_object (typeof (StickerSet));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a new sticker to a set
     * @param user_id Sticker set owner; ignored for regular users
     * @param name Sticker set name. The sticker set must be owned by the
     * current user, and contain less than 200 stickers for custom emoji
     * sticker sets and less than 120 otherwise
     * @param sticker Sticker to add to the set
     */
    public async Ok add_sticker_to_set (
        int64 user_id,
        string name,
        InputSticker sticker
    ) throws BadStatusCodeError {
        var obj = new AddStickerToSet (
            user_id,
            name,
            sticker
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_sticker_to_set.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Replaces existing sticker in a set. The function is equivalent to
     * removeStickerFromSet, then addStickerToSet, then
     * setStickerPositionInSet
     * @param user_id Sticker set owner; ignored for regular users
     * @param name Sticker set name. The sticker set must be owned by the
     * current user
     * @param old_sticker Sticker to remove from the set
     * @param new_sticker Sticker to add to the set
     */
    public async Ok replace_sticker_in_set (
        int64 user_id,
        string name,
        InputFile old_sticker,
        InputSticker new_sticker
    ) throws BadStatusCodeError {
        var obj = new ReplaceStickerInSet (
            user_id,
            name,
            old_sticker,
            new_sticker
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (replace_sticker_in_set.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets a sticker set thumbnail
     * @param user_id Sticker set owner; ignored for regular users
     * @param name Sticker set name. The sticker set must be owned by the
     * current user
     * @param thumbnail Thumbnail to set; pass null to remove the sticker set
     * thumbnail
     * @param format Format of the thumbnail; pass null if thumbnail is
     * removed
     */
    public async Ok set_sticker_set_thumbnail (
        int64 user_id,
        string name,
        InputFile thumbnail,
        StickerFormat format
    ) throws BadStatusCodeError {
        var obj = new SetStickerSetThumbnail (
            user_id,
            name,
            thumbnail,
            format
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_sticker_set_thumbnail.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets a custom emoji sticker set thumbnail
     * @param name Sticker set name. The sticker set must be owned by the
     * current user
     * @param custom_emoji_id Identifier of the custom emoji from the sticker
     * set, which will be set as sticker set thumbnail; pass 0 to remove the
     * sticker set thumbnail
     */
    public async Ok set_custom_emoji_sticker_set_thumbnail (
        string name,
        int64 custom_emoji_id
    ) throws BadStatusCodeError {
        var obj = new SetCustomEmojiStickerSetThumbnail (
            name,
            custom_emoji_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_custom_emoji_sticker_set_thumbnail.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets a sticker set title
     * @param name Sticker set name. The sticker set must be owned by the
     * current user
     * @param title New sticker set title
     */
    public async Ok set_sticker_set_title (
        string name,
        string title
    ) throws BadStatusCodeError {
        var obj = new SetStickerSetTitle (
            name,
            title
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_sticker_set_title.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Completely deletes a sticker set
     * @param name Sticker set name. The sticker set must be owned by the
     * current user
     */
    public async Ok delete_sticker_set (
        string name
    ) throws BadStatusCodeError {
        var obj = new DeleteStickerSet (
            name
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_sticker_set.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the position of a sticker in the set to which it belongs. The
     * sticker set must be owned by the current user
     * @param sticker Sticker
     * @param position New position of the sticker in the set, 0-based
     */
    public async Ok set_sticker_position_in_set (
        InputFile sticker,
        int32 position
    ) throws BadStatusCodeError {
        var obj = new SetStickerPositionInSet (
            sticker,
            position
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_sticker_position_in_set.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes a sticker from the set to which it belongs. The sticker set
     * must be owned by the current user
     * @param sticker Sticker to remove from the set
     */
    public async Ok remove_sticker_from_set (
        InputFile sticker
    ) throws BadStatusCodeError {
        var obj = new RemoveStickerFromSet (
            sticker
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_sticker_from_set.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the list of emojis corresponding to a sticker. The sticker
     * must belong to a regular or custom emoji sticker set that is owned by
     * the current user
     * @param sticker Sticker
     * @param emojis New string with 1-20 emoji corresponding to the sticker
     */
    public async Ok set_sticker_emojis (
        InputFile sticker,
        string emojis
    ) throws BadStatusCodeError {
        var obj = new SetStickerEmojis (
            sticker,
            emojis
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_sticker_emojis.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the list of keywords of a sticker. The sticker must belong to
     * a regular or custom emoji sticker set that is owned by the current
     * user
     * @param sticker Sticker
     * @param keywords List of up to 20 keywords with total length up to 64
     * characters, which can be used to find the sticker
     */
    public async Ok set_sticker_keywords (
        InputFile sticker,
        Gee.ArrayList<string?> keywords
    ) throws BadStatusCodeError {
        var obj = new SetStickerKeywords (
            sticker,
            keywords
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_sticker_keywords.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Changes the mask position of a mask sticker. The sticker must belong
     * to a mask sticker set that is owned by the current user
     * @param sticker Sticker
     * @param mask_position Position where the mask is placed; pass null to
     * remove mask position
     */
    public async Ok set_sticker_mask_position (
        InputFile sticker,
        MaskPosition mask_position
    ) throws BadStatusCodeError {
        var obj = new SetStickerMaskPosition (
            sticker,
            mask_position
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_sticker_mask_position.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns sticker sets owned by the current user
     * @param offset_sticker_set_id Identifier of the sticker set from which
     * to return owned sticker sets; use 0 to get results from the beginning
     * @param limit The maximum number of sticker sets to be returned; must
     * be positive and can't be greater than 100. For optimal performance,
     * the number of returned objects is chosen by TDLib and can be smaller
     * than the specified limit
     */
    public async StickerSets get_owned_sticker_sets (
        int64 offset_sticker_set_id,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetOwnedStickerSets (
            offset_sticker_set_id,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_owned_sticker_sets.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StickerSets out_obj;
        switch (tdlib_type) {
            case "stickerSets":
                out_obj = (StickerSets) jsoner.deserialize_object (typeof (StickerSets));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a file with a map thumbnail in PNG format.
     * Only map thumbnail files with size less than 1MB can be downloaded
     * @param location Location of the map center
     * @param zoom Map zoom level; 13-20
     * @param width Map width in pixels before applying scale; 16-1024
     * @param height Map height in pixels before applying scale; 16-1024
     * @param scale Map scale; 1-3
     * @param chat_id Identifier of a chat in which the thumbnail will be
     * shown. Use 0 if unknown
     */
    public async File get_map_thumbnail_file (
        Location location,
        int32 zoom,
        int32 width,
        int32 height,
        int32 scale,
        int64 chat_id
    ) throws BadStatusCodeError {
        var obj = new GetMapThumbnailFile (
            location,
            zoom,
            width,
            height,
            scale,
            chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_map_thumbnail_file.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        File out_obj;
        switch (tdlib_type) {
            case "file":
                out_obj = (File) jsoner.deserialize_object (typeof (File));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a limit, increased for Premium users.
     * Returns a 404 error if the limit is unknown
     * @param limit_type Type of the limit
     */
    public async PremiumLimit get_premium_limit (
        PremiumLimitType limit_type
    ) throws BadStatusCodeError {
        var obj = new GetPremiumLimit (
            limit_type
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_premium_limit.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PremiumLimit out_obj;
        switch (tdlib_type) {
            case "premiumLimit":
                out_obj = (PremiumLimit) jsoner.deserialize_object (typeof (PremiumLimit));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about features, available to Premium users
     * @param source Source of the request; pass null if the method is called
     * from some non-standard source
     */
    public async PremiumFeatures get_premium_features (
        PremiumSource source
    ) throws BadStatusCodeError {
        var obj = new GetPremiumFeatures (
            source
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_premium_features.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PremiumFeatures out_obj;
        switch (tdlib_type) {
            case "premiumFeatures":
                out_obj = (PremiumFeatures) jsoner.deserialize_object (typeof (PremiumFeatures));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns examples of premium stickers for demonstration purposes
     */
    public async Stickers get_premium_sticker_examples () throws BadStatusCodeError {
        var obj = new GetPremiumStickerExamples ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_premium_sticker_examples.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Stickers out_obj;
        switch (tdlib_type) {
            case "stickers":
                out_obj = (Stickers) jsoner.deserialize_object (typeof (Stickers));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the sticker to be used as representation of the Telegram
     * Premium subscription
     * @param month_count Number of months the Telegram Premium subscription
     * will be active
     */
    public async Sticker get_premium_info_sticker (
        int32 month_count
    ) throws BadStatusCodeError {
        var obj = new GetPremiumInfoSticker (
            month_count
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_premium_info_sticker.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Sticker out_obj;
        switch (tdlib_type) {
            case "sticker":
                out_obj = (Sticker) jsoner.deserialize_object (typeof (Sticker));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs TDLib that the user viewed detailed information about a
     * Premium feature on the Premium features screen
     * @param feature The viewed premium feature
     */
    public async Ok view_premium_feature (
        PremiumFeature feature
    ) throws BadStatusCodeError {
        var obj = new ViewPremiumFeature (
            feature
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (view_premium_feature.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs TDLib that the user clicked Premium subscription button on the
     * Premium features screen
     */
    public async Ok click_premium_subscription_button () throws BadStatusCodeError {
        var obj = new ClickPremiumSubscriptionButton ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (click_premium_subscription_button.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns state of Telegram Premium subscription and promotion videos
     * for Premium features
     */
    public async PremiumState get_premium_state () throws BadStatusCodeError {
        var obj = new GetPremiumState ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_premium_state.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PremiumState out_obj;
        switch (tdlib_type) {
            case "premiumState":
                out_obj = (PremiumState) jsoner.deserialize_object (typeof (PremiumState));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns available options for Telegram Premium gift code or Telegram
     * Premium giveaway creation
     * @param boosted_chat_id Identifier of the supergroup or channel chat,
     * which will be automatically boosted by receivers of the gift codes and
     * which is administered by the user; 0 if none
     */
    public async PremiumGiftCodePaymentOptions get_premium_gift_code_payment_options (
        int64 boosted_chat_id
    ) throws BadStatusCodeError {
        var obj = new GetPremiumGiftCodePaymentOptions (
            boosted_chat_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_premium_gift_code_payment_options.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PremiumGiftCodePaymentOptions out_obj;
        switch (tdlib_type) {
            case "premiumGiftCodePaymentOptions":
                out_obj = (PremiumGiftCodePaymentOptions) jsoner.deserialize_object (typeof (PremiumGiftCodePaymentOptions));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Return information about a Telegram Premium gift code
     * @param code The code to check
     */
    public async PremiumGiftCodeInfo check_premium_gift_code (
        string code
    ) throws BadStatusCodeError {
        var obj = new CheckPremiumGiftCode (
            code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_premium_gift_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PremiumGiftCodeInfo out_obj;
        switch (tdlib_type) {
            case "premiumGiftCodeInfo":
                out_obj = (PremiumGiftCodeInfo) jsoner.deserialize_object (typeof (PremiumGiftCodeInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Applies a Telegram Premium gift code
     * @param code The code to apply
     */
    public async Ok apply_premium_gift_code (
        string code
    ) throws BadStatusCodeError {
        var obj = new ApplyPremiumGiftCode (
            code
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (apply_premium_gift_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Launches a prepaid giveaway
     * @param giveaway_id Unique identifier of the prepaid giveaway
     * @param parameters Giveaway parameters
     * @param winner_count The number of users to receive giveaway prize
     * @param star_count The number of Telegram Stars to be distributed
     * through the giveaway; pass 0 for Telegram Premium giveaways
     */
    public async Ok launch_prepaid_giveaway (
        int64 giveaway_id,
        GiveawayParameters parameters,
        int32 winner_count,
        int64 star_count
    ) throws BadStatusCodeError {
        var obj = new LaunchPrepaidGiveaway (
            giveaway_id,
            parameters,
            winner_count,
            star_count
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (launch_prepaid_giveaway.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a giveaway
     * @param chat_id Identifier of the channel chat which started the
     * giveaway
     * @param message_id Identifier of the giveaway or a giveaway winners
     * message in the chat
     */
    public async GiveawayInfo get_giveaway_info (
        int64 chat_id,
        int64 message_id
    ) throws BadStatusCodeError {
        var obj = new GetGiveawayInfo (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_giveaway_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        GiveawayInfo out_obj;
        switch (tdlib_type) {
            case "giveawayInfoOngoing":
                out_obj = (GiveawayInfoOngoing) jsoner.deserialize_object (typeof (GiveawayInfoOngoing));
                break;
            case "giveawayInfoCompleted":
                out_obj = (GiveawayInfoCompleted) jsoner.deserialize_object (typeof (GiveawayInfoCompleted));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns available options for Telegram Stars purchase
     */
    public async StarPaymentOptions get_star_payment_options () throws BadStatusCodeError {
        var obj = new GetStarPaymentOptions ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_star_payment_options.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StarPaymentOptions out_obj;
        switch (tdlib_type) {
            case "starPaymentOptions":
                out_obj = (StarPaymentOptions) jsoner.deserialize_object (typeof (StarPaymentOptions));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns available options for Telegram Stars gifting
     * @param user_id Identifier of the user that will receive Telegram
     * Stars; pass 0 to get options for an unspecified user
     */
    public async StarPaymentOptions get_star_gift_payment_options (
        int64 user_id
    ) throws BadStatusCodeError {
        var obj = new GetStarGiftPaymentOptions (
            user_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_star_gift_payment_options.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StarPaymentOptions out_obj;
        switch (tdlib_type) {
            case "starPaymentOptions":
                out_obj = (StarPaymentOptions) jsoner.deserialize_object (typeof (StarPaymentOptions));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns available options for Telegram Star giveaway creation
     */
    public async StarGiveawayPaymentOptions get_star_giveaway_payment_options () throws BadStatusCodeError {
        var obj = new GetStarGiveawayPaymentOptions ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_star_giveaway_payment_options.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StarGiveawayPaymentOptions out_obj;
        switch (tdlib_type) {
            case "starGiveawayPaymentOptions":
                out_obj = (StarGiveawayPaymentOptions) jsoner.deserialize_object (typeof (StarGiveawayPaymentOptions));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of Telegram Star transactions for the specified owner
     * @param owner_id Identifier of the owner of the Telegram Stars; can be
     * the identifier of the current user, identifier of an owned bot, or
     * identifier of a channel chat with
     * supergroupFullInfo.can_get_star_revenue_statistics == true
     * @param subscription_id If non-empty, only transactions related to the
     * Star Subscription will be returned
     * @param direction Direction of the transactions to receive; pass null
     * to get all transactions
     * @param offset Offset of the first transaction to return as received
     * from the previous request; use empty string to get the first chunk of
     * results
     * @param limit The maximum number of transactions to return
     */
    public async StarTransactions get_star_transactions (
        MessageSender owner_id,
        string subscription_id,
        StarTransactionDirection direction,
        string offset,
        int32 limit
    ) throws BadStatusCodeError {
        var obj = new GetStarTransactions (
            owner_id,
            subscription_id,
            direction,
            offset,
            limit
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_star_transactions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StarTransactions out_obj;
        switch (tdlib_type) {
            case "starTransactions":
                out_obj = (StarTransactions) jsoner.deserialize_object (typeof (StarTransactions));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of Telegram Star subscriptions for the current user
     * @param only_expiring Pass true to receive only expiring subscriptions
     * for which there are no enough Telegram Stars to extend
     * @param offset Offset of the first subscription to return as received
     * from the previous request; use empty string to get the first chunk of
     * results
     */
    public async StarSubscriptions get_star_subscriptions (
        bool only_expiring,
        string offset
    ) throws BadStatusCodeError {
        var obj = new GetStarSubscriptions (
            only_expiring,
            offset
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_star_subscriptions.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        StarSubscriptions out_obj;
        switch (tdlib_type) {
            case "starSubscriptions":
                out_obj = (StarSubscriptions) jsoner.deserialize_object (typeof (StarSubscriptions));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Checks whether an in-store purchase is possible. Must be called before
     * any in-store purchase
     * @param purpose Transaction purpose
     */
    public async Ok can_purchase_from_store (
        StorePaymentPurpose purpose
    ) throws BadStatusCodeError {
        var obj = new CanPurchaseFromStore (
            purpose
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (can_purchase_from_store.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs server about a purchase through App Store. For official
     * applications only
     * @param receipt App Store receipt
     * @param purpose Transaction purpose
     */
    public async Ok assign_app_store_transaction (
        Bytes receipt,
        StorePaymentPurpose purpose
    ) throws BadStatusCodeError {
        var obj = new AssignAppStoreTransaction (
            receipt,
            purpose
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (assign_app_store_transaction.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Informs server about a purchase through Google Play. For official
     * applications only
     * @param package_name Application package name
     * @param store_product_id Identifier of the purchased store product
     * @param purchase_token Google Play purchase token
     * @param purpose Transaction purpose
     */
    public async Ok assign_google_play_transaction (
        string package_name,
        string store_product_id,
        string purchase_token,
        StorePaymentPurpose purpose
    ) throws BadStatusCodeError {
        var obj = new AssignGooglePlayTransaction (
            package_name,
            store_product_id,
            purchase_token,
            purpose
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (assign_google_play_transaction.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Cancels or re-enables Telegram Star subscription
     * @param subscription_id Identifier of the subscription to change
     * @param is_canceled New value of is_canceled
     */
    public async Ok edit_star_subscription (
        string subscription_id,
        bool is_canceled
    ) throws BadStatusCodeError {
        var obj = new EditStarSubscription (
            subscription_id,
            is_canceled
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_star_subscription.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Cancels or re-enables Telegram Star subscription for a user; for bots
     * only
     * @param user_id User identifier
     * @param telegram_payment_charge_id Telegram payment identifier of the
     * subscription
     * @param is_canceled Pass true to cancel the subscription; pass false to
     * allow the user to enable it
     */
    public async Ok edit_user_star_subscription (
        int64 user_id,
        string telegram_payment_charge_id,
        bool is_canceled
    ) throws BadStatusCodeError {
        var obj = new EditUserStarSubscription (
            user_id,
            telegram_payment_charge_id,
            is_canceled
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_user_star_subscription.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Reuses an active Telegram Star subscription to a channel chat and
     * joins the chat again
     * @param subscription_id Identifier of the subscription
     */
    public async Ok reuse_star_subscription (
        string subscription_id
    ) throws BadStatusCodeError {
        var obj = new ReuseStarSubscription (
            subscription_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reuse_star_subscription.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about features, available to Business users
     * @param source Source of the request; pass null if the method is called
     * from settings or some non-standard source
     */
    public async BusinessFeatures get_business_features (
        BusinessFeature source
    ) throws BadStatusCodeError {
        var obj = new GetBusinessFeatures (
            source
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_business_features.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        BusinessFeatures out_obj;
        switch (tdlib_type) {
            case "businessFeatures":
                out_obj = (BusinessFeatures) jsoner.deserialize_object (typeof (BusinessFeatures));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Accepts Telegram terms of services
     * @param terms_of_service_id Terms of service identifier
     */
    public async Ok accept_terms_of_service (
        string terms_of_service_id
    ) throws BadStatusCodeError {
        var obj = new AcceptTermsOfService (
            terms_of_service_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (accept_terms_of_service.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches specified query by word prefixes in the provided strings.
     * Returns 0-based positions of strings that matched. Can be called
     * synchronously
     * @param strings The strings to search in for the query
     * @param query Query to search for
     * @param limit The maximum number of objects to return
     * @param return_none_for_empty_query Pass true to receive no results for
     * an empty query
     */
    public FoundPositions search_strings_by_prefix_sync (
        Gee.ArrayList<string?> strings,
        string query,
        int32 limit,
        bool return_none_for_empty_query
    ) throws BadStatusCodeError {
        var obj = new SearchStringsByPrefix (
            strings,
            query,
            limit,
            return_none_for_empty_query
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundPositions out_obj;
        switch (tdlib_type) {
            case "foundPositions":
                out_obj = (FoundPositions) jsoner.deserialize_object (typeof (FoundPositions));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Searches specified query by word prefixes in the provided strings.
     * Returns 0-based positions of strings that matched. Can be called
     * synchronously
     * @param strings The strings to search in for the query
     * @param query Query to search for
     * @param limit The maximum number of objects to return
     * @param return_none_for_empty_query Pass true to receive no results for
     * an empty query
     */
    public async FoundPositions search_strings_by_prefix (
        Gee.ArrayList<string?> strings,
        string query,
        int32 limit,
        bool return_none_for_empty_query
    ) throws BadStatusCodeError {
        var obj = new SearchStringsByPrefix (
            strings,
            query,
            limit,
            return_none_for_empty_query
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_strings_by_prefix.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        FoundPositions out_obj;
        switch (tdlib_type) {
            case "foundPositions":
                out_obj = (FoundPositions) jsoner.deserialize_object (typeof (FoundPositions));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends a custom request; for bots only
     * @param method The method name
     * @param parameters JSON-serialized method parameters
     */
    public async CustomRequestResult send_custom_request (
        string method,
        string parameters
    ) throws BadStatusCodeError {
        var obj = new SendCustomRequest (
            method,
            parameters
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_custom_request.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        CustomRequestResult out_obj;
        switch (tdlib_type) {
            case "customRequestResult":
                out_obj = (CustomRequestResult) jsoner.deserialize_object (typeof (CustomRequestResult));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Answers a custom query; for bots only
     * @param custom_query_id Identifier of a custom query
     * @param data JSON-serialized answer to the query
     */
    public async Ok answer_custom_query (
        int64 custom_query_id,
        string data
    ) throws BadStatusCodeError {
        var obj = new AnswerCustomQuery (
            custom_query_id,
            data
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (answer_custom_query.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Succeeds after a specified amount of time has passed. Can be called
     * before initialization
     * @param seconds Number of seconds before the function returns
     */
    public async Ok set_alarm (
        double seconds
    ) throws BadStatusCodeError {
        var obj = new SetAlarm (
            seconds
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_alarm.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about existing countries. Can be called before
     * authorization
     */
    public async Countries get_countries () throws BadStatusCodeError {
        var obj = new GetCountries ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_countries.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Countries out_obj;
        switch (tdlib_type) {
            case "countries":
                out_obj = (Countries) jsoner.deserialize_object (typeof (Countries));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Uses the current IP address to find the current country. Returns
     * two-letter ISO 3166-1 alpha-2 country code. Can be called before
     * authorization
     */
    public async Text get_country_code () throws BadStatusCodeError {
        var obj = new GetCountryCode ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_country_code.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a phone number by its prefix. Can be called
     * before authorization
     * @param phone_number_prefix The phone number prefix
     */
    public async PhoneNumberInfo get_phone_number_info (
        string phone_number_prefix
    ) throws BadStatusCodeError {
        var obj = new GetPhoneNumberInfo (
            phone_number_prefix
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_phone_number_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PhoneNumberInfo out_obj;
        switch (tdlib_type) {
            case "phoneNumberInfo":
                out_obj = (PhoneNumberInfo) jsoner.deserialize_object (typeof (PhoneNumberInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a phone number by its prefix synchronously.
     * getCountries must be called at least once after changing localization
     * to the specified language if properly localized country information is
     * expected. Can be called synchronously
     * @param language_code A two-letter ISO 639-1 language code for country
     * information localization
     * @param phone_number_prefix The phone number prefix
     */
    public PhoneNumberInfo get_phone_number_info_sync_sync (
        string language_code,
        string phone_number_prefix
    ) throws BadStatusCodeError {
        var obj = new GetPhoneNumberInfoSync (
            language_code,
            phone_number_prefix
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PhoneNumberInfo out_obj;
        switch (tdlib_type) {
            case "phoneNumberInfo":
                out_obj = (PhoneNumberInfo) jsoner.deserialize_object (typeof (PhoneNumberInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a phone number by its prefix synchronously.
     * getCountries must be called at least once after changing localization
     * to the specified language if properly localized country information is
     * expected. Can be called synchronously
     * @param language_code A two-letter ISO 639-1 language code for country
     * information localization
     * @param phone_number_prefix The phone number prefix
     */
    public async PhoneNumberInfo get_phone_number_info_sync (
        string language_code,
        string phone_number_prefix
    ) throws BadStatusCodeError {
        var obj = new GetPhoneNumberInfoSync (
            language_code,
            phone_number_prefix
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_phone_number_info_sync.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        PhoneNumberInfo out_obj;
        switch (tdlib_type) {
            case "phoneNumberInfo":
                out_obj = (PhoneNumberInfo) jsoner.deserialize_object (typeof (PhoneNumberInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a given collectible item that was purchased
     * at https://fragment.com
     * @param type_ Type of the collectible item. The item must be used by a
     * user and must be visible to the current user
     */
    public async CollectibleItemInfo get_collectible_item_info (
        CollectibleItemType type_
    ) throws BadStatusCodeError {
        var obj = new GetCollectibleItemInfo (
            type_
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_collectible_item_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        CollectibleItemInfo out_obj;
        switch (tdlib_type) {
            case "collectibleItemInfo":
                out_obj = (CollectibleItemInfo) jsoner.deserialize_object (typeof (CollectibleItemInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about a tg:// deep link. Use
     * "tg://need_update_for_some_feature" or "tg:some_unsupported_feature"
     * for testing. Returns a 404 error for unknown links. Can be called
     * before authorization
     * @param link The link
     */
    public async DeepLinkInfo get_deep_link_info (
        string link
    ) throws BadStatusCodeError {
        var obj = new GetDeepLinkInfo (
            link
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_deep_link_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        DeepLinkInfo out_obj;
        switch (tdlib_type) {
            case "deepLinkInfo":
                out_obj = (DeepLinkInfo) jsoner.deserialize_object (typeof (DeepLinkInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns application config, provided by the server. Can be called
     * before authorization
     */
    public async JsonValue get_application_config () throws BadStatusCodeError {
        var obj = new GetApplicationConfig ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_application_config.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        JsonValue out_obj;
        switch (tdlib_type) {
            case "jsonValueNull":
                out_obj = (JsonValueNull) jsoner.deserialize_object (typeof (JsonValueNull));
                break;
            case "jsonValueBoolean":
                out_obj = (JsonValueBoolean) jsoner.deserialize_object (typeof (JsonValueBoolean));
                break;
            case "jsonValueNumber":
                out_obj = (JsonValueNumber) jsoner.deserialize_object (typeof (JsonValueNumber));
                break;
            case "jsonValueString":
                out_obj = (JsonValueString) jsoner.deserialize_object (typeof (JsonValueString));
                break;
            case "jsonValueArray":
                out_obj = (JsonValueArray) jsoner.deserialize_object (typeof (JsonValueArray));
                break;
            case "jsonValueObject":
                out_obj = (JsonValueObject) jsoner.deserialize_object (typeof (JsonValueObject));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Saves application log event on the server. Can be called before
     * authorization
     * @param type_ Event type
     * @param chat_id Optional chat identifier, associated with the event
     * @param data The log event data
     */
    public async Ok save_application_log_event (
        string type_,
        int64 chat_id,
        JsonValue data
    ) throws BadStatusCodeError {
        var obj = new SaveApplicationLogEvent (
            type_,
            chat_id,
            data
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (save_application_log_event.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the link for downloading official Telegram application to be
     * used when the current user invites friends to Telegram
     */
    public async HttpUrl get_application_download_link () throws BadStatusCodeError {
        var obj = new GetApplicationDownloadLink ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_application_download_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        HttpUrl out_obj;
        switch (tdlib_type) {
            case "httpUrl":
                out_obj = (HttpUrl) jsoner.deserialize_object (typeof (HttpUrl));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a proxy server for network requests. Can be called before
     * authorization
     * @param server Proxy server domain or IP address
     * @param port Proxy server port
     * @param enable Pass true to immediately enable the proxy
     * @param type_ Proxy type
     */
    public async Proxy add_proxy (
        string server,
        int32 port,
        bool enable,
        ProxyType type_
    ) throws BadStatusCodeError {
        var obj = new AddProxy (
            server,
            port,
            enable,
            type_
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_proxy.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Proxy out_obj;
        switch (tdlib_type) {
            case "proxy":
                out_obj = (Proxy) jsoner.deserialize_object (typeof (Proxy));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Edits an existing proxy server for network requests. Can be called
     * before authorization
     * @param proxy_id Proxy identifier
     * @param server Proxy server domain or IP address
     * @param port Proxy server port
     * @param enable Pass true to immediately enable the proxy
     * @param type_ Proxy type
     */
    public async Proxy edit_proxy (
        int32 proxy_id,
        string server,
        int32 port,
        bool enable,
        ProxyType type_
    ) throws BadStatusCodeError {
        var obj = new EditProxy (
            proxy_id,
            server,
            port,
            enable,
            type_
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_proxy.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Proxy out_obj;
        switch (tdlib_type) {
            case "proxy":
                out_obj = (Proxy) jsoner.deserialize_object (typeof (Proxy));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Enables a proxy. Only one proxy can be enabled at a time. Can be
     * called before authorization
     * @param proxy_id Proxy identifier
     */
    public async Ok enable_proxy (
        int32 proxy_id
    ) throws BadStatusCodeError {
        var obj = new EnableProxy (
            proxy_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (enable_proxy.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Disables the currently enabled proxy. Can be called before
     * authorization
     */
    public async Ok disable_proxy () throws BadStatusCodeError {
        var obj = new DisableProxy ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (disable_proxy.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Removes a proxy server. Can be called before authorization
     * @param proxy_id Proxy identifier
     */
    public async Ok remove_proxy (
        int32 proxy_id
    ) throws BadStatusCodeError {
        var obj = new RemoveProxy (
            proxy_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_proxy.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of proxies that are currently set up. Can be called
     * before authorization
     */
    public async Proxies get_proxies () throws BadStatusCodeError {
        var obj = new GetProxies ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_proxies.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Proxies out_obj;
        switch (tdlib_type) {
            case "proxies":
                out_obj = (Proxies) jsoner.deserialize_object (typeof (Proxies));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns an HTTPS link, which can be used to add a proxy. Available
     * only for SOCKS5 and MTProto proxies. Can be called before
     * authorization
     * @param proxy_id Proxy identifier
     */
    public async HttpUrl get_proxy_link (
        int32 proxy_id
    ) throws BadStatusCodeError {
        var obj = new GetProxyLink (
            proxy_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_proxy_link.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        HttpUrl out_obj;
        switch (tdlib_type) {
            case "httpUrl":
                out_obj = (HttpUrl) jsoner.deserialize_object (typeof (HttpUrl));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Computes time needed to receive a response from a Telegram server
     * through a proxy. Can be called before authorization
     * @param proxy_id Proxy identifier. Use 0 to ping a Telegram server
     * without a proxy
     */
    public async Seconds ping_proxy (
        int32 proxy_id
    ) throws BadStatusCodeError {
        var obj = new PingProxy (
            proxy_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (ping_proxy.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Seconds out_obj;
        switch (tdlib_type) {
            case "seconds":
                out_obj = (Seconds) jsoner.deserialize_object (typeof (Seconds));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets new log stream for internal logging of TDLib. Can be called
     * synchronously
     * @param log_stream New log stream
     */
    public Ok set_log_stream_sync (
        LogStream log_stream
    ) throws BadStatusCodeError {
        var obj = new SetLogStream (
            log_stream
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets new log stream for internal logging of TDLib. Can be called
     * synchronously
     * @param log_stream New log stream
     */
    public async Ok set_log_stream (
        LogStream log_stream
    ) throws BadStatusCodeError {
        var obj = new SetLogStream (
            log_stream
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_log_stream.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about currently used log stream for internal
     * logging of TDLib. Can be called synchronously
     */
    public LogStream get_log_stream_sync () throws BadStatusCodeError {
        var obj = new GetLogStream ();

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        LogStream out_obj;
        switch (tdlib_type) {
            case "logStreamDefault":
                out_obj = (LogStreamDefault) jsoner.deserialize_object (typeof (LogStreamDefault));
                break;
            case "logStreamFile":
                out_obj = (LogStreamFile) jsoner.deserialize_object (typeof (LogStreamFile));
                break;
            case "logStreamEmpty":
                out_obj = (LogStreamEmpty) jsoner.deserialize_object (typeof (LogStreamEmpty));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns information about currently used log stream for internal
     * logging of TDLib. Can be called synchronously
     */
    public async LogStream get_log_stream () throws BadStatusCodeError {
        var obj = new GetLogStream ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_log_stream.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        LogStream out_obj;
        switch (tdlib_type) {
            case "logStreamDefault":
                out_obj = (LogStreamDefault) jsoner.deserialize_object (typeof (LogStreamDefault));
                break;
            case "logStreamFile":
                out_obj = (LogStreamFile) jsoner.deserialize_object (typeof (LogStreamFile));
                break;
            case "logStreamEmpty":
                out_obj = (LogStreamEmpty) jsoner.deserialize_object (typeof (LogStreamEmpty));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the verbosity level of the internal logging of TDLib. Can be
     * called synchronously
     * @param new_verbosity_level New value of the verbosity level for
     * logging. Value 0 corresponds to fatal errors, value 1 corresponds to
     * errors, value 2 corresponds to warnings and debug warnings, value 3
     * corresponds to informational, value 4 corresponds to debug, value 5
     * corresponds to verbose debug, value greater than 5 and up to 1023 can
     * be used to enable even more logging
     */
    public Ok set_log_verbosity_level_sync (
        int32 new_verbosity_level
    ) throws BadStatusCodeError {
        var obj = new SetLogVerbosityLevel (
            new_verbosity_level
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the verbosity level of the internal logging of TDLib. Can be
     * called synchronously
     * @param new_verbosity_level New value of the verbosity level for
     * logging. Value 0 corresponds to fatal errors, value 1 corresponds to
     * errors, value 2 corresponds to warnings and debug warnings, value 3
     * corresponds to informational, value 4 corresponds to debug, value 5
     * corresponds to verbose debug, value greater than 5 and up to 1023 can
     * be used to enable even more logging
     */
    public async Ok set_log_verbosity_level (
        int32 new_verbosity_level
    ) throws BadStatusCodeError {
        var obj = new SetLogVerbosityLevel (
            new_verbosity_level
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_log_verbosity_level.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns current verbosity level of the internal logging of TDLib. Can
     * be called synchronously
     */
    public LogVerbosityLevel get_log_verbosity_level_sync () throws BadStatusCodeError {
        var obj = new GetLogVerbosityLevel ();

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        LogVerbosityLevel out_obj;
        switch (tdlib_type) {
            case "logVerbosityLevel":
                out_obj = (LogVerbosityLevel) jsoner.deserialize_object (typeof (LogVerbosityLevel));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns current verbosity level of the internal logging of TDLib. Can
     * be called synchronously
     */
    public async LogVerbosityLevel get_log_verbosity_level () throws BadStatusCodeError {
        var obj = new GetLogVerbosityLevel ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_log_verbosity_level.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        LogVerbosityLevel out_obj;
        switch (tdlib_type) {
            case "logVerbosityLevel":
                out_obj = (LogVerbosityLevel) jsoner.deserialize_object (typeof (LogVerbosityLevel));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of available TDLib internal log tags, for example,
     * ["actor", "binlog", "connections", "notifications", "proxy"]. Can be
     * called synchronously
     */
    public LogTags get_log_tags_sync () throws BadStatusCodeError {
        var obj = new GetLogTags ();

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        LogTags out_obj;
        switch (tdlib_type) {
            case "logTags":
                out_obj = (LogTags) jsoner.deserialize_object (typeof (LogTags));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the list of available TDLib internal log tags, for example,
     * ["actor", "binlog", "connections", "notifications", "proxy"]. Can be
     * called synchronously
     */
    public async LogTags get_log_tags () throws BadStatusCodeError {
        var obj = new GetLogTags ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_log_tags.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        LogTags out_obj;
        switch (tdlib_type) {
            case "logTags":
                out_obj = (LogTags) jsoner.deserialize_object (typeof (LogTags));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the verbosity level for a specified TDLib internal log tag. Can
     * be called synchronously
     * @param tag Logging tag to change verbosity level
     * @param new_verbosity_level New verbosity level; 1-1024
     */
    public Ok set_log_tag_verbosity_level_sync (
        string tag,
        int32 new_verbosity_level
    ) throws BadStatusCodeError {
        var obj = new SetLogTagVerbosityLevel (
            tag,
            new_verbosity_level
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets the verbosity level for a specified TDLib internal log tag. Can
     * be called synchronously
     * @param tag Logging tag to change verbosity level
     * @param new_verbosity_level New verbosity level; 1-1024
     */
    public async Ok set_log_tag_verbosity_level (
        string tag,
        int32 new_verbosity_level
    ) throws BadStatusCodeError {
        var obj = new SetLogTagVerbosityLevel (
            tag,
            new_verbosity_level
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_log_tag_verbosity_level.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns current verbosity level for a specified TDLib internal log
     * tag. Can be called synchronously
     * @param tag Logging tag to change verbosity level
     */
    public LogVerbosityLevel get_log_tag_verbosity_level_sync (
        string tag
    ) throws BadStatusCodeError {
        var obj = new GetLogTagVerbosityLevel (
            tag
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        LogVerbosityLevel out_obj;
        switch (tdlib_type) {
            case "logVerbosityLevel":
                out_obj = (LogVerbosityLevel) jsoner.deserialize_object (typeof (LogVerbosityLevel));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns current verbosity level for a specified TDLib internal log
     * tag. Can be called synchronously
     * @param tag Logging tag to change verbosity level
     */
    public async LogVerbosityLevel get_log_tag_verbosity_level (
        string tag
    ) throws BadStatusCodeError {
        var obj = new GetLogTagVerbosityLevel (
            tag
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_log_tag_verbosity_level.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        LogVerbosityLevel out_obj;
        switch (tdlib_type) {
            case "logVerbosityLevel":
                out_obj = (LogVerbosityLevel) jsoner.deserialize_object (typeof (LogVerbosityLevel));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a message to TDLib internal log. Can be called synchronously
     * @param verbosity_level The minimum verbosity level needed for the
     * message to be logged; 0-1023
     * @param text Text of a message to log
     */
    public Ok add_log_message_sync (
        int32 verbosity_level,
        string text
    ) throws BadStatusCodeError {
        var obj = new AddLogMessage (
            verbosity_level,
            text
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Adds a message to TDLib internal log. Can be called synchronously
     * @param verbosity_level The minimum verbosity level needed for the
     * message to be logged; 0-1023
     * @param text Text of a message to log
     */
    public async Ok add_log_message (
        int32 verbosity_level,
        string text
    ) throws BadStatusCodeError {
        var obj = new AddLogMessage (
            verbosity_level,
            text
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_log_message.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns support information for the given user; for Telegram support
     * only
     * @param user_id User identifier
     */
    public async UserSupportInfo get_user_support_info (
        int64 user_id
    ) throws BadStatusCodeError {
        var obj = new GetUserSupportInfo (
            user_id
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_user_support_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        UserSupportInfo out_obj;
        switch (tdlib_type) {
            case "userSupportInfo":
                out_obj = (UserSupportInfo) jsoner.deserialize_object (typeof (UserSupportInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sets support information for the given user; for Telegram support only
     * @param user_id User identifier
     * @param message New information message
     */
    public async UserSupportInfo set_user_support_info (
        int64 user_id,
        FormattedText message
    ) throws BadStatusCodeError {
        var obj = new SetUserSupportInfo (
            user_id,
            message
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_user_support_info.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        UserSupportInfo out_obj;
        switch (tdlib_type) {
            case "userSupportInfo":
                out_obj = (UserSupportInfo) jsoner.deserialize_object (typeof (UserSupportInfo));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns localized name of the Telegram support user; for Telegram
     * support only
     */
    public async Text get_support_name () throws BadStatusCodeError {
        var obj = new GetSupportName ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_support_name.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Text out_obj;
        switch (tdlib_type) {
            case "text":
                out_obj = (Text) jsoner.deserialize_object (typeof (Text));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Does nothing; for testing only. This is an offline method. Can be
     * called before authorization
     */
    public async Ok test_call_empty () throws BadStatusCodeError {
        var obj = new TestCallEmpty ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_call_empty.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the received string; for testing only. This is an offline
     * method. Can be called before authorization
     * @param x String to return
     */
    public async TestString test_call_string (
        string x
    ) throws BadStatusCodeError {
        var obj = new TestCallString (
            x
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_call_string.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        TestString out_obj;
        switch (tdlib_type) {
            case "testString":
                out_obj = (TestString) jsoner.deserialize_object (typeof (TestString));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the received bytes; for testing only. This is an offline
     * method. Can be called before authorization
     * @param x Bytes to return
     */
    public async TestBytes test_call_bytes (
        Bytes x
    ) throws BadStatusCodeError {
        var obj = new TestCallBytes (
            x
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_call_bytes.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        TestBytes out_obj;
        switch (tdlib_type) {
            case "testBytes":
                out_obj = (TestBytes) jsoner.deserialize_object (typeof (TestBytes));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the received vector of numbers; for testing only. This is an
     * offline method. Can be called before authorization
     * @param x Vector of numbers to return
     */
    public async TestVectorInt test_call_vector_int (
        Gee.ArrayList<int32?> x
    ) throws BadStatusCodeError {
        var obj = new TestCallVectorInt (
            x
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_call_vector_int.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        TestVectorInt out_obj;
        switch (tdlib_type) {
            case "testVectorInt":
                out_obj = (TestVectorInt) jsoner.deserialize_object (typeof (TestVectorInt));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the received vector of objects containing a number; for
     * testing only. This is an offline method. Can be called before
     * authorization
     * @param x Vector of objects to return
     */
    public async TestVectorIntObject test_call_vector_int_object (
        Gee.ArrayList<TestInt?> x
    ) throws BadStatusCodeError {
        var obj = new TestCallVectorIntObject (
            x
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_call_vector_int_object.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        TestVectorIntObject out_obj;
        switch (tdlib_type) {
            case "testVectorIntObject":
                out_obj = (TestVectorIntObject) jsoner.deserialize_object (typeof (TestVectorIntObject));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the received vector of strings; for testing only. This is an
     * offline method. Can be called before authorization
     * @param x Vector of strings to return
     */
    public async TestVectorString test_call_vector_string (
        Gee.ArrayList<string?> x
    ) throws BadStatusCodeError {
        var obj = new TestCallVectorString (
            x
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_call_vector_string.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        TestVectorString out_obj;
        switch (tdlib_type) {
            case "testVectorString":
                out_obj = (TestVectorString) jsoner.deserialize_object (typeof (TestVectorString));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the received vector of objects containing a string; for
     * testing only. This is an offline method. Can be called before
     * authorization
     * @param x Vector of objects to return
     */
    public async TestVectorStringObject test_call_vector_string_object (
        Gee.ArrayList<TestString?> x
    ) throws BadStatusCodeError {
        var obj = new TestCallVectorStringObject (
            x
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_call_vector_string_object.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        TestVectorStringObject out_obj;
        switch (tdlib_type) {
            case "testVectorStringObject":
                out_obj = (TestVectorStringObject) jsoner.deserialize_object (typeof (TestVectorStringObject));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the squared received number; for testing only. This is an
     * offline method. Can be called before authorization
     * @param x Number to square
     */
    public async TestInt test_square_int (
        int32 x
    ) throws BadStatusCodeError {
        var obj = new TestSquareInt (
            x
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_square_int.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        TestInt out_obj;
        switch (tdlib_type) {
            case "testInt":
                out_obj = (TestInt) jsoner.deserialize_object (typeof (TestInt));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends a simple network request to the Telegram servers; for testing
     * only. Can be called before authorization
     */
    public async Ok test_network () throws BadStatusCodeError {
        var obj = new TestNetwork ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_network.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Sends a simple network request to the Telegram servers via proxy; for
     * testing only. Can be called before authorization
     * @param server Proxy server domain or IP address
     * @param port Proxy server port
     * @param type_ Proxy type
     * @param dc_id Identifier of a datacenter with which to test connection
     * @param timeout The maximum overall timeout for the request
     */
    public async Ok test_proxy (
        string server,
        int32 port,
        ProxyType type_,
        int32 dc_id,
        double timeout
    ) throws BadStatusCodeError {
        var obj = new TestProxy (
            server,
            port,
            type_,
            dc_id,
            timeout
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_proxy.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Forces an updates.getDifference call to the Telegram servers; for
     * testing only
     */
    public async Ok test_get_difference () throws BadStatusCodeError {
        var obj = new TestGetDifference ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_get_difference.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Ok out_obj;
        switch (tdlib_type) {
            case "ok":
                out_obj = (Ok) jsoner.deserialize_object (typeof (Ok));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Does nothing and ensures that the Update object is used; for testing
     * only. This is an offline method. Can be called before authorization
     */
    public async Update test_use_update () throws BadStatusCodeError {
        var obj = new TestUseUpdate ();
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_use_update.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Update out_obj;
        switch (tdlib_type) {
            case "updateAuthorizationState":
                out_obj = (UpdateAuthorizationState) jsoner.deserialize_object (typeof (UpdateAuthorizationState));
                break;
            case "updateNewMessage":
                out_obj = (UpdateNewMessage) jsoner.deserialize_object (typeof (UpdateNewMessage));
                break;
            case "updateMessageSendAcknowledged":
                out_obj = (UpdateMessageSendAcknowledged) jsoner.deserialize_object (typeof (UpdateMessageSendAcknowledged));
                break;
            case "updateMessageSendSucceeded":
                out_obj = (UpdateMessageSendSucceeded) jsoner.deserialize_object (typeof (UpdateMessageSendSucceeded));
                break;
            case "updateMessageSendFailed":
                out_obj = (UpdateMessageSendFailed) jsoner.deserialize_object (typeof (UpdateMessageSendFailed));
                break;
            case "updateMessageContent":
                out_obj = (UpdateMessageContent) jsoner.deserialize_object (typeof (UpdateMessageContent));
                break;
            case "updateMessageEdited":
                out_obj = (UpdateMessageEdited) jsoner.deserialize_object (typeof (UpdateMessageEdited));
                break;
            case "updateMessageIsPinned":
                out_obj = (UpdateMessageIsPinned) jsoner.deserialize_object (typeof (UpdateMessageIsPinned));
                break;
            case "updateMessageInteractionInfo":
                out_obj = (UpdateMessageInteractionInfo) jsoner.deserialize_object (typeof (UpdateMessageInteractionInfo));
                break;
            case "updateMessageContentOpened":
                out_obj = (UpdateMessageContentOpened) jsoner.deserialize_object (typeof (UpdateMessageContentOpened));
                break;
            case "updateMessageMentionRead":
                out_obj = (UpdateMessageMentionRead) jsoner.deserialize_object (typeof (UpdateMessageMentionRead));
                break;
            case "updateMessageUnreadReactions":
                out_obj = (UpdateMessageUnreadReactions) jsoner.deserialize_object (typeof (UpdateMessageUnreadReactions));
                break;
            case "updateMessageFactCheck":
                out_obj = (UpdateMessageFactCheck) jsoner.deserialize_object (typeof (UpdateMessageFactCheck));
                break;
            case "updateMessageLiveLocationViewed":
                out_obj = (UpdateMessageLiveLocationViewed) jsoner.deserialize_object (typeof (UpdateMessageLiveLocationViewed));
                break;
            case "updateVideoPublished":
                out_obj = (UpdateVideoPublished) jsoner.deserialize_object (typeof (UpdateVideoPublished));
                break;
            case "updateNewChat":
                out_obj = (UpdateNewChat) jsoner.deserialize_object (typeof (UpdateNewChat));
                break;
            case "updateChatTitle":
                out_obj = (UpdateChatTitle) jsoner.deserialize_object (typeof (UpdateChatTitle));
                break;
            case "updateChatPhoto":
                out_obj = (UpdateChatPhoto) jsoner.deserialize_object (typeof (UpdateChatPhoto));
                break;
            case "updateChatAccentColors":
                out_obj = (UpdateChatAccentColors) jsoner.deserialize_object (typeof (UpdateChatAccentColors));
                break;
            case "updateChatPermissions":
                out_obj = (UpdateChatPermissions) jsoner.deserialize_object (typeof (UpdateChatPermissions));
                break;
            case "updateChatLastMessage":
                out_obj = (UpdateChatLastMessage) jsoner.deserialize_object (typeof (UpdateChatLastMessage));
                break;
            case "updateChatPosition":
                out_obj = (UpdateChatPosition) jsoner.deserialize_object (typeof (UpdateChatPosition));
                break;
            case "updateChatAddedToList":
                out_obj = (UpdateChatAddedToList) jsoner.deserialize_object (typeof (UpdateChatAddedToList));
                break;
            case "updateChatRemovedFromList":
                out_obj = (UpdateChatRemovedFromList) jsoner.deserialize_object (typeof (UpdateChatRemovedFromList));
                break;
            case "updateChatReadInbox":
                out_obj = (UpdateChatReadInbox) jsoner.deserialize_object (typeof (UpdateChatReadInbox));
                break;
            case "updateChatReadOutbox":
                out_obj = (UpdateChatReadOutbox) jsoner.deserialize_object (typeof (UpdateChatReadOutbox));
                break;
            case "updateChatActionBar":
                out_obj = (UpdateChatActionBar) jsoner.deserialize_object (typeof (UpdateChatActionBar));
                break;
            case "updateChatBusinessBotManageBar":
                out_obj = (UpdateChatBusinessBotManageBar) jsoner.deserialize_object (typeof (UpdateChatBusinessBotManageBar));
                break;
            case "updateChatAvailableReactions":
                out_obj = (UpdateChatAvailableReactions) jsoner.deserialize_object (typeof (UpdateChatAvailableReactions));
                break;
            case "updateChatDraftMessage":
                out_obj = (UpdateChatDraftMessage) jsoner.deserialize_object (typeof (UpdateChatDraftMessage));
                break;
            case "updateChatEmojiStatus":
                out_obj = (UpdateChatEmojiStatus) jsoner.deserialize_object (typeof (UpdateChatEmojiStatus));
                break;
            case "updateChatMessageSender":
                out_obj = (UpdateChatMessageSender) jsoner.deserialize_object (typeof (UpdateChatMessageSender));
                break;
            case "updateChatMessageAutoDeleteTime":
                out_obj = (UpdateChatMessageAutoDeleteTime) jsoner.deserialize_object (typeof (UpdateChatMessageAutoDeleteTime));
                break;
            case "updateChatNotificationSettings":
                out_obj = (UpdateChatNotificationSettings) jsoner.deserialize_object (typeof (UpdateChatNotificationSettings));
                break;
            case "updateChatPendingJoinRequests":
                out_obj = (UpdateChatPendingJoinRequests) jsoner.deserialize_object (typeof (UpdateChatPendingJoinRequests));
                break;
            case "updateChatReplyMarkup":
                out_obj = (UpdateChatReplyMarkup) jsoner.deserialize_object (typeof (UpdateChatReplyMarkup));
                break;
            case "updateChatBackground":
                out_obj = (UpdateChatBackground) jsoner.deserialize_object (typeof (UpdateChatBackground));
                break;
            case "updateChatTheme":
                out_obj = (UpdateChatTheme) jsoner.deserialize_object (typeof (UpdateChatTheme));
                break;
            case "updateChatUnreadMentionCount":
                out_obj = (UpdateChatUnreadMentionCount) jsoner.deserialize_object (typeof (UpdateChatUnreadMentionCount));
                break;
            case "updateChatUnreadReactionCount":
                out_obj = (UpdateChatUnreadReactionCount) jsoner.deserialize_object (typeof (UpdateChatUnreadReactionCount));
                break;
            case "updateChatVideoChat":
                out_obj = (UpdateChatVideoChat) jsoner.deserialize_object (typeof (UpdateChatVideoChat));
                break;
            case "updateChatDefaultDisableNotification":
                out_obj = (UpdateChatDefaultDisableNotification) jsoner.deserialize_object (typeof (UpdateChatDefaultDisableNotification));
                break;
            case "updateChatHasProtectedContent":
                out_obj = (UpdateChatHasProtectedContent) jsoner.deserialize_object (typeof (UpdateChatHasProtectedContent));
                break;
            case "updateChatIsTranslatable":
                out_obj = (UpdateChatIsTranslatable) jsoner.deserialize_object (typeof (UpdateChatIsTranslatable));
                break;
            case "updateChatIsMarkedAsUnread":
                out_obj = (UpdateChatIsMarkedAsUnread) jsoner.deserialize_object (typeof (UpdateChatIsMarkedAsUnread));
                break;
            case "updateChatViewAsTopics":
                out_obj = (UpdateChatViewAsTopics) jsoner.deserialize_object (typeof (UpdateChatViewAsTopics));
                break;
            case "updateChatBlockList":
                out_obj = (UpdateChatBlockList) jsoner.deserialize_object (typeof (UpdateChatBlockList));
                break;
            case "updateChatHasScheduledMessages":
                out_obj = (UpdateChatHasScheduledMessages) jsoner.deserialize_object (typeof (UpdateChatHasScheduledMessages));
                break;
            case "updateChatFolders":
                out_obj = (UpdateChatFolders) jsoner.deserialize_object (typeof (UpdateChatFolders));
                break;
            case "updateChatOnlineMemberCount":
                out_obj = (UpdateChatOnlineMemberCount) jsoner.deserialize_object (typeof (UpdateChatOnlineMemberCount));
                break;
            case "updateSavedMessagesTopic":
                out_obj = (UpdateSavedMessagesTopic) jsoner.deserialize_object (typeof (UpdateSavedMessagesTopic));
                break;
            case "updateSavedMessagesTopicCount":
                out_obj = (UpdateSavedMessagesTopicCount) jsoner.deserialize_object (typeof (UpdateSavedMessagesTopicCount));
                break;
            case "updateQuickReplyShortcut":
                out_obj = (UpdateQuickReplyShortcut) jsoner.deserialize_object (typeof (UpdateQuickReplyShortcut));
                break;
            case "updateQuickReplyShortcutDeleted":
                out_obj = (UpdateQuickReplyShortcutDeleted) jsoner.deserialize_object (typeof (UpdateQuickReplyShortcutDeleted));
                break;
            case "updateQuickReplyShortcuts":
                out_obj = (UpdateQuickReplyShortcuts) jsoner.deserialize_object (typeof (UpdateQuickReplyShortcuts));
                break;
            case "updateQuickReplyShortcutMessages":
                out_obj = (UpdateQuickReplyShortcutMessages) jsoner.deserialize_object (typeof (UpdateQuickReplyShortcutMessages));
                break;
            case "updateForumTopicInfo":
                out_obj = (UpdateForumTopicInfo) jsoner.deserialize_object (typeof (UpdateForumTopicInfo));
                break;
            case "updateScopeNotificationSettings":
                out_obj = (UpdateScopeNotificationSettings) jsoner.deserialize_object (typeof (UpdateScopeNotificationSettings));
                break;
            case "updateReactionNotificationSettings":
                out_obj = (UpdateReactionNotificationSettings) jsoner.deserialize_object (typeof (UpdateReactionNotificationSettings));
                break;
            case "updateNotification":
                out_obj = (UpdateNotification) jsoner.deserialize_object (typeof (UpdateNotification));
                break;
            case "updateNotificationGroup":
                out_obj = (UpdateNotificationGroup) jsoner.deserialize_object (typeof (UpdateNotificationGroup));
                break;
            case "updateActiveNotifications":
                out_obj = (UpdateActiveNotifications) jsoner.deserialize_object (typeof (UpdateActiveNotifications));
                break;
            case "updateHavePendingNotifications":
                out_obj = (UpdateHavePendingNotifications) jsoner.deserialize_object (typeof (UpdateHavePendingNotifications));
                break;
            case "updateDeleteMessages":
                out_obj = (UpdateDeleteMessages) jsoner.deserialize_object (typeof (UpdateDeleteMessages));
                break;
            case "updateChatAction":
                out_obj = (UpdateChatAction) jsoner.deserialize_object (typeof (UpdateChatAction));
                break;
            case "updateUserStatus":
                out_obj = (UpdateUserStatus) jsoner.deserialize_object (typeof (UpdateUserStatus));
                break;
            case "updateUser":
                out_obj = (UpdateUser) jsoner.deserialize_object (typeof (UpdateUser));
                break;
            case "updateBasicGroup":
                out_obj = (UpdateBasicGroup) jsoner.deserialize_object (typeof (UpdateBasicGroup));
                break;
            case "updateSupergroup":
                out_obj = (UpdateSupergroup) jsoner.deserialize_object (typeof (UpdateSupergroup));
                break;
            case "updateSecretChat":
                out_obj = (UpdateSecretChat) jsoner.deserialize_object (typeof (UpdateSecretChat));
                break;
            case "updateUserFullInfo":
                out_obj = (UpdateUserFullInfo) jsoner.deserialize_object (typeof (UpdateUserFullInfo));
                break;
            case "updateBasicGroupFullInfo":
                out_obj = (UpdateBasicGroupFullInfo) jsoner.deserialize_object (typeof (UpdateBasicGroupFullInfo));
                break;
            case "updateSupergroupFullInfo":
                out_obj = (UpdateSupergroupFullInfo) jsoner.deserialize_object (typeof (UpdateSupergroupFullInfo));
                break;
            case "updateServiceNotification":
                out_obj = (UpdateServiceNotification) jsoner.deserialize_object (typeof (UpdateServiceNotification));
                break;
            case "updateFile":
                out_obj = (UpdateFile) jsoner.deserialize_object (typeof (UpdateFile));
                break;
            case "updateFileGenerationStart":
                out_obj = (UpdateFileGenerationStart) jsoner.deserialize_object (typeof (UpdateFileGenerationStart));
                break;
            case "updateFileGenerationStop":
                out_obj = (UpdateFileGenerationStop) jsoner.deserialize_object (typeof (UpdateFileGenerationStop));
                break;
            case "updateFileDownloads":
                out_obj = (UpdateFileDownloads) jsoner.deserialize_object (typeof (UpdateFileDownloads));
                break;
            case "updateFileAddedToDownloads":
                out_obj = (UpdateFileAddedToDownloads) jsoner.deserialize_object (typeof (UpdateFileAddedToDownloads));
                break;
            case "updateFileDownload":
                out_obj = (UpdateFileDownload) jsoner.deserialize_object (typeof (UpdateFileDownload));
                break;
            case "updateFileRemovedFromDownloads":
                out_obj = (UpdateFileRemovedFromDownloads) jsoner.deserialize_object (typeof (UpdateFileRemovedFromDownloads));
                break;
            case "updateApplicationVerificationRequired":
                out_obj = (UpdateApplicationVerificationRequired) jsoner.deserialize_object (typeof (UpdateApplicationVerificationRequired));
                break;
            case "updateCall":
                out_obj = (UpdateCall) jsoner.deserialize_object (typeof (UpdateCall));
                break;
            case "updateGroupCall":
                out_obj = (UpdateGroupCall) jsoner.deserialize_object (typeof (UpdateGroupCall));
                break;
            case "updateGroupCallParticipant":
                out_obj = (UpdateGroupCallParticipant) jsoner.deserialize_object (typeof (UpdateGroupCallParticipant));
                break;
            case "updateNewCallSignalingData":
                out_obj = (UpdateNewCallSignalingData) jsoner.deserialize_object (typeof (UpdateNewCallSignalingData));
                break;
            case "updateUserPrivacySettingRules":
                out_obj = (UpdateUserPrivacySettingRules) jsoner.deserialize_object (typeof (UpdateUserPrivacySettingRules));
                break;
            case "updateUnreadMessageCount":
                out_obj = (UpdateUnreadMessageCount) jsoner.deserialize_object (typeof (UpdateUnreadMessageCount));
                break;
            case "updateUnreadChatCount":
                out_obj = (UpdateUnreadChatCount) jsoner.deserialize_object (typeof (UpdateUnreadChatCount));
                break;
            case "updateStory":
                out_obj = (UpdateStory) jsoner.deserialize_object (typeof (UpdateStory));
                break;
            case "updateStoryDeleted":
                out_obj = (UpdateStoryDeleted) jsoner.deserialize_object (typeof (UpdateStoryDeleted));
                break;
            case "updateStorySendSucceeded":
                out_obj = (UpdateStorySendSucceeded) jsoner.deserialize_object (typeof (UpdateStorySendSucceeded));
                break;
            case "updateStorySendFailed":
                out_obj = (UpdateStorySendFailed) jsoner.deserialize_object (typeof (UpdateStorySendFailed));
                break;
            case "updateChatActiveStories":
                out_obj = (UpdateChatActiveStories) jsoner.deserialize_object (typeof (UpdateChatActiveStories));
                break;
            case "updateStoryListChatCount":
                out_obj = (UpdateStoryListChatCount) jsoner.deserialize_object (typeof (UpdateStoryListChatCount));
                break;
            case "updateStoryStealthMode":
                out_obj = (UpdateStoryStealthMode) jsoner.deserialize_object (typeof (UpdateStoryStealthMode));
                break;
            case "updateOption":
                out_obj = (UpdateOption) jsoner.deserialize_object (typeof (UpdateOption));
                break;
            case "updateStickerSet":
                out_obj = (UpdateStickerSet) jsoner.deserialize_object (typeof (UpdateStickerSet));
                break;
            case "updateInstalledStickerSets":
                out_obj = (UpdateInstalledStickerSets) jsoner.deserialize_object (typeof (UpdateInstalledStickerSets));
                break;
            case "updateTrendingStickerSets":
                out_obj = (UpdateTrendingStickerSets) jsoner.deserialize_object (typeof (UpdateTrendingStickerSets));
                break;
            case "updateRecentStickers":
                out_obj = (UpdateRecentStickers) jsoner.deserialize_object (typeof (UpdateRecentStickers));
                break;
            case "updateFavoriteStickers":
                out_obj = (UpdateFavoriteStickers) jsoner.deserialize_object (typeof (UpdateFavoriteStickers));
                break;
            case "updateSavedAnimations":
                out_obj = (UpdateSavedAnimations) jsoner.deserialize_object (typeof (UpdateSavedAnimations));
                break;
            case "updateSavedNotificationSounds":
                out_obj = (UpdateSavedNotificationSounds) jsoner.deserialize_object (typeof (UpdateSavedNotificationSounds));
                break;
            case "updateDefaultBackground":
                out_obj = (UpdateDefaultBackground) jsoner.deserialize_object (typeof (UpdateDefaultBackground));
                break;
            case "updateChatThemes":
                out_obj = (UpdateChatThemes) jsoner.deserialize_object (typeof (UpdateChatThemes));
                break;
            case "updateAccentColors":
                out_obj = (UpdateAccentColors) jsoner.deserialize_object (typeof (UpdateAccentColors));
                break;
            case "updateProfileAccentColors":
                out_obj = (UpdateProfileAccentColors) jsoner.deserialize_object (typeof (UpdateProfileAccentColors));
                break;
            case "updateLanguagePackStrings":
                out_obj = (UpdateLanguagePackStrings) jsoner.deserialize_object (typeof (UpdateLanguagePackStrings));
                break;
            case "updateConnectionState":
                out_obj = (UpdateConnectionState) jsoner.deserialize_object (typeof (UpdateConnectionState));
                break;
            case "updateTermsOfService":
                out_obj = (UpdateTermsOfService) jsoner.deserialize_object (typeof (UpdateTermsOfService));
                break;
            case "updateUnconfirmedSession":
                out_obj = (UpdateUnconfirmedSession) jsoner.deserialize_object (typeof (UpdateUnconfirmedSession));
                break;
            case "updateAttachmentMenuBots":
                out_obj = (UpdateAttachmentMenuBots) jsoner.deserialize_object (typeof (UpdateAttachmentMenuBots));
                break;
            case "updateWebAppMessageSent":
                out_obj = (UpdateWebAppMessageSent) jsoner.deserialize_object (typeof (UpdateWebAppMessageSent));
                break;
            case "updateActiveEmojiReactions":
                out_obj = (UpdateActiveEmojiReactions) jsoner.deserialize_object (typeof (UpdateActiveEmojiReactions));
                break;
            case "updateAvailableMessageEffects":
                out_obj = (UpdateAvailableMessageEffects) jsoner.deserialize_object (typeof (UpdateAvailableMessageEffects));
                break;
            case "updateDefaultReactionType":
                out_obj = (UpdateDefaultReactionType) jsoner.deserialize_object (typeof (UpdateDefaultReactionType));
                break;
            case "updateSavedMessagesTags":
                out_obj = (UpdateSavedMessagesTags) jsoner.deserialize_object (typeof (UpdateSavedMessagesTags));
                break;
            case "updateActiveLiveLocationMessages":
                out_obj = (UpdateActiveLiveLocationMessages) jsoner.deserialize_object (typeof (UpdateActiveLiveLocationMessages));
                break;
            case "updateOwnedStarCount":
                out_obj = (UpdateOwnedStarCount) jsoner.deserialize_object (typeof (UpdateOwnedStarCount));
                break;
            case "updateChatRevenueAmount":
                out_obj = (UpdateChatRevenueAmount) jsoner.deserialize_object (typeof (UpdateChatRevenueAmount));
                break;
            case "updateStarRevenueStatus":
                out_obj = (UpdateStarRevenueStatus) jsoner.deserialize_object (typeof (UpdateStarRevenueStatus));
                break;
            case "updateSpeechRecognitionTrial":
                out_obj = (UpdateSpeechRecognitionTrial) jsoner.deserialize_object (typeof (UpdateSpeechRecognitionTrial));
                break;
            case "updateDiceEmojis":
                out_obj = (UpdateDiceEmojis) jsoner.deserialize_object (typeof (UpdateDiceEmojis));
                break;
            case "updateAnimatedEmojiMessageClicked":
                out_obj = (UpdateAnimatedEmojiMessageClicked) jsoner.deserialize_object (typeof (UpdateAnimatedEmojiMessageClicked));
                break;
            case "updateAnimationSearchParameters":
                out_obj = (UpdateAnimationSearchParameters) jsoner.deserialize_object (typeof (UpdateAnimationSearchParameters));
                break;
            case "updateSuggestedActions":
                out_obj = (UpdateSuggestedActions) jsoner.deserialize_object (typeof (UpdateSuggestedActions));
                break;
            case "updateSpeedLimitNotification":
                out_obj = (UpdateSpeedLimitNotification) jsoner.deserialize_object (typeof (UpdateSpeedLimitNotification));
                break;
            case "updateContactCloseBirthdays":
                out_obj = (UpdateContactCloseBirthdays) jsoner.deserialize_object (typeof (UpdateContactCloseBirthdays));
                break;
            case "updateAutosaveSettings":
                out_obj = (UpdateAutosaveSettings) jsoner.deserialize_object (typeof (UpdateAutosaveSettings));
                break;
            case "updateBusinessConnection":
                out_obj = (UpdateBusinessConnection) jsoner.deserialize_object (typeof (UpdateBusinessConnection));
                break;
            case "updateNewBusinessMessage":
                out_obj = (UpdateNewBusinessMessage) jsoner.deserialize_object (typeof (UpdateNewBusinessMessage));
                break;
            case "updateBusinessMessageEdited":
                out_obj = (UpdateBusinessMessageEdited) jsoner.deserialize_object (typeof (UpdateBusinessMessageEdited));
                break;
            case "updateBusinessMessagesDeleted":
                out_obj = (UpdateBusinessMessagesDeleted) jsoner.deserialize_object (typeof (UpdateBusinessMessagesDeleted));
                break;
            case "updateNewInlineQuery":
                out_obj = (UpdateNewInlineQuery) jsoner.deserialize_object (typeof (UpdateNewInlineQuery));
                break;
            case "updateNewChosenInlineResult":
                out_obj = (UpdateNewChosenInlineResult) jsoner.deserialize_object (typeof (UpdateNewChosenInlineResult));
                break;
            case "updateNewCallbackQuery":
                out_obj = (UpdateNewCallbackQuery) jsoner.deserialize_object (typeof (UpdateNewCallbackQuery));
                break;
            case "updateNewInlineCallbackQuery":
                out_obj = (UpdateNewInlineCallbackQuery) jsoner.deserialize_object (typeof (UpdateNewInlineCallbackQuery));
                break;
            case "updateNewBusinessCallbackQuery":
                out_obj = (UpdateNewBusinessCallbackQuery) jsoner.deserialize_object (typeof (UpdateNewBusinessCallbackQuery));
                break;
            case "updateNewShippingQuery":
                out_obj = (UpdateNewShippingQuery) jsoner.deserialize_object (typeof (UpdateNewShippingQuery));
                break;
            case "updateNewPreCheckoutQuery":
                out_obj = (UpdateNewPreCheckoutQuery) jsoner.deserialize_object (typeof (UpdateNewPreCheckoutQuery));
                break;
            case "updateNewCustomEvent":
                out_obj = (UpdateNewCustomEvent) jsoner.deserialize_object (typeof (UpdateNewCustomEvent));
                break;
            case "updateNewCustomQuery":
                out_obj = (UpdateNewCustomQuery) jsoner.deserialize_object (typeof (UpdateNewCustomQuery));
                break;
            case "updatePoll":
                out_obj = (UpdatePoll) jsoner.deserialize_object (typeof (UpdatePoll));
                break;
            case "updatePollAnswer":
                out_obj = (UpdatePollAnswer) jsoner.deserialize_object (typeof (UpdatePollAnswer));
                break;
            case "updateChatMember":
                out_obj = (UpdateChatMember) jsoner.deserialize_object (typeof (UpdateChatMember));
                break;
            case "updateNewChatJoinRequest":
                out_obj = (UpdateNewChatJoinRequest) jsoner.deserialize_object (typeof (UpdateNewChatJoinRequest));
                break;
            case "updateChatBoost":
                out_obj = (UpdateChatBoost) jsoner.deserialize_object (typeof (UpdateChatBoost));
                break;
            case "updateMessageReaction":
                out_obj = (UpdateMessageReaction) jsoner.deserialize_object (typeof (UpdateMessageReaction));
                break;
            case "updateMessageReactions":
                out_obj = (UpdateMessageReactions) jsoner.deserialize_object (typeof (UpdateMessageReactions));
                break;
            case "updatePaidMediaPurchased":
                out_obj = (UpdatePaidMediaPurchased) jsoner.deserialize_object (typeof (UpdatePaidMediaPurchased));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the specified error and ensures that the Error object is used;
     * for testing only. Can be called synchronously
     * @param error The error to be returned
     */
    public Error test_return_error_sync (
        Error error
    ) throws BadStatusCodeError {
        var obj = new TestReturnError (
            error
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);
        
        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Error out_obj;
        switch (tdlib_type) {
            case "error":
                out_obj = (Error) jsoner.deserialize_object (typeof (Error));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }

    /**
     * Returns the specified error and ensures that the Error object is used;
     * for testing only. Can be called synchronously
     * @param error The error to be returned
     */
    public async Error test_return_error (
        Error error
    ) throws BadStatusCodeError {
        var obj = new TestReturnError (
            error
        );
        string json_response = "";

        string json_string = yield TDJsoner.serialize_async (obj, Case.SNAKE);
        
        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_return_error.callback);
            }    
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();
        
        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new BadStatusCodeError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);

        Error out_obj;
        switch (tdlib_type) {
            case "error":
                out_obj = (Error) jsoner.deserialize_object (typeof (Error));
                break;
            default:
                assert_not_reached ();
        }

        return out_obj;
    }
}