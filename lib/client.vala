/*
 * Copyright (C) 2024-2025 Vladimir Vaskov
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

// THIS FILE WAS GENERATED, DON'T MODIFY IT

public sealed class TDLib.Client : Object {

    public int client_id { get; private set; }

    internal RequestManager request_manager { get; set; }

    public double timeout { get; construct set; }

    public string version { get; set; }
    public signal void update_recieved (Update update);
    /**
     * @param timeout Base timeout
     */
    public Client (double timeout = 1.0) {
        Object (timeout: timeout);
    }

    ~Client () {
        if (request_manager != null) {
            request_manager.stop ();
        }
    }

    static construct {
        typeof (Error).ensure ();
        typeof (Ok).ensure ();
        typeof (AuthenticationCodeTypeTelegramMessage).ensure ();
        typeof (AuthenticationCodeTypeSms).ensure ();
        typeof (AuthenticationCodeTypeSmsWord).ensure ();
        typeof (AuthenticationCodeTypeSmsPhrase).ensure ();
        typeof (AuthenticationCodeTypeCall).ensure ();
        typeof (AuthenticationCodeTypeFlashCall).ensure ();
        typeof (AuthenticationCodeTypeMissedCall).ensure ();
        typeof (AuthenticationCodeTypeFragment).ensure ();
        typeof (AuthenticationCodeTypeFirebaseAndroid).ensure ();
        typeof (AuthenticationCodeTypeFirebaseIos).ensure ();
        typeof (AuthenticationCodeInfo).ensure ();
        typeof (EmailAddressAuthenticationCodeInfo).ensure ();
        typeof (EmailAddressAuthenticationCode).ensure ();
        typeof (EmailAddressAuthenticationAppleId).ensure ();
        typeof (EmailAddressAuthenticationGoogleId).ensure ();
        typeof (EmailAddressResetStateAvailable).ensure ();
        typeof (EmailAddressResetStatePending).ensure ();
        typeof (TextEntity).ensure ();
        typeof (TextEntities).ensure ();
        typeof (FormattedText).ensure ();
        typeof (TermsOfService).ensure ();
        typeof (AuthorizationStateWaitTdlibParameters).ensure ();
        typeof (AuthorizationStateWaitPhoneNumber).ensure ();
        typeof (AuthorizationStateWaitEmailAddress).ensure ();
        typeof (AuthorizationStateWaitEmailCode).ensure ();
        typeof (AuthorizationStateWaitCode).ensure ();
        typeof (AuthorizationStateWaitOtherDeviceConfirmation).ensure ();
        typeof (AuthorizationStateWaitRegistration).ensure ();
        typeof (AuthorizationStateWaitPassword).ensure ();
        typeof (AuthorizationStateReady).ensure ();
        typeof (AuthorizationStateLoggingOut).ensure ();
        typeof (AuthorizationStateClosing).ensure ();
        typeof (AuthorizationStateClosed).ensure ();
        typeof (FirebaseDeviceVerificationParametersSafetyNet).ensure ();
        typeof (FirebaseDeviceVerificationParametersPlayIntegrity).ensure ();
        typeof (PasswordState).ensure ();
        typeof (RecoveryEmailAddress).ensure ();
        typeof (TemporaryPasswordState).ensure ();
        typeof (LocalFile).ensure ();
        typeof (RemoteFile).ensure ();
        typeof (File).ensure ();
        typeof (InputFileId).ensure ();
        typeof (InputFileRemote).ensure ();
        typeof (InputFileLocal).ensure ();
        typeof (InputFileGenerated).ensure ();
        typeof (PhotoSize).ensure ();
        typeof (Minithumbnail).ensure ();
        typeof (ThumbnailFormatJpeg).ensure ();
        typeof (ThumbnailFormatGif).ensure ();
        typeof (ThumbnailFormatMpeg4).ensure ();
        typeof (ThumbnailFormatPng).ensure ();
        typeof (ThumbnailFormatTgs).ensure ();
        typeof (ThumbnailFormatWebm).ensure ();
        typeof (ThumbnailFormatWebp).ensure ();
        typeof (Thumbnail).ensure ();
        typeof (MaskPointForehead).ensure ();
        typeof (MaskPointEyes).ensure ();
        typeof (MaskPointMouth).ensure ();
        typeof (MaskPointChin).ensure ();
        typeof (MaskPosition).ensure ();
        typeof (StickerFormatWebp).ensure ();
        typeof (StickerFormatTgs).ensure ();
        typeof (StickerFormatWebm).ensure ();
        typeof (StickerTypeRegular).ensure ();
        typeof (StickerTypeMask).ensure ();
        typeof (StickerTypeCustomEmoji).ensure ();
        typeof (StickerFullTypeRegular).ensure ();
        typeof (StickerFullTypeMask).ensure ();
        typeof (StickerFullTypeCustomEmoji).ensure ();
        typeof (ClosedVectorPath).ensure ();
        typeof (Outline).ensure ();
        typeof (PollOption).ensure ();
        typeof (PollTypeRegular).ensure ();
        typeof (PollTypeQuiz).ensure ();
        typeof (Animation).ensure ();
        typeof (Audio).ensure ();
        typeof (Document).ensure ();
        typeof (Photo).ensure ();
        typeof (Sticker).ensure ();
        typeof (Video).ensure ();
        typeof (VideoNote).ensure ();
        typeof (VoiceNote).ensure ();
        typeof (AnimatedEmoji).ensure ();
        typeof (Contact).ensure ();
        typeof (Location).ensure ();
        typeof (Venue).ensure ();
        typeof (Game).ensure ();
        typeof (WebApp).ensure ();
        typeof (Poll).ensure ();
        typeof (AlternativeVideo).ensure ();
        typeof (Background).ensure ();
        typeof (Backgrounds).ensure ();
        typeof (ChatBackground).ensure ();
        typeof (ProfilePhoto).ensure ();
        typeof (ChatPhotoInfo).ensure ();
        typeof (UserTypeRegular).ensure ();
        typeof (UserTypeDeleted).ensure ();
        typeof (UserTypeBot).ensure ();
        typeof (UserTypeUnknown).ensure ();
        typeof (BotCommand).ensure ();
        typeof (BotCommands).ensure ();
        typeof (BotMenuButton).ensure ();
        typeof (BotVerificationParameters).ensure ();
        typeof (BotVerification).ensure ();
        typeof (VerificationStatus).ensure ();
        typeof (ChatLocation).ensure ();
        typeof (Birthdate).ensure ();
        typeof (CloseBirthdayUser).ensure ();
        typeof (BusinessAwayMessageScheduleAlways).ensure ();
        typeof (BusinessAwayMessageScheduleOutsideOfOpeningHours).ensure ();
        typeof (BusinessAwayMessageScheduleCustom).ensure ();
        typeof (BusinessLocation).ensure ();
        typeof (BusinessRecipients).ensure ();
        typeof (BusinessAwayMessageSettings).ensure ();
        typeof (BusinessGreetingMessageSettings).ensure ();
        typeof (BusinessConnectedBot).ensure ();
        typeof (BusinessStartPage).ensure ();
        typeof (InputBusinessStartPage).ensure ();
        typeof (BusinessOpeningHoursInterval).ensure ();
        typeof (BusinessOpeningHours).ensure ();
        typeof (BusinessInfo).ensure ();
        typeof (BusinessChatLink).ensure ();
        typeof (BusinessChatLinks).ensure ();
        typeof (InputBusinessChatLink).ensure ();
        typeof (BusinessChatLinkInfo).ensure ();
        typeof (ChatPhotoStickerTypeRegularOrMask).ensure ();
        typeof (ChatPhotoStickerTypeCustomEmoji).ensure ();
        typeof (ChatPhotoSticker).ensure ();
        typeof (AnimatedChatPhoto).ensure ();
        typeof (ChatPhoto).ensure ();
        typeof (ChatPhotos).ensure ();
        typeof (InputChatPhotoPrevious).ensure ();
        typeof (InputChatPhotoStatic).ensure ();
        typeof (InputChatPhotoAnimation).ensure ();
        typeof (InputChatPhotoSticker).ensure ();
        typeof (ChatPermissions).ensure ();
        typeof (ChatAdministratorRights).ensure ();
        typeof (StarAmount).ensure ();
        typeof (StarSubscriptionTypeChannel).ensure ();
        typeof (StarSubscriptionTypeBot).ensure ();
        typeof (StarSubscriptionPricing).ensure ();
        typeof (StarSubscription).ensure ();
        typeof (StarSubscriptions).ensure ();
        typeof (AffiliateTypeCurrentUser).ensure ();
        typeof (AffiliateTypeBot).ensure ();
        typeof (AffiliateTypeChannel).ensure ();
        typeof (AffiliateProgramSortOrderProfitability).ensure ();
        typeof (AffiliateProgramSortOrderCreationDate).ensure ();
        typeof (AffiliateProgramSortOrderRevenue).ensure ();
        typeof (AffiliateProgramParameters).ensure ();
        typeof (AffiliateProgramInfo).ensure ();
        typeof (AffiliateInfo).ensure ();
        typeof (FoundAffiliateProgram).ensure ();
        typeof (FoundAffiliatePrograms).ensure ();
        typeof (ConnectedAffiliateProgram).ensure ();
        typeof (ConnectedAffiliatePrograms).ensure ();
        typeof (ProductInfo).ensure ();
        typeof (PremiumPaymentOption).ensure ();
        typeof (PremiumStatePaymentOption).ensure ();
        typeof (PremiumGiftCodePaymentOption).ensure ();
        typeof (PremiumGiftCodePaymentOptions).ensure ();
        typeof (PremiumGiftCodeInfo).ensure ();
        typeof (StarPaymentOption).ensure ();
        typeof (StarPaymentOptions).ensure ();
        typeof (StarGiveawayWinnerOption).ensure ();
        typeof (StarGiveawayPaymentOption).ensure ();
        typeof (StarGiveawayPaymentOptions).ensure ();
        typeof (UpgradedGiftModel).ensure ();
        typeof (UpgradedGiftSymbol).ensure ();
        typeof (UpgradedGiftBackdropColors).ensure ();
        typeof (UpgradedGiftBackdrop).ensure ();
        typeof (UpgradedGiftOriginalDetails).ensure ();
        typeof (Gift).ensure ();
        typeof (Gifts).ensure ();
        typeof (UpgradedGift).ensure ();
        typeof (UpgradeGiftResult).ensure ();
        typeof (SentGiftRegular).ensure ();
        typeof (SentGiftUpgraded).ensure ();
        typeof (ReceivedGift).ensure ();
        typeof (ReceivedGifts).ensure ();
        typeof (GiftUpgradePreview).ensure ();
        typeof (StarTransactionDirectionIncoming).ensure ();
        typeof (StarTransactionDirectionOutgoing).ensure ();
        typeof (StarTransactionTypePremiumBotDeposit).ensure ();
        typeof (StarTransactionTypeAppStoreDeposit).ensure ();
        typeof (StarTransactionTypeGooglePlayDeposit).ensure ();
        typeof (StarTransactionTypeFragmentDeposit).ensure ();
        typeof (StarTransactionTypeUserDeposit).ensure ();
        typeof (StarTransactionTypeGiveawayDeposit).ensure ();
        typeof (StarTransactionTypeFragmentWithdrawal).ensure ();
        typeof (StarTransactionTypeTelegramAdsWithdrawal).ensure ();
        typeof (StarTransactionTypeTelegramApiUsage).ensure ();
        typeof (StarTransactionTypeBotPaidMediaPurchase).ensure ();
        typeof (StarTransactionTypeBotPaidMediaSale).ensure ();
        typeof (StarTransactionTypeChannelPaidMediaPurchase).ensure ();
        typeof (StarTransactionTypeChannelPaidMediaSale).ensure ();
        typeof (StarTransactionTypeBotInvoicePurchase).ensure ();
        typeof (StarTransactionTypeBotInvoiceSale).ensure ();
        typeof (StarTransactionTypeBotSubscriptionPurchase).ensure ();
        typeof (StarTransactionTypeBotSubscriptionSale).ensure ();
        typeof (StarTransactionTypeChannelSubscriptionPurchase).ensure ();
        typeof (StarTransactionTypeChannelSubscriptionSale).ensure ();
        typeof (StarTransactionTypeGiftPurchase).ensure ();
        typeof (StarTransactionTypeGiftTransfer).ensure ();
        typeof (StarTransactionTypeGiftSale).ensure ();
        typeof (StarTransactionTypeGiftUpgrade).ensure ();
        typeof (StarTransactionTypeChannelPaidReactionSend).ensure ();
        typeof (StarTransactionTypeChannelPaidReactionReceive).ensure ();
        typeof (StarTransactionTypeAffiliateProgramCommission).ensure ();
        typeof (StarTransactionTypeUnsupported).ensure ();
        typeof (StarTransaction).ensure ();
        typeof (StarTransactions).ensure ();
        typeof (GiveawayParticipantStatusEligible).ensure ();
        typeof (GiveawayParticipantStatusParticipating).ensure ();
        typeof (GiveawayParticipantStatusAlreadyWasMember).ensure ();
        typeof (GiveawayParticipantStatusAdministrator).ensure ();
        typeof (GiveawayParticipantStatusDisallowedCountry).ensure ();
        typeof (GiveawayInfoOngoing).ensure ();
        typeof (GiveawayInfoCompleted).ensure ();
        typeof (GiveawayPrizePremium).ensure ();
        typeof (GiveawayPrizeStars).ensure ();
        typeof (AccentColor).ensure ();
        typeof (ProfileAccentColors).ensure ();
        typeof (ProfileAccentColor).ensure ();
        typeof (EmojiStatusTypeCustomEmoji).ensure ();
        typeof (EmojiStatusTypeUpgradedGift).ensure ();
        typeof (EmojiStatus).ensure ();
        typeof (EmojiStatuses).ensure ();
        typeof (EmojiStatusCustomEmojis).ensure ();
        typeof (Usernames).ensure ();
        typeof (User).ensure ();
        typeof (BotInfo).ensure ();
        typeof (UserFullInfo).ensure ();
        typeof (Users).ensure ();
        typeof (FoundUsers).ensure ();
        typeof (ChatAdministrator).ensure ();
        typeof (ChatAdministrators).ensure ();
        typeof (ChatMemberStatusCreator).ensure ();
        typeof (ChatMemberStatusAdministrator).ensure ();
        typeof (ChatMemberStatusMember).ensure ();
        typeof (ChatMemberStatusRestricted).ensure ();
        typeof (ChatMemberStatusLeft).ensure ();
        typeof (ChatMemberStatusBanned).ensure ();
        typeof (ChatMember).ensure ();
        typeof (ChatMembers).ensure ();
        typeof (ChatMembersFilterContacts).ensure ();
        typeof (ChatMembersFilterAdministrators).ensure ();
        typeof (ChatMembersFilterMembers).ensure ();
        typeof (ChatMembersFilterMention).ensure ();
        typeof (ChatMembersFilterRestricted).ensure ();
        typeof (ChatMembersFilterBanned).ensure ();
        typeof (ChatMembersFilterBots).ensure ();
        typeof (SupergroupMembersFilterRecent).ensure ();
        typeof (SupergroupMembersFilterContacts).ensure ();
        typeof (SupergroupMembersFilterAdministrators).ensure ();
        typeof (SupergroupMembersFilterSearch).ensure ();
        typeof (SupergroupMembersFilterRestricted).ensure ();
        typeof (SupergroupMembersFilterBanned).ensure ();
        typeof (SupergroupMembersFilterMention).ensure ();
        typeof (SupergroupMembersFilterBots).ensure ();
        typeof (ChatInviteLink).ensure ();
        typeof (ChatInviteLinks).ensure ();
        typeof (ChatInviteLinkCount).ensure ();
        typeof (ChatInviteLinkCounts).ensure ();
        typeof (ChatInviteLinkMember).ensure ();
        typeof (ChatInviteLinkMembers).ensure ();
        typeof (InviteLinkChatTypeBasicGroup).ensure ();
        typeof (InviteLinkChatTypeSupergroup).ensure ();
        typeof (InviteLinkChatTypeChannel).ensure ();
        typeof (ChatInviteLinkSubscriptionInfo).ensure ();
        typeof (ChatInviteLinkInfo).ensure ();
        typeof (ChatJoinRequest).ensure ();
        typeof (ChatJoinRequests).ensure ();
        typeof (ChatJoinRequestsInfo).ensure ();
        typeof (BasicGroup).ensure ();
        typeof (BasicGroupFullInfo).ensure ();
        typeof (Supergroup).ensure ();
        typeof (SupergroupFullInfo).ensure ();
        typeof (SecretChatStatePending).ensure ();
        typeof (SecretChatStateReady).ensure ();
        typeof (SecretChatStateClosed).ensure ();
        typeof (SecretChat).ensure ();
        typeof (MessageSenderUser).ensure ();
        typeof (MessageSenderChat).ensure ();
        typeof (MessageSenders).ensure ();
        typeof (ChatMessageSender).ensure ();
        typeof (ChatMessageSenders).ensure ();
        typeof (MessageReadDateRead).ensure ();
        typeof (MessageReadDateUnread).ensure ();
        typeof (MessageReadDateTooOld).ensure ();
        typeof (MessageReadDateUserPrivacyRestricted).ensure ();
        typeof (MessageReadDateMyPrivacyRestricted).ensure ();
        typeof (MessageViewer).ensure ();
        typeof (MessageViewers).ensure ();
        typeof (MessageOriginUser).ensure ();
        typeof (MessageOriginHiddenUser).ensure ();
        typeof (MessageOriginChat).ensure ();
        typeof (MessageOriginChannel).ensure ();
        typeof (ForwardSource).ensure ();
        typeof (ReactionTypeEmoji).ensure ();
        typeof (ReactionTypeCustomEmoji).ensure ();
        typeof (ReactionTypePaid).ensure ();
        typeof (PaidReactionTypeRegular).ensure ();
        typeof (PaidReactionTypeAnonymous).ensure ();
        typeof (PaidReactionTypeChat).ensure ();
        typeof (PaidReactor).ensure ();
        typeof (MessageForwardInfo).ensure ();
        typeof (MessageImportInfo).ensure ();
        typeof (MessageReplyInfo).ensure ();
        typeof (MessageReaction).ensure ();
        typeof (MessageReactions).ensure ();
        typeof (MessageInteractionInfo).ensure ();
        typeof (UnreadReaction).ensure ();
        typeof (MessageEffectTypeEmojiReaction).ensure ();
        typeof (MessageEffectTypePremiumSticker).ensure ();
        typeof (MessageEffect).ensure ();
        typeof (MessageSendingStatePending).ensure ();
        typeof (MessageSendingStateFailed).ensure ();
        typeof (TextQuote).ensure ();
        typeof (InputTextQuote).ensure ();
        typeof (MessageReplyToMessage).ensure ();
        typeof (MessageReplyToStory).ensure ();
        typeof (InputMessageReplyToMessage).ensure ();
        typeof (InputMessageReplyToExternalMessage).ensure ();
        typeof (InputMessageReplyToStory).ensure ();
        typeof (FactCheck).ensure ();
        typeof (Message).ensure ();
        typeof (Messages).ensure ();
        typeof (FoundMessages).ensure ();
        typeof (FoundChatMessages).ensure ();
        typeof (MessagePosition).ensure ();
        typeof (MessagePositions).ensure ();
        typeof (MessageCalendarDay).ensure ();
        typeof (MessageCalendar).ensure ();
        typeof (BusinessMessage).ensure ();
        typeof (BusinessMessages).ensure ();
        typeof (MessageSourceChatHistory).ensure ();
        typeof (MessageSourceMessageThreadHistory).ensure ();
        typeof (MessageSourceForumTopicHistory).ensure ();
        typeof (MessageSourceHistoryPreview).ensure ();
        typeof (MessageSourceChatList).ensure ();
        typeof (MessageSourceSearch).ensure ();
        typeof (MessageSourceChatEventLog).ensure ();
        typeof (MessageSourceNotification).ensure ();
        typeof (MessageSourceScreenshot).ensure ();
        typeof (MessageSourceOther).ensure ();
        typeof (MessageSponsor).ensure ();
        typeof (SponsoredMessage).ensure ();
        typeof (SponsoredMessages).ensure ();
        typeof (ReportOption).ensure ();
        typeof (ReportChatSponsoredMessageResultOk).ensure ();
        typeof (ReportChatSponsoredMessageResultFailed).ensure ();
        typeof (ReportChatSponsoredMessageResultOptionRequired).ensure ();
        typeof (ReportChatSponsoredMessageResultAdsHidden).ensure ();
        typeof (ReportChatSponsoredMessageResultPremiumRequired).ensure ();
        typeof (FileDownload).ensure ();
        typeof (DownloadedFileCounts).ensure ();
        typeof (FoundFileDownloads).ensure ();
        typeof (NotificationSettingsScopePrivateChats).ensure ();
        typeof (NotificationSettingsScopeGroupChats).ensure ();
        typeof (NotificationSettingsScopeChannelChats).ensure ();
        typeof (ChatNotificationSettings).ensure ();
        typeof (ScopeNotificationSettings).ensure ();
        typeof (ReactionNotificationSourceNone).ensure ();
        typeof (ReactionNotificationSourceContacts).ensure ();
        typeof (ReactionNotificationSourceAll).ensure ();
        typeof (ReactionNotificationSettings).ensure ();
        typeof (DraftMessage).ensure ();
        typeof (ChatTypePrivate).ensure ();
        typeof (ChatTypeBasicGroup).ensure ();
        typeof (ChatTypeSupergroup).ensure ();
        typeof (ChatTypeSecret).ensure ();
        typeof (ChatFolderIcon).ensure ();
        typeof (ChatFolderName).ensure ();
        typeof (ChatFolder).ensure ();
        typeof (ChatFolderInfo).ensure ();
        typeof (ChatFolderInviteLink).ensure ();
        typeof (ChatFolderInviteLinks).ensure ();
        typeof (ChatFolderInviteLinkInfo).ensure ();
        typeof (RecommendedChatFolder).ensure ();
        typeof (RecommendedChatFolders).ensure ();
        typeof (ArchiveChatListSettings).ensure ();
        typeof (ChatListMain).ensure ();
        typeof (ChatListArchive).ensure ();
        typeof (ChatListFolder).ensure ();
        typeof (ChatLists).ensure ();
        typeof (ChatSourceMtprotoProxy).ensure ();
        typeof (ChatSourcePublicServiceAnnouncement).ensure ();
        typeof (ChatPosition).ensure ();
        typeof (ChatAvailableReactionsAll).ensure ();
        typeof (ChatAvailableReactionsSome).ensure ();
        typeof (SavedMessagesTag).ensure ();
        typeof (SavedMessagesTags).ensure ();
        typeof (BusinessBotManageBar).ensure ();
        typeof (VideoChat).ensure ();
        typeof (Chat).ensure ();
        typeof (Chats).ensure ();
        typeof (FailedToAddMember).ensure ();
        typeof (FailedToAddMembers).ensure ();
        typeof (CreatedBasicGroupChat).ensure ();
        typeof (PublicChatTypeHasUsername).ensure ();
        typeof (PublicChatTypeIsLocationBased).ensure ();
        typeof (ChatActionBarReportSpam).ensure ();
        typeof (ChatActionBarInviteMembers).ensure ();
        typeof (ChatActionBarReportAddBlock).ensure ();
        typeof (ChatActionBarAddContact).ensure ();
        typeof (ChatActionBarSharePhoneNumber).ensure ();
        typeof (ChatActionBarJoinRequest).ensure ();
        typeof (KeyboardButtonTypeText).ensure ();
        typeof (KeyboardButtonTypeRequestPhoneNumber).ensure ();
        typeof (KeyboardButtonTypeRequestLocation).ensure ();
        typeof (KeyboardButtonTypeRequestPoll).ensure ();
        typeof (KeyboardButtonTypeRequestUsers).ensure ();
        typeof (KeyboardButtonTypeRequestChat).ensure ();
        typeof (KeyboardButtonTypeWebApp).ensure ();
        typeof (KeyboardButton).ensure ();
        typeof (InlineKeyboardButtonTypeUrl).ensure ();
        typeof (InlineKeyboardButtonTypeLoginUrl).ensure ();
        typeof (InlineKeyboardButtonTypeWebApp).ensure ();
        typeof (InlineKeyboardButtonTypeCallback).ensure ();
        typeof (InlineKeyboardButtonTypeCallbackWithPassword).ensure ();
        typeof (InlineKeyboardButtonTypeCallbackGame).ensure ();
        typeof (InlineKeyboardButtonTypeSwitchInline).ensure ();
        typeof (InlineKeyboardButtonTypeBuy).ensure ();
        typeof (InlineKeyboardButtonTypeUser).ensure ();
        typeof (InlineKeyboardButtonTypeCopyText).ensure ();
        typeof (InlineKeyboardButton).ensure ();
        typeof (ReplyMarkupRemoveKeyboard).ensure ();
        typeof (ReplyMarkupForceReply).ensure ();
        typeof (ReplyMarkupShowKeyboard).ensure ();
        typeof (ReplyMarkupInlineKeyboard).ensure ();
        typeof (LoginUrlInfoOpen).ensure ();
        typeof (LoginUrlInfoRequestConfirmation).ensure ();
        typeof (ThemeParameters).ensure ();
        typeof (WebAppOpenModeCompact).ensure ();
        typeof (WebAppOpenModeFullSize).ensure ();
        typeof (WebAppOpenModeFullScreen).ensure ();
        typeof (FoundWebApp).ensure ();
        typeof (WebAppInfo).ensure ();
        typeof (MainWebApp).ensure ();
        typeof (WebAppOpenParameters).ensure ();
        typeof (MessageThreadInfo).ensure ();
        typeof (SavedMessagesTopicTypeMyNotes).ensure ();
        typeof (SavedMessagesTopicTypeAuthorHidden).ensure ();
        typeof (SavedMessagesTopicTypeSavedFromChat).ensure ();
        typeof (SavedMessagesTopic).ensure ();
        typeof (ForumTopicIcon).ensure ();
        typeof (ForumTopicInfo).ensure ();
        typeof (ForumTopic).ensure ();
        typeof (ForumTopics).ensure ();
        typeof (LinkPreviewOptions).ensure ();
        typeof (SharedUser).ensure ();
        typeof (SharedChat).ensure ();
        typeof (ThemeSettings).ensure ();
        typeof (RichTextPlain).ensure ();
        typeof (RichTextBold).ensure ();
        typeof (RichTextItalic).ensure ();
        typeof (RichTextUnderline).ensure ();
        typeof (RichTextStrikethrough).ensure ();
        typeof (RichTextFixed).ensure ();
        typeof (RichTextUrl).ensure ();
        typeof (RichTextEmailAddress).ensure ();
        typeof (RichTextSubscript).ensure ();
        typeof (RichTextSuperscript).ensure ();
        typeof (RichTextMarked).ensure ();
        typeof (RichTextPhoneNumber).ensure ();
        typeof (RichTextIcon).ensure ();
        typeof (RichTextReference).ensure ();
        typeof (RichTextAnchor).ensure ();
        typeof (RichTextAnchorLink).ensure ();
        typeof (RichTexts).ensure ();
        typeof (PageBlockCaption).ensure ();
        typeof (PageBlockListItem).ensure ();
        typeof (PageBlockHorizontalAlignmentLeft).ensure ();
        typeof (PageBlockHorizontalAlignmentCenter).ensure ();
        typeof (PageBlockHorizontalAlignmentRight).ensure ();
        typeof (PageBlockVerticalAlignmentTop).ensure ();
        typeof (PageBlockVerticalAlignmentMiddle).ensure ();
        typeof (PageBlockVerticalAlignmentBottom).ensure ();
        typeof (PageBlockTableCell).ensure ();
        typeof (PageBlockRelatedArticle).ensure ();
        typeof (PageBlockTitle).ensure ();
        typeof (PageBlockSubtitle).ensure ();
        typeof (PageBlockAuthorDate).ensure ();
        typeof (PageBlockHeader).ensure ();
        typeof (PageBlockSubheader).ensure ();
        typeof (PageBlockKicker).ensure ();
        typeof (PageBlockParagraph).ensure ();
        typeof (PageBlockPreformatted).ensure ();
        typeof (PageBlockFooter).ensure ();
        typeof (PageBlockDivider).ensure ();
        typeof (PageBlockAnchor).ensure ();
        typeof (PageBlockList).ensure ();
        typeof (PageBlockBlockQuote).ensure ();
        typeof (PageBlockPullQuote).ensure ();
        typeof (PageBlockAnimation).ensure ();
        typeof (PageBlockAudio).ensure ();
        typeof (PageBlockPhoto).ensure ();
        typeof (PageBlockVideo).ensure ();
        typeof (PageBlockVoiceNote).ensure ();
        typeof (PageBlockCover).ensure ();
        typeof (PageBlockEmbedded).ensure ();
        typeof (PageBlockEmbeddedPost).ensure ();
        typeof (PageBlockCollage).ensure ();
        typeof (PageBlockSlideshow).ensure ();
        typeof (PageBlockChatLink).ensure ();
        typeof (PageBlockTable).ensure ();
        typeof (PageBlockDetails).ensure ();
        typeof (PageBlockRelatedArticles).ensure ();
        typeof (PageBlockMap).ensure ();
        typeof (WebPageInstantView).ensure ();
        typeof (LinkPreviewAlbumMediaPhoto).ensure ();
        typeof (LinkPreviewAlbumMediaVideo).ensure ();
        typeof (LinkPreviewTypeAlbum).ensure ();
        typeof (LinkPreviewTypeAnimation).ensure ();
        typeof (LinkPreviewTypeApp).ensure ();
        typeof (LinkPreviewTypeArticle).ensure ();
        typeof (LinkPreviewTypeAudio).ensure ();
        typeof (LinkPreviewTypeBackground).ensure ();
        typeof (LinkPreviewTypeChannelBoost).ensure ();
        typeof (LinkPreviewTypeChat).ensure ();
        typeof (LinkPreviewTypeDocument).ensure ();
        typeof (LinkPreviewTypeEmbeddedAnimationPlayer).ensure ();
        typeof (LinkPreviewTypeEmbeddedAudioPlayer).ensure ();
        typeof (LinkPreviewTypeEmbeddedVideoPlayer).ensure ();
        typeof (LinkPreviewTypeExternalAudio).ensure ();
        typeof (LinkPreviewTypeExternalVideo).ensure ();
        typeof (LinkPreviewTypeInvoice).ensure ();
        typeof (LinkPreviewTypeMessage).ensure ();
        typeof (LinkPreviewTypePhoto).ensure ();
        typeof (LinkPreviewTypePremiumGiftCode).ensure ();
        typeof (LinkPreviewTypeShareableChatFolder).ensure ();
        typeof (LinkPreviewTypeSticker).ensure ();
        typeof (LinkPreviewTypeStickerSet).ensure ();
        typeof (LinkPreviewTypeStory).ensure ();
        typeof (LinkPreviewTypeSupergroupBoost).ensure ();
        typeof (LinkPreviewTypeTheme).ensure ();
        typeof (LinkPreviewTypeUnsupported).ensure ();
        typeof (LinkPreviewTypeUpgradedGift).ensure ();
        typeof (LinkPreviewTypeUser).ensure ();
        typeof (LinkPreviewTypeVideo).ensure ();
        typeof (LinkPreviewTypeVideoChat).ensure ();
        typeof (LinkPreviewTypeVideoNote).ensure ();
        typeof (LinkPreviewTypeVoiceNote).ensure ();
        typeof (LinkPreviewTypeWebApp).ensure ();
        typeof (LinkPreview).ensure ();
        typeof (CountryInfo).ensure ();
        typeof (Countries).ensure ();
        typeof (PhoneNumberInfo).ensure ();
        typeof (CollectibleItemTypeUsername).ensure ();
        typeof (CollectibleItemTypePhoneNumber).ensure ();
        typeof (CollectibleItemInfo).ensure ();
        typeof (BankCardActionOpenUrl).ensure ();
        typeof (BankCardInfo).ensure ();
        typeof (Address).ensure ();
        typeof (LocationAddress).ensure ();
        typeof (LabeledPricePart).ensure ();
        typeof (Invoice).ensure ();
        typeof (OrderInfo).ensure ();
        typeof (ShippingOption).ensure ();
        typeof (SavedCredentials).ensure ();
        typeof (InputCredentialsSaved).ensure ();
        typeof (InputCredentialsNew).ensure ();
        typeof (InputCredentialsApplePay).ensure ();
        typeof (InputCredentialsGooglePay).ensure ();
        typeof (PaymentProviderSmartGlocal).ensure ();
        typeof (PaymentProviderStripe).ensure ();
        typeof (PaymentProviderOther).ensure ();
        typeof (PaymentOption).ensure ();
        typeof (PaymentFormTypeRegular).ensure ();
        typeof (PaymentFormTypeStars).ensure ();
        typeof (PaymentFormTypeStarSubscription).ensure ();
        typeof (PaymentForm).ensure ();
        typeof (ValidatedOrderInfo).ensure ();
        typeof (PaymentResult).ensure ();
        typeof (PaymentReceiptTypeRegular).ensure ();
        typeof (PaymentReceiptTypeStars).ensure ();
        typeof (PaymentReceipt).ensure ();
        typeof (InputInvoiceMessage).ensure ();
        typeof (InputInvoiceName).ensure ();
        typeof (InputInvoiceTelegram).ensure ();
        typeof (PaidMediaPreview).ensure ();
        typeof (PaidMediaPhoto).ensure ();
        typeof (PaidMediaVideo).ensure ();
        typeof (PaidMediaUnsupported).ensure ();
        typeof (GiveawayParameters).ensure ();
        typeof (DatedFile).ensure ();
        typeof (PassportElementTypePersonalDetails).ensure ();
        typeof (PassportElementTypePassport).ensure ();
        typeof (PassportElementTypeDriverLicense).ensure ();
        typeof (PassportElementTypeIdentityCard).ensure ();
        typeof (PassportElementTypeInternalPassport).ensure ();
        typeof (PassportElementTypeAddress).ensure ();
        typeof (PassportElementTypeUtilityBill).ensure ();
        typeof (PassportElementTypeBankStatement).ensure ();
        typeof (PassportElementTypeRentalAgreement).ensure ();
        typeof (PassportElementTypePassportRegistration).ensure ();
        typeof (PassportElementTypeTemporaryRegistration).ensure ();
        typeof (PassportElementTypePhoneNumber).ensure ();
        typeof (PassportElementTypeEmailAddress).ensure ();
        typeof (Date).ensure ();
        typeof (PersonalDetails).ensure ();
        typeof (IdentityDocument).ensure ();
        typeof (InputIdentityDocument).ensure ();
        typeof (PersonalDocument).ensure ();
        typeof (InputPersonalDocument).ensure ();
        typeof (PassportElementPersonalDetails).ensure ();
        typeof (PassportElementPassport).ensure ();
        typeof (PassportElementDriverLicense).ensure ();
        typeof (PassportElementIdentityCard).ensure ();
        typeof (PassportElementInternalPassport).ensure ();
        typeof (PassportElementAddress).ensure ();
        typeof (PassportElementUtilityBill).ensure ();
        typeof (PassportElementBankStatement).ensure ();
        typeof (PassportElementRentalAgreement).ensure ();
        typeof (PassportElementPassportRegistration).ensure ();
        typeof (PassportElementTemporaryRegistration).ensure ();
        typeof (PassportElementPhoneNumber).ensure ();
        typeof (PassportElementEmailAddress).ensure ();
        typeof (InputPassportElementPersonalDetails).ensure ();
        typeof (InputPassportElementPassport).ensure ();
        typeof (InputPassportElementDriverLicense).ensure ();
        typeof (InputPassportElementIdentityCard).ensure ();
        typeof (InputPassportElementInternalPassport).ensure ();
        typeof (InputPassportElementAddress).ensure ();
        typeof (InputPassportElementUtilityBill).ensure ();
        typeof (InputPassportElementBankStatement).ensure ();
        typeof (InputPassportElementRentalAgreement).ensure ();
        typeof (InputPassportElementPassportRegistration).ensure ();
        typeof (InputPassportElementTemporaryRegistration).ensure ();
        typeof (InputPassportElementPhoneNumber).ensure ();
        typeof (InputPassportElementEmailAddress).ensure ();
        typeof (PassportElements).ensure ();
        typeof (PassportElementErrorSourceUnspecified).ensure ();
        typeof (PassportElementErrorSourceDataField).ensure ();
        typeof (PassportElementErrorSourceFrontSide).ensure ();
        typeof (PassportElementErrorSourceReverseSide).ensure ();
        typeof (PassportElementErrorSourceSelfie).ensure ();
        typeof (PassportElementErrorSourceTranslationFile).ensure ();
        typeof (PassportElementErrorSourceTranslationFiles).ensure ();
        typeof (PassportElementErrorSourceFile).ensure ();
        typeof (PassportElementErrorSourceFiles).ensure ();
        typeof (PassportElementError).ensure ();
        typeof (PassportSuitableElement).ensure ();
        typeof (PassportRequiredElement).ensure ();
        typeof (PassportAuthorizationForm).ensure ();
        typeof (PassportElementsWithErrors).ensure ();
        typeof (EncryptedCredentials).ensure ();
        typeof (EncryptedPassportElement).ensure ();
        typeof (InputPassportElementErrorSourceUnspecified).ensure ();
        typeof (InputPassportElementErrorSourceDataField).ensure ();
        typeof (InputPassportElementErrorSourceFrontSide).ensure ();
        typeof (InputPassportElementErrorSourceReverseSide).ensure ();
        typeof (InputPassportElementErrorSourceSelfie).ensure ();
        typeof (InputPassportElementErrorSourceTranslationFile).ensure ();
        typeof (InputPassportElementErrorSourceTranslationFiles).ensure ();
        typeof (InputPassportElementErrorSourceFile).ensure ();
        typeof (InputPassportElementErrorSourceFiles).ensure ();
        typeof (InputPassportElementError).ensure ();
        typeof (MessageText).ensure ();
        typeof (MessageAnimation).ensure ();
        typeof (MessageAudio).ensure ();
        typeof (MessageDocument).ensure ();
        typeof (MessagePaidMedia).ensure ();
        typeof (MessagePhoto).ensure ();
        typeof (MessageSticker).ensure ();
        typeof (MessageVideo).ensure ();
        typeof (MessageVideoNote).ensure ();
        typeof (MessageVoiceNote).ensure ();
        typeof (MessageExpiredPhoto).ensure ();
        typeof (MessageExpiredVideo).ensure ();
        typeof (MessageExpiredVideoNote).ensure ();
        typeof (MessageExpiredVoiceNote).ensure ();
        typeof (MessageLocation).ensure ();
        typeof (MessageVenue).ensure ();
        typeof (MessageContact).ensure ();
        typeof (MessageAnimatedEmoji).ensure ();
        typeof (MessageDice).ensure ();
        typeof (MessageGame).ensure ();
        typeof (MessagePoll).ensure ();
        typeof (MessageStory).ensure ();
        typeof (MessageInvoice).ensure ();
        typeof (MessageCall).ensure ();
        typeof (MessageVideoChatScheduled).ensure ();
        typeof (MessageVideoChatStarted).ensure ();
        typeof (MessageVideoChatEnded).ensure ();
        typeof (MessageInviteVideoChatParticipants).ensure ();
        typeof (MessageBasicGroupChatCreate).ensure ();
        typeof (MessageSupergroupChatCreate).ensure ();
        typeof (MessageChatChangeTitle).ensure ();
        typeof (MessageChatChangePhoto).ensure ();
        typeof (MessageChatDeletePhoto).ensure ();
        typeof (MessageChatAddMembers).ensure ();
        typeof (MessageChatJoinByLink).ensure ();
        typeof (MessageChatJoinByRequest).ensure ();
        typeof (MessageChatDeleteMember).ensure ();
        typeof (MessageChatUpgradeTo).ensure ();
        typeof (MessageChatUpgradeFrom).ensure ();
        typeof (MessagePinMessage).ensure ();
        typeof (MessageScreenshotTaken).ensure ();
        typeof (MessageChatSetBackground).ensure ();
        typeof (MessageChatSetTheme).ensure ();
        typeof (MessageChatSetMessageAutoDeleteTime).ensure ();
        typeof (MessageChatBoost).ensure ();
        typeof (MessageForumTopicCreated).ensure ();
        typeof (MessageForumTopicEdited).ensure ();
        typeof (MessageForumTopicIsClosedToggled).ensure ();
        typeof (MessageForumTopicIsHiddenToggled).ensure ();
        typeof (MessageSuggestProfilePhoto).ensure ();
        typeof (MessageCustomServiceAction).ensure ();
        typeof (MessageGameScore).ensure ();
        typeof (MessagePaymentSuccessful).ensure ();
        typeof (MessagePaymentSuccessfulBot).ensure ();
        typeof (MessagePaymentRefunded).ensure ();
        typeof (MessageGiftedPremium).ensure ();
        typeof (MessagePremiumGiftCode).ensure ();
        typeof (MessageGiveawayCreated).ensure ();
        typeof (MessageGiveaway).ensure ();
        typeof (MessageGiveawayCompleted).ensure ();
        typeof (MessageGiveawayWinners).ensure ();
        typeof (MessageGiftedStars).ensure ();
        typeof (MessageGiveawayPrizeStars).ensure ();
        typeof (MessageGift).ensure ();
        typeof (MessageUpgradedGift).ensure ();
        typeof (MessageRefundedUpgradedGift).ensure ();
        typeof (MessageContactRegistered).ensure ();
        typeof (MessageUsersShared).ensure ();
        typeof (MessageChatShared).ensure ();
        typeof (MessageBotWriteAccessAllowed).ensure ();
        typeof (MessageWebAppDataSent).ensure ();
        typeof (MessageWebAppDataReceived).ensure ();
        typeof (MessagePassportDataSent).ensure ();
        typeof (MessagePassportDataReceived).ensure ();
        typeof (MessageProximityAlertTriggered).ensure ();
        typeof (MessageUnsupported).ensure ();
        typeof (TextEntityTypeMention).ensure ();
        typeof (TextEntityTypeHashtag).ensure ();
        typeof (TextEntityTypeCashtag).ensure ();
        typeof (TextEntityTypeBotCommand).ensure ();
        typeof (TextEntityTypeUrl).ensure ();
        typeof (TextEntityTypeEmailAddress).ensure ();
        typeof (TextEntityTypePhoneNumber).ensure ();
        typeof (TextEntityTypeBankCardNumber).ensure ();
        typeof (TextEntityTypeBold).ensure ();
        typeof (TextEntityTypeItalic).ensure ();
        typeof (TextEntityTypeUnderline).ensure ();
        typeof (TextEntityTypeStrikethrough).ensure ();
        typeof (TextEntityTypeSpoiler).ensure ();
        typeof (TextEntityTypeCode).ensure ();
        typeof (TextEntityTypePre).ensure ();
        typeof (TextEntityTypePreCode).ensure ();
        typeof (TextEntityTypeBlockQuote).ensure ();
        typeof (TextEntityTypeExpandableBlockQuote).ensure ();
        typeof (TextEntityTypeTextUrl).ensure ();
        typeof (TextEntityTypeMentionName).ensure ();
        typeof (TextEntityTypeCustomEmoji).ensure ();
        typeof (TextEntityTypeMediaTimestamp).ensure ();
        typeof (InputThumbnail).ensure ();
        typeof (InputPaidMediaTypePhoto).ensure ();
        typeof (InputPaidMediaTypeVideo).ensure ();
        typeof (InputPaidMedia).ensure ();
        typeof (MessageSchedulingStateSendAtDate).ensure ();
        typeof (MessageSchedulingStateSendWhenOnline).ensure ();
        typeof (MessageSchedulingStateSendWhenVideoProcessed).ensure ();
        typeof (MessageSelfDestructTypeTimer).ensure ();
        typeof (MessageSelfDestructTypeImmediately).ensure ();
        typeof (MessageSendOptions).ensure ();
        typeof (MessageCopyOptions).ensure ();
        typeof (InputMessageText).ensure ();
        typeof (InputMessageAnimation).ensure ();
        typeof (InputMessageAudio).ensure ();
        typeof (InputMessageDocument).ensure ();
        typeof (InputMessagePaidMedia).ensure ();
        typeof (InputMessagePhoto).ensure ();
        typeof (InputMessageSticker).ensure ();
        typeof (InputMessageVideo).ensure ();
        typeof (InputMessageVideoNote).ensure ();
        typeof (InputMessageVoiceNote).ensure ();
        typeof (InputMessageLocation).ensure ();
        typeof (InputMessageVenue).ensure ();
        typeof (InputMessageContact).ensure ();
        typeof (InputMessageDice).ensure ();
        typeof (InputMessageGame).ensure ();
        typeof (InputMessageInvoice).ensure ();
        typeof (InputMessagePoll).ensure ();
        typeof (InputMessageStory).ensure ();
        typeof (InputMessageForwarded).ensure ();
        typeof (MessageProperties).ensure ();
        typeof (SearchMessagesFilterEmpty).ensure ();
        typeof (SearchMessagesFilterAnimation).ensure ();
        typeof (SearchMessagesFilterAudio).ensure ();
        typeof (SearchMessagesFilterDocument).ensure ();
        typeof (SearchMessagesFilterPhoto).ensure ();
        typeof (SearchMessagesFilterVideo).ensure ();
        typeof (SearchMessagesFilterVoiceNote).ensure ();
        typeof (SearchMessagesFilterPhotoAndVideo).ensure ();
        typeof (SearchMessagesFilterUrl).ensure ();
        typeof (SearchMessagesFilterChatPhoto).ensure ();
        typeof (SearchMessagesFilterVideoNote).ensure ();
        typeof (SearchMessagesFilterVoiceAndVideoNote).ensure ();
        typeof (SearchMessagesFilterMention).ensure ();
        typeof (SearchMessagesFilterUnreadMention).ensure ();
        typeof (SearchMessagesFilterUnreadReaction).ensure ();
        typeof (SearchMessagesFilterFailedToSend).ensure ();
        typeof (SearchMessagesFilterPinned).ensure ();
        typeof (SearchMessagesChatTypeFilterPrivate).ensure ();
        typeof (SearchMessagesChatTypeFilterGroup).ensure ();
        typeof (SearchMessagesChatTypeFilterChannel).ensure ();
        typeof (ChatActionTyping).ensure ();
        typeof (ChatActionRecordingVideo).ensure ();
        typeof (ChatActionUploadingVideo).ensure ();
        typeof (ChatActionRecordingVoiceNote).ensure ();
        typeof (ChatActionUploadingVoiceNote).ensure ();
        typeof (ChatActionUploadingPhoto).ensure ();
        typeof (ChatActionUploadingDocument).ensure ();
        typeof (ChatActionChoosingSticker).ensure ();
        typeof (ChatActionChoosingLocation).ensure ();
        typeof (ChatActionChoosingContact).ensure ();
        typeof (ChatActionStartPlayingGame).ensure ();
        typeof (ChatActionRecordingVideoNote).ensure ();
        typeof (ChatActionUploadingVideoNote).ensure ();
        typeof (ChatActionWatchingAnimations).ensure ();
        typeof (ChatActionCancel).ensure ();
        typeof (UserStatusEmpty).ensure ();
        typeof (UserStatusOnline).ensure ();
        typeof (UserStatusOffline).ensure ();
        typeof (UserStatusRecently).ensure ();
        typeof (UserStatusLastWeek).ensure ();
        typeof (UserStatusLastMonth).ensure ();
        typeof (EmojiKeyword).ensure ();
        typeof (EmojiKeywords).ensure ();
        typeof (Stickers).ensure ();
        typeof (Emojis).ensure ();
        typeof (StickerSet).ensure ();
        typeof (StickerSetInfo).ensure ();
        typeof (StickerSets).ensure ();
        typeof (TrendingStickerSets).ensure ();
        typeof (EmojiCategorySourceSearch).ensure ();
        typeof (EmojiCategorySourcePremium).ensure ();
        typeof (EmojiCategory).ensure ();
        typeof (EmojiCategories).ensure ();
        typeof (EmojiCategoryTypeDefault).ensure ();
        typeof (EmojiCategoryTypeRegularStickers).ensure ();
        typeof (EmojiCategoryTypeEmojiStatus).ensure ();
        typeof (EmojiCategoryTypeChatPhoto).ensure ();
        typeof (CurrentWeather).ensure ();
        typeof (StoryAreaPosition).ensure ();
        typeof (StoryAreaTypeLocation).ensure ();
        typeof (StoryAreaTypeVenue).ensure ();
        typeof (StoryAreaTypeSuggestedReaction).ensure ();
        typeof (StoryAreaTypeMessage).ensure ();
        typeof (StoryAreaTypeLink).ensure ();
        typeof (StoryAreaTypeWeather).ensure ();
        typeof (StoryAreaTypeUpgradedGift).ensure ();
        typeof (StoryArea).ensure ();
        typeof (InputStoryAreaTypeLocation).ensure ();
        typeof (InputStoryAreaTypeFoundVenue).ensure ();
        typeof (InputStoryAreaTypePreviousVenue).ensure ();
        typeof (InputStoryAreaTypeSuggestedReaction).ensure ();
        typeof (InputStoryAreaTypeMessage).ensure ();
        typeof (InputStoryAreaTypeLink).ensure ();
        typeof (InputStoryAreaTypeWeather).ensure ();
        typeof (InputStoryAreaTypeUpgradedGift).ensure ();
        typeof (InputStoryArea).ensure ();
        typeof (InputStoryAreas).ensure ();
        typeof (StoryVideo).ensure ();
        typeof (StoryContentPhoto).ensure ();
        typeof (StoryContentVideo).ensure ();
        typeof (StoryContentUnsupported).ensure ();
        typeof (InputStoryContentPhoto).ensure ();
        typeof (InputStoryContentVideo).ensure ();
        typeof (StoryListMain).ensure ();
        typeof (StoryListArchive).ensure ();
        typeof (StoryOriginPublicStory).ensure ();
        typeof (StoryOriginHiddenUser).ensure ();
        typeof (StoryRepostInfo).ensure ();
        typeof (StoryInteractionInfo).ensure ();
        typeof (Story).ensure ();
        typeof (Stories).ensure ();
        typeof (FoundStories).ensure ();
        typeof (StoryFullId).ensure ();
        typeof (StoryInfo).ensure ();
        typeof (ChatActiveStories).ensure ();
        typeof (StoryInteractionTypeView).ensure ();
        typeof (StoryInteractionTypeForward).ensure ();
        typeof (StoryInteractionTypeRepost).ensure ();
        typeof (StoryInteraction).ensure ();
        typeof (StoryInteractions).ensure ();
        typeof (QuickReplyMessage).ensure ();
        typeof (QuickReplyMessages).ensure ();
        typeof (QuickReplyShortcut).ensure ();
        typeof (PublicForwardMessage).ensure ();
        typeof (PublicForwardStory).ensure ();
        typeof (PublicForwards).ensure ();
        typeof (BotMediaPreview).ensure ();
        typeof (BotMediaPreviews).ensure ();
        typeof (BotMediaPreviewInfo).ensure ();
        typeof (ChatBoostLevelFeatures).ensure ();
        typeof (ChatBoostFeatures).ensure ();
        typeof (ChatBoostSourceGiftCode).ensure ();
        typeof (ChatBoostSourceGiveaway).ensure ();
        typeof (ChatBoostSourcePremium).ensure ();
        typeof (PrepaidGiveaway).ensure ();
        typeof (ChatBoostStatus).ensure ();
        typeof (ChatBoost).ensure ();
        typeof (FoundChatBoosts).ensure ();
        typeof (ChatBoostSlot).ensure ();
        typeof (ChatBoostSlots).ensure ();
        typeof (ResendCodeReasonUserRequest).ensure ();
        typeof (ResendCodeReasonVerificationFailed).ensure ();
        typeof (CallDiscardReasonEmpty).ensure ();
        typeof (CallDiscardReasonMissed).ensure ();
        typeof (CallDiscardReasonDeclined).ensure ();
        typeof (CallDiscardReasonDisconnected).ensure ();
        typeof (CallDiscardReasonHungUp).ensure ();
        typeof (CallDiscardReasonAllowGroupCall).ensure ();
        typeof (CallProtocol).ensure ();
        typeof (CallServerTypeTelegramReflector).ensure ();
        typeof (CallServerTypeWebrtc).ensure ();
        typeof (CallServer).ensure ();
        typeof (CallId).ensure ();
        typeof (GroupCallId).ensure ();
        typeof (CallStatePending).ensure ();
        typeof (CallStateExchangingKeys).ensure ();
        typeof (CallStateReady).ensure ();
        typeof (CallStateHangingUp).ensure ();
        typeof (CallStateDiscarded).ensure ();
        typeof (CallStateError).ensure ();
        typeof (GroupCallVideoQualityThumbnail).ensure ();
        typeof (GroupCallVideoQualityMedium).ensure ();
        typeof (GroupCallVideoQualityFull).ensure ();
        typeof (GroupCallStream).ensure ();
        typeof (GroupCallStreams).ensure ();
        typeof (RtmpUrl).ensure ();
        typeof (GroupCallRecentSpeaker).ensure ();
        typeof (GroupCall).ensure ();
        typeof (GroupCallVideoSourceGroup).ensure ();
        typeof (GroupCallParticipantVideoInfo).ensure ();
        typeof (GroupCallParticipant).ensure ();
        typeof (CallProblemEcho).ensure ();
        typeof (CallProblemNoise).ensure ();
        typeof (CallProblemInterruptions).ensure ();
        typeof (CallProblemDistortedSpeech).ensure ();
        typeof (CallProblemSilentLocal).ensure ();
        typeof (CallProblemSilentRemote).ensure ();
        typeof (CallProblemDropped).ensure ();
        typeof (CallProblemDistortedVideo).ensure ();
        typeof (CallProblemPixelatedVideo).ensure ();
        typeof (Call).ensure ();
        typeof (FirebaseAuthenticationSettingsAndroid).ensure ();
        typeof (FirebaseAuthenticationSettingsIos).ensure ();
        typeof (PhoneNumberAuthenticationSettings).ensure ();
        typeof (AddedReaction).ensure ();
        typeof (AddedReactions).ensure ();
        typeof (AvailableReaction).ensure ();
        typeof (AvailableReactions).ensure ();
        typeof (EmojiReaction).ensure ();
        typeof (ReactionUnavailabilityReasonAnonymousAdministrator).ensure ();
        typeof (ReactionUnavailabilityReasonGuest).ensure ();
        typeof (Animations).ensure ();
        typeof (DiceStickersRegular).ensure ();
        typeof (DiceStickersSlotMachine).ensure ();
        typeof (ImportedContacts).ensure ();
        typeof (SpeechRecognitionResultPending).ensure ();
        typeof (SpeechRecognitionResultText).ensure ();
        typeof (SpeechRecognitionResultError).ensure ();
        typeof (BusinessConnection).ensure ();
        typeof (AttachmentMenuBotColor).ensure ();
        typeof (AttachmentMenuBot).ensure ();
        typeof (SentWebAppMessage).ensure ();
        typeof (BotWriteAccessAllowReasonConnectedWebsite).ensure ();
        typeof (BotWriteAccessAllowReasonAddedToAttachmentMenu).ensure ();
        typeof (BotWriteAccessAllowReasonLaunchedWebApp).ensure ();
        typeof (BotWriteAccessAllowReasonAcceptedRequest).ensure ();
        typeof (HttpUrl).ensure ();
        typeof (UserLink).ensure ();
        typeof (TargetChatTypes).ensure ();
        typeof (TargetChatCurrent).ensure ();
        typeof (TargetChatChosen).ensure ();
        typeof (TargetChatInternalLink).ensure ();
        typeof (InputInlineQueryResultAnimation).ensure ();
        typeof (InputInlineQueryResultArticle).ensure ();
        typeof (InputInlineQueryResultAudio).ensure ();
        typeof (InputInlineQueryResultContact).ensure ();
        typeof (InputInlineQueryResultDocument).ensure ();
        typeof (InputInlineQueryResultGame).ensure ();
        typeof (InputInlineQueryResultLocation).ensure ();
        typeof (InputInlineQueryResultPhoto).ensure ();
        typeof (InputInlineQueryResultSticker).ensure ();
        typeof (InputInlineQueryResultVenue).ensure ();
        typeof (InputInlineQueryResultVideo).ensure ();
        typeof (InputInlineQueryResultVoiceNote).ensure ();
        typeof (InlineQueryResultArticle).ensure ();
        typeof (InlineQueryResultContact).ensure ();
        typeof (InlineQueryResultLocation).ensure ();
        typeof (InlineQueryResultVenue).ensure ();
        typeof (InlineQueryResultGame).ensure ();
        typeof (InlineQueryResultAnimation).ensure ();
        typeof (InlineQueryResultAudio).ensure ();
        typeof (InlineQueryResultDocument).ensure ();
        typeof (InlineQueryResultPhoto).ensure ();
        typeof (InlineQueryResultSticker).ensure ();
        typeof (InlineQueryResultVideo).ensure ();
        typeof (InlineQueryResultVoiceNote).ensure ();
        typeof (InlineQueryResultsButtonTypeStartBot).ensure ();
        typeof (InlineQueryResultsButtonTypeWebApp).ensure ();
        typeof (InlineQueryResultsButton).ensure ();
        typeof (InlineQueryResults).ensure ();
        typeof (PreparedInlineMessageId).ensure ();
        typeof (PreparedInlineMessage).ensure ();
        typeof (CallbackQueryPayloadData).ensure ();
        typeof (CallbackQueryPayloadDataWithPassword).ensure ();
        typeof (CallbackQueryPayloadGame).ensure ();
        typeof (CallbackQueryAnswer).ensure ();
        typeof (CustomRequestResult).ensure ();
        typeof (GameHighScore).ensure ();
        typeof (GameHighScores).ensure ();
        typeof (ChatEventMessageEdited).ensure ();
        typeof (ChatEventMessageDeleted).ensure ();
        typeof (ChatEventMessagePinned).ensure ();
        typeof (ChatEventMessageUnpinned).ensure ();
        typeof (ChatEventPollStopped).ensure ();
        typeof (ChatEventMemberJoined).ensure ();
        typeof (ChatEventMemberJoinedByInviteLink).ensure ();
        typeof (ChatEventMemberJoinedByRequest).ensure ();
        typeof (ChatEventMemberInvited).ensure ();
        typeof (ChatEventMemberLeft).ensure ();
        typeof (ChatEventMemberPromoted).ensure ();
        typeof (ChatEventMemberRestricted).ensure ();
        typeof (ChatEventMemberSubscriptionExtended).ensure ();
        typeof (ChatEventAvailableReactionsChanged).ensure ();
        typeof (ChatEventBackgroundChanged).ensure ();
        typeof (ChatEventDescriptionChanged).ensure ();
        typeof (ChatEventEmojiStatusChanged).ensure ();
        typeof (ChatEventLinkedChatChanged).ensure ();
        typeof (ChatEventLocationChanged).ensure ();
        typeof (ChatEventMessageAutoDeleteTimeChanged).ensure ();
        typeof (ChatEventPermissionsChanged).ensure ();
        typeof (ChatEventPhotoChanged).ensure ();
        typeof (ChatEventSlowModeDelayChanged).ensure ();
        typeof (ChatEventStickerSetChanged).ensure ();
        typeof (ChatEventCustomEmojiStickerSetChanged).ensure ();
        typeof (ChatEventTitleChanged).ensure ();
        typeof (ChatEventUsernameChanged).ensure ();
        typeof (ChatEventActiveUsernamesChanged).ensure ();
        typeof (ChatEventAccentColorChanged).ensure ();
        typeof (ChatEventProfileAccentColorChanged).ensure ();
        typeof (ChatEventHasProtectedContentToggled).ensure ();
        typeof (ChatEventInvitesToggled).ensure ();
        typeof (ChatEventIsAllHistoryAvailableToggled).ensure ();
        typeof (ChatEventHasAggressiveAntiSpamEnabledToggled).ensure ();
        typeof (ChatEventSignMessagesToggled).ensure ();
        typeof (ChatEventShowMessageSenderToggled).ensure ();
        typeof (ChatEventInviteLinkEdited).ensure ();
        typeof (ChatEventInviteLinkRevoked).ensure ();
        typeof (ChatEventInviteLinkDeleted).ensure ();
        typeof (ChatEventVideoChatCreated).ensure ();
        typeof (ChatEventVideoChatEnded).ensure ();
        typeof (ChatEventVideoChatMuteNewParticipantsToggled).ensure ();
        typeof (ChatEventVideoChatParticipantIsMutedToggled).ensure ();
        typeof (ChatEventVideoChatParticipantVolumeLevelChanged).ensure ();
        typeof (ChatEventIsForumToggled).ensure ();
        typeof (ChatEventForumTopicCreated).ensure ();
        typeof (ChatEventForumTopicEdited).ensure ();
        typeof (ChatEventForumTopicToggleIsClosed).ensure ();
        typeof (ChatEventForumTopicToggleIsHidden).ensure ();
        typeof (ChatEventForumTopicDeleted).ensure ();
        typeof (ChatEventForumTopicPinned).ensure ();
        typeof (ChatEvent).ensure ();
        typeof (ChatEvents).ensure ();
        typeof (ChatEventLogFilters).ensure ();
        typeof (LanguagePackStringValueOrdinary).ensure ();
        typeof (LanguagePackStringValuePluralized).ensure ();
        typeof (LanguagePackStringValueDeleted).ensure ();
        typeof (LanguagePackString).ensure ();
        typeof (LanguagePackStrings).ensure ();
        typeof (LanguagePackInfo).ensure ();
        typeof (LocalizationTargetInfo).ensure ();
        typeof (PremiumLimitTypeSupergroupCount).ensure ();
        typeof (PremiumLimitTypePinnedChatCount).ensure ();
        typeof (PremiumLimitTypeCreatedPublicChatCount).ensure ();
        typeof (PremiumLimitTypeSavedAnimationCount).ensure ();
        typeof (PremiumLimitTypeFavoriteStickerCount).ensure ();
        typeof (PremiumLimitTypeChatFolderCount).ensure ();
        typeof (PremiumLimitTypeChatFolderChosenChatCount).ensure ();
        typeof (PremiumLimitTypePinnedArchivedChatCount).ensure ();
        typeof (PremiumLimitTypePinnedSavedMessagesTopicCount).ensure ();
        typeof (PremiumLimitTypeCaptionLength).ensure ();
        typeof (PremiumLimitTypeBioLength).ensure ();
        typeof (PremiumLimitTypeChatFolderInviteLinkCount).ensure ();
        typeof (PremiumLimitTypeShareableChatFolderCount).ensure ();
        typeof (PremiumLimitTypeActiveStoryCount).ensure ();
        typeof (PremiumLimitTypeWeeklySentStoryCount).ensure ();
        typeof (PremiumLimitTypeMonthlySentStoryCount).ensure ();
        typeof (PremiumLimitTypeStoryCaptionLength).ensure ();
        typeof (PremiumLimitTypeStorySuggestedReactionAreaCount).ensure ();
        typeof (PremiumLimitTypeSimilarChatCount).ensure ();
        typeof (PremiumFeatureIncreasedLimits).ensure ();
        typeof (PremiumFeatureIncreasedUploadFileSize).ensure ();
        typeof (PremiumFeatureImprovedDownloadSpeed).ensure ();
        typeof (PremiumFeatureVoiceRecognition).ensure ();
        typeof (PremiumFeatureDisabledAds).ensure ();
        typeof (PremiumFeatureUniqueReactions).ensure ();
        typeof (PremiumFeatureUniqueStickers).ensure ();
        typeof (PremiumFeatureCustomEmoji).ensure ();
        typeof (PremiumFeatureAdvancedChatManagement).ensure ();
        typeof (PremiumFeatureProfileBadge).ensure ();
        typeof (PremiumFeatureEmojiStatus).ensure ();
        typeof (PremiumFeatureAnimatedProfilePhoto).ensure ();
        typeof (PremiumFeatureForumTopicIcon).ensure ();
        typeof (PremiumFeatureAppIcons).ensure ();
        typeof (PremiumFeatureRealTimeChatTranslation).ensure ();
        typeof (PremiumFeatureUpgradedStories).ensure ();
        typeof (PremiumFeatureChatBoost).ensure ();
        typeof (PremiumFeatureAccentColor).ensure ();
        typeof (PremiumFeatureBackgroundForBoth).ensure ();
        typeof (PremiumFeatureSavedMessagesTags).ensure ();
        typeof (PremiumFeatureMessagePrivacy).ensure ();
        typeof (PremiumFeatureLastSeenTimes).ensure ();
        typeof (PremiumFeatureBusiness).ensure ();
        typeof (PremiumFeatureMessageEffects).ensure ();
        typeof (BusinessFeatureLocation).ensure ();
        typeof (BusinessFeatureOpeningHours).ensure ();
        typeof (BusinessFeatureQuickReplies).ensure ();
        typeof (BusinessFeatureGreetingMessage).ensure ();
        typeof (BusinessFeatureAwayMessage).ensure ();
        typeof (BusinessFeatureAccountLinks).ensure ();
        typeof (BusinessFeatureStartPage).ensure ();
        typeof (BusinessFeatureBots).ensure ();
        typeof (BusinessFeatureEmojiStatus).ensure ();
        typeof (BusinessFeatureChatFolderTags).ensure ();
        typeof (BusinessFeatureUpgradedStories).ensure ();
        typeof (PremiumStoryFeaturePriorityOrder).ensure ();
        typeof (PremiumStoryFeatureStealthMode).ensure ();
        typeof (PremiumStoryFeaturePermanentViewsHistory).ensure ();
        typeof (PremiumStoryFeatureCustomExpirationDuration).ensure ();
        typeof (PremiumStoryFeatureSaveStories).ensure ();
        typeof (PremiumStoryFeatureLinksAndFormatting).ensure ();
        typeof (PremiumStoryFeatureVideoQuality).ensure ();
        typeof (PremiumLimit).ensure ();
        typeof (PremiumFeatures).ensure ();
        typeof (BusinessFeatures).ensure ();
        typeof (PremiumSourceLimitExceeded).ensure ();
        typeof (PremiumSourceFeature).ensure ();
        typeof (PremiumSourceBusinessFeature).ensure ();
        typeof (PremiumSourceStoryFeature).ensure ();
        typeof (PremiumSourceLink).ensure ();
        typeof (PremiumSourceSettings).ensure ();
        typeof (PremiumFeaturePromotionAnimation).ensure ();
        typeof (BusinessFeaturePromotionAnimation).ensure ();
        typeof (PremiumState).ensure ();
        typeof (StorePaymentPurposePremiumSubscription).ensure ();
        typeof (StorePaymentPurposePremiumGiftCodes).ensure ();
        typeof (StorePaymentPurposePremiumGiveaway).ensure ();
        typeof (StorePaymentPurposeStarGiveaway).ensure ();
        typeof (StorePaymentPurposeStars).ensure ();
        typeof (StorePaymentPurposeGiftedStars).ensure ();
        typeof (TelegramPaymentPurposePremiumGiftCodes).ensure ();
        typeof (TelegramPaymentPurposePremiumGiveaway).ensure ();
        typeof (TelegramPaymentPurposeStars).ensure ();
        typeof (TelegramPaymentPurposeGiftedStars).ensure ();
        typeof (TelegramPaymentPurposeStarGiveaway).ensure ();
        typeof (TelegramPaymentPurposeJoinChat).ensure ();
        typeof (DeviceTokenFirebaseCloudMessaging).ensure ();
        typeof (DeviceTokenApplePush).ensure ();
        typeof (DeviceTokenApplePushVoIP).ensure ();
        typeof (DeviceTokenWindowsPush).ensure ();
        typeof (DeviceTokenMicrosoftPush).ensure ();
        typeof (DeviceTokenMicrosoftPushVoIP).ensure ();
        typeof (DeviceTokenWebPush).ensure ();
        typeof (DeviceTokenSimplePush).ensure ();
        typeof (DeviceTokenUbuntuPush).ensure ();
        typeof (DeviceTokenBlackBerryPush).ensure ();
        typeof (DeviceTokenTizenPush).ensure ();
        typeof (DeviceTokenHuaweiPush).ensure ();
        typeof (PushReceiverId).ensure ();
        typeof (BackgroundFillSolid).ensure ();
        typeof (BackgroundFillGradient).ensure ();
        typeof (BackgroundFillFreeformGradient).ensure ();
        typeof (BackgroundTypeWallpaper).ensure ();
        typeof (BackgroundTypePattern).ensure ();
        typeof (BackgroundTypeFill).ensure ();
        typeof (BackgroundTypeChatTheme).ensure ();
        typeof (InputBackgroundLocal).ensure ();
        typeof (InputBackgroundRemote).ensure ();
        typeof (InputBackgroundPrevious).ensure ();
        typeof (ChatTheme).ensure ();
        typeof (TimeZone).ensure ();
        typeof (TimeZones).ensure ();
        typeof (Hashtags).ensure ();
        typeof (CanSendStoryResultOk).ensure ();
        typeof (CanSendStoryResultPremiumNeeded).ensure ();
        typeof (CanSendStoryResultBoostNeeded).ensure ();
        typeof (CanSendStoryResultActiveStoryLimitExceeded).ensure ();
        typeof (CanSendStoryResultWeeklyLimitExceeded).ensure ();
        typeof (CanSendStoryResultMonthlyLimitExceeded).ensure ();
        typeof (CanTransferOwnershipResultOk).ensure ();
        typeof (CanTransferOwnershipResultPasswordNeeded).ensure ();
        typeof (CanTransferOwnershipResultPasswordTooFresh).ensure ();
        typeof (CanTransferOwnershipResultSessionTooFresh).ensure ();
        typeof (CheckChatUsernameResultOk).ensure ();
        typeof (CheckChatUsernameResultUsernameInvalid).ensure ();
        typeof (CheckChatUsernameResultUsernameOccupied).ensure ();
        typeof (CheckChatUsernameResultUsernamePurchasable).ensure ();
        typeof (CheckChatUsernameResultPublicChatsTooMany).ensure ();
        typeof (CheckChatUsernameResultPublicGroupsUnavailable).ensure ();
        typeof (CheckStickerSetNameResultOk).ensure ();
        typeof (CheckStickerSetNameResultNameInvalid).ensure ();
        typeof (CheckStickerSetNameResultNameOccupied).ensure ();
        typeof (ResetPasswordResultOk).ensure ();
        typeof (ResetPasswordResultPending).ensure ();
        typeof (ResetPasswordResultDeclined).ensure ();
        typeof (MessageFileTypePrivate).ensure ();
        typeof (MessageFileTypeGroup).ensure ();
        typeof (MessageFileTypeUnknown).ensure ();
        typeof (PushMessageContentHidden).ensure ();
        typeof (PushMessageContentAnimation).ensure ();
        typeof (PushMessageContentAudio).ensure ();
        typeof (PushMessageContentContact).ensure ();
        typeof (PushMessageContentContactRegistered).ensure ();
        typeof (PushMessageContentDocument).ensure ();
        typeof (PushMessageContentGame).ensure ();
        typeof (PushMessageContentGameScore).ensure ();
        typeof (PushMessageContentInvoice).ensure ();
        typeof (PushMessageContentLocation).ensure ();
        typeof (PushMessageContentPaidMedia).ensure ();
        typeof (PushMessageContentPhoto).ensure ();
        typeof (PushMessageContentPoll).ensure ();
        typeof (PushMessageContentPremiumGiftCode).ensure ();
        typeof (PushMessageContentGiveaway).ensure ();
        typeof (PushMessageContentGift).ensure ();
        typeof (PushMessageContentUpgradedGift).ensure ();
        typeof (PushMessageContentScreenshotTaken).ensure ();
        typeof (PushMessageContentSticker).ensure ();
        typeof (PushMessageContentStory).ensure ();
        typeof (PushMessageContentText).ensure ();
        typeof (PushMessageContentVideo).ensure ();
        typeof (PushMessageContentVideoNote).ensure ();
        typeof (PushMessageContentVoiceNote).ensure ();
        typeof (PushMessageContentBasicGroupChatCreate).ensure ();
        typeof (PushMessageContentChatAddMembers).ensure ();
        typeof (PushMessageContentChatChangePhoto).ensure ();
        typeof (PushMessageContentChatChangeTitle).ensure ();
        typeof (PushMessageContentChatSetBackground).ensure ();
        typeof (PushMessageContentChatSetTheme).ensure ();
        typeof (PushMessageContentChatDeleteMember).ensure ();
        typeof (PushMessageContentChatJoinByLink).ensure ();
        typeof (PushMessageContentChatJoinByRequest).ensure ();
        typeof (PushMessageContentRecurringPayment).ensure ();
        typeof (PushMessageContentSuggestProfilePhoto).ensure ();
        typeof (PushMessageContentMessageForwards).ensure ();
        typeof (PushMessageContentMediaAlbum).ensure ();
        typeof (NotificationTypeNewMessage).ensure ();
        typeof (NotificationTypeNewSecretChat).ensure ();
        typeof (NotificationTypeNewCall).ensure ();
        typeof (NotificationTypeNewPushMessage).ensure ();
        typeof (NotificationGroupTypeMessages).ensure ();
        typeof (NotificationGroupTypeMentions).ensure ();
        typeof (NotificationGroupTypeSecretChat).ensure ();
        typeof (NotificationGroupTypeCalls).ensure ();
        typeof (NotificationSound).ensure ();
        typeof (NotificationSounds).ensure ();
        typeof (Notification).ensure ();
        typeof (NotificationGroup).ensure ();
        typeof (OptionValueBoolean).ensure ();
        typeof (OptionValueEmpty).ensure ();
        typeof (OptionValueInteger).ensure ();
        typeof (OptionValueString).ensure ();
        typeof (JsonObjectMember).ensure ();
        typeof (JsonValueNull).ensure ();
        typeof (JsonValueBoolean).ensure ();
        typeof (JsonValueNumber).ensure ();
        typeof (JsonValueString).ensure ();
        typeof (JsonValueArray).ensure ();
        typeof (JsonValueObject).ensure ();
        typeof (StoryPrivacySettingsEveryone).ensure ();
        typeof (StoryPrivacySettingsContacts).ensure ();
        typeof (StoryPrivacySettingsCloseFriends).ensure ();
        typeof (StoryPrivacySettingsSelectedUsers).ensure ();
        typeof (UserPrivacySettingRuleAllowAll).ensure ();
        typeof (UserPrivacySettingRuleAllowContacts).ensure ();
        typeof (UserPrivacySettingRuleAllowBots).ensure ();
        typeof (UserPrivacySettingRuleAllowPremiumUsers).ensure ();
        typeof (UserPrivacySettingRuleAllowUsers).ensure ();
        typeof (UserPrivacySettingRuleAllowChatMembers).ensure ();
        typeof (UserPrivacySettingRuleRestrictAll).ensure ();
        typeof (UserPrivacySettingRuleRestrictContacts).ensure ();
        typeof (UserPrivacySettingRuleRestrictBots).ensure ();
        typeof (UserPrivacySettingRuleRestrictUsers).ensure ();
        typeof (UserPrivacySettingRuleRestrictChatMembers).ensure ();
        typeof (UserPrivacySettingRules).ensure ();
        typeof (UserPrivacySettingShowStatus).ensure ();
        typeof (UserPrivacySettingShowProfilePhoto).ensure ();
        typeof (UserPrivacySettingShowLinkInForwardedMessages).ensure ();
        typeof (UserPrivacySettingShowPhoneNumber).ensure ();
        typeof (UserPrivacySettingShowBio).ensure ();
        typeof (UserPrivacySettingShowBirthdate).ensure ();
        typeof (UserPrivacySettingAllowChatInvites).ensure ();
        typeof (UserPrivacySettingAllowCalls).ensure ();
        typeof (UserPrivacySettingAllowPeerToPeerCalls).ensure ();
        typeof (UserPrivacySettingAllowFindingByPhoneNumber).ensure ();
        typeof (UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages).ensure ();
        typeof (UserPrivacySettingAutosaveGifts).ensure ();
        typeof (ReadDatePrivacySettings).ensure ();
        typeof (NewChatPrivacySettings).ensure ();
        typeof (CanSendMessageToUserResultOk).ensure ();
        typeof (CanSendMessageToUserResultUserIsDeleted).ensure ();
        typeof (CanSendMessageToUserResultUserRestrictsNewChats).ensure ();
        typeof (AccountTtl).ensure ();
        typeof (MessageAutoDeleteTime).ensure ();
        typeof (SessionTypeAndroid).ensure ();
        typeof (SessionTypeApple).ensure ();
        typeof (SessionTypeBrave).ensure ();
        typeof (SessionTypeChrome).ensure ();
        typeof (SessionTypeEdge).ensure ();
        typeof (SessionTypeFirefox).ensure ();
        typeof (SessionTypeIpad).ensure ();
        typeof (SessionTypeIphone).ensure ();
        typeof (SessionTypeLinux).ensure ();
        typeof (SessionTypeMac).ensure ();
        typeof (SessionTypeOpera).ensure ();
        typeof (SessionTypeSafari).ensure ();
        typeof (SessionTypeUbuntu).ensure ();
        typeof (SessionTypeUnknown).ensure ();
        typeof (SessionTypeVivaldi).ensure ();
        typeof (SessionTypeWindows).ensure ();
        typeof (SessionTypeXbox).ensure ();
        typeof (Session).ensure ();
        typeof (Sessions).ensure ();
        typeof (UnconfirmedSession).ensure ();
        typeof (ConnectedWebsite).ensure ();
        typeof (ConnectedWebsites).ensure ();
        typeof (ReportReasonSpam).ensure ();
        typeof (ReportReasonViolence).ensure ();
        typeof (ReportReasonPornography).ensure ();
        typeof (ReportReasonChildAbuse).ensure ();
        typeof (ReportReasonCopyright).ensure ();
        typeof (ReportReasonUnrelatedLocation).ensure ();
        typeof (ReportReasonFake).ensure ();
        typeof (ReportReasonIllegalDrugs).ensure ();
        typeof (ReportReasonPersonalDetails).ensure ();
        typeof (ReportReasonCustom).ensure ();
        typeof (ReportChatResultOk).ensure ();
        typeof (ReportChatResultOptionRequired).ensure ();
        typeof (ReportChatResultTextRequired).ensure ();
        typeof (ReportChatResultMessagesRequired).ensure ();
        typeof (ReportStoryResultOk).ensure ();
        typeof (ReportStoryResultOptionRequired).ensure ();
        typeof (ReportStoryResultTextRequired).ensure ();
        typeof (InternalLinkTypeActiveSessions).ensure ();
        typeof (InternalLinkTypeAttachmentMenuBot).ensure ();
        typeof (InternalLinkTypeAuthenticationCode).ensure ();
        typeof (InternalLinkTypeBackground).ensure ();
        typeof (InternalLinkTypeBotAddToChannel).ensure ();
        typeof (InternalLinkTypeBotStart).ensure ();
        typeof (InternalLinkTypeBotStartInGroup).ensure ();
        typeof (InternalLinkTypeBusinessChat).ensure ();
        typeof (InternalLinkTypeBuyStars).ensure ();
        typeof (InternalLinkTypeChangePhoneNumber).ensure ();
        typeof (InternalLinkTypeChatAffiliateProgram).ensure ();
        typeof (InternalLinkTypeChatBoost).ensure ();
        typeof (InternalLinkTypeChatFolderInvite).ensure ();
        typeof (InternalLinkTypeChatFolderSettings).ensure ();
        typeof (InternalLinkTypeChatInvite).ensure ();
        typeof (InternalLinkTypeDefaultMessageAutoDeleteTimerSettings).ensure ();
        typeof (InternalLinkTypeEditProfileSettings).ensure ();
        typeof (InternalLinkTypeGame).ensure ();
        typeof (InternalLinkTypeInstantView).ensure ();
        typeof (InternalLinkTypeInvoice).ensure ();
        typeof (InternalLinkTypeLanguagePack).ensure ();
        typeof (InternalLinkTypeLanguageSettings).ensure ();
        typeof (InternalLinkTypeMainWebApp).ensure ();
        typeof (InternalLinkTypeMessage).ensure ();
        typeof (InternalLinkTypeMessageDraft).ensure ();
        typeof (InternalLinkTypePassportDataRequest).ensure ();
        typeof (InternalLinkTypePhoneNumberConfirmation).ensure ();
        typeof (InternalLinkTypePremiumFeatures).ensure ();
        typeof (InternalLinkTypePremiumGift).ensure ();
        typeof (InternalLinkTypePremiumGiftCode).ensure ();
        typeof (InternalLinkTypePrivacyAndSecuritySettings).ensure ();
        typeof (InternalLinkTypeProxy).ensure ();
        typeof (InternalLinkTypePublicChat).ensure ();
        typeof (InternalLinkTypeQrCodeAuthentication).ensure ();
        typeof (InternalLinkTypeRestorePurchases).ensure ();
        typeof (InternalLinkTypeSettings).ensure ();
        typeof (InternalLinkTypeStickerSet).ensure ();
        typeof (InternalLinkTypeStory).ensure ();
        typeof (InternalLinkTypeTheme).ensure ();
        typeof (InternalLinkTypeThemeSettings).ensure ();
        typeof (InternalLinkTypeUnknownDeepLink).ensure ();
        typeof (InternalLinkTypeUnsupportedProxy).ensure ();
        typeof (InternalLinkTypeUpgradedGift).ensure ();
        typeof (InternalLinkTypeUserPhoneNumber).ensure ();
        typeof (InternalLinkTypeUserToken).ensure ();
        typeof (InternalLinkTypeVideoChat).ensure ();
        typeof (InternalLinkTypeWebApp).ensure ();
        typeof (MessageLink).ensure ();
        typeof (MessageLinkInfo).ensure ();
        typeof (ChatBoostLink).ensure ();
        typeof (ChatBoostLinkInfo).ensure ();
        typeof (BlockListMain).ensure ();
        typeof (BlockListStories).ensure ();
        typeof (FilePart).ensure ();
        typeof (FileTypeNone).ensure ();
        typeof (FileTypeAnimation).ensure ();
        typeof (FileTypeAudio).ensure ();
        typeof (FileTypeDocument).ensure ();
        typeof (FileTypeNotificationSound).ensure ();
        typeof (FileTypePhoto).ensure ();
        typeof (FileTypePhotoStory).ensure ();
        typeof (FileTypeProfilePhoto).ensure ();
        typeof (FileTypeSecret).ensure ();
        typeof (FileTypeSecretThumbnail).ensure ();
        typeof (FileTypeSecure).ensure ();
        typeof (FileTypeSelfDestructingPhoto).ensure ();
        typeof (FileTypeSelfDestructingVideo).ensure ();
        typeof (FileTypeSelfDestructingVideoNote).ensure ();
        typeof (FileTypeSelfDestructingVoiceNote).ensure ();
        typeof (FileTypeSticker).ensure ();
        typeof (FileTypeThumbnail).ensure ();
        typeof (FileTypeUnknown).ensure ();
        typeof (FileTypeVideo).ensure ();
        typeof (FileTypeVideoNote).ensure ();
        typeof (FileTypeVideoStory).ensure ();
        typeof (FileTypeVoiceNote).ensure ();
        typeof (FileTypeWallpaper).ensure ();
        typeof (StorageStatisticsByFileType).ensure ();
        typeof (StorageStatisticsByChat).ensure ();
        typeof (StorageStatistics).ensure ();
        typeof (StorageStatisticsFast).ensure ();
        typeof (DatabaseStatistics).ensure ();
        typeof (NetworkTypeNone).ensure ();
        typeof (NetworkTypeMobile).ensure ();
        typeof (NetworkTypeMobileRoaming).ensure ();
        typeof (NetworkTypeWiFi).ensure ();
        typeof (NetworkTypeOther).ensure ();
        typeof (NetworkStatisticsEntryFile).ensure ();
        typeof (NetworkStatisticsEntryCall).ensure ();
        typeof (NetworkStatistics).ensure ();
        typeof (AutoDownloadSettings).ensure ();
        typeof (AutoDownloadSettingsPresets).ensure ();
        typeof (AutosaveSettingsScopePrivateChats).ensure ();
        typeof (AutosaveSettingsScopeGroupChats).ensure ();
        typeof (AutosaveSettingsScopeChannelChats).ensure ();
        typeof (AutosaveSettingsScopeChat).ensure ();
        typeof (ScopeAutosaveSettings).ensure ();
        typeof (AutosaveSettingsException).ensure ();
        typeof (AutosaveSettings).ensure ();
        typeof (ConnectionStateWaitingForNetwork).ensure ();
        typeof (ConnectionStateConnectingToProxy).ensure ();
        typeof (ConnectionStateConnecting).ensure ();
        typeof (ConnectionStateUpdating).ensure ();
        typeof (ConnectionStateReady).ensure ();
        typeof (TopChatCategoryUsers).ensure ();
        typeof (TopChatCategoryBots).ensure ();
        typeof (TopChatCategoryGroups).ensure ();
        typeof (TopChatCategoryChannels).ensure ();
        typeof (TopChatCategoryInlineBots).ensure ();
        typeof (TopChatCategoryWebAppBots).ensure ();
        typeof (TopChatCategoryCalls).ensure ();
        typeof (TopChatCategoryForwardChats).ensure ();
        typeof (FoundPosition).ensure ();
        typeof (FoundPositions).ensure ();
        typeof (TMeUrlTypeUser).ensure ();
        typeof (TMeUrlTypeSupergroup).ensure ();
        typeof (TMeUrlTypeChatInvite).ensure ();
        typeof (TMeUrlTypeStickerSet).ensure ();
        typeof (TMeUrl).ensure ();
        typeof (TMeUrls).ensure ();
        typeof (SuggestedActionEnableArchiveAndMuteNewChats).ensure ();
        typeof (SuggestedActionCheckPassword).ensure ();
        typeof (SuggestedActionCheckPhoneNumber).ensure ();
        typeof (SuggestedActionViewChecksHint).ensure ();
        typeof (SuggestedActionConvertToBroadcastGroup).ensure ();
        typeof (SuggestedActionSetPassword).ensure ();
        typeof (SuggestedActionUpgradePremium).ensure ();
        typeof (SuggestedActionRestorePremium).ensure ();
        typeof (SuggestedActionSubscribeToAnnualPremium).ensure ();
        typeof (SuggestedActionGiftPremiumForChristmas).ensure ();
        typeof (SuggestedActionSetBirthdate).ensure ();
        typeof (SuggestedActionSetProfilePhoto).ensure ();
        typeof (SuggestedActionExtendPremium).ensure ();
        typeof (SuggestedActionExtendStarSubscriptions).ensure ();
        typeof (Count).ensure ();
        typeof (Text).ensure ();
        typeof (Seconds).ensure ();
        typeof (FileDownloadedPrefixSize).ensure ();
        typeof (DeepLinkInfo).ensure ();
        typeof (TextParseModeMarkdown).ensure ();
        typeof (TextParseModeHTML).ensure ();
        typeof (ProxyTypeSocks5).ensure ();
        typeof (ProxyTypeHttp).ensure ();
        typeof (ProxyTypeMtproto).ensure ();
        typeof (Proxy).ensure ();
        typeof (Proxies).ensure ();
        typeof (InputSticker).ensure ();
        typeof (DateRange).ensure ();
        typeof (StatisticalValue).ensure ();
        typeof (StatisticalGraphData).ensure ();
        typeof (StatisticalGraphAsync).ensure ();
        typeof (StatisticalGraphError).ensure ();
        typeof (ChatStatisticsObjectTypeMessage).ensure ();
        typeof (ChatStatisticsObjectTypeStory).ensure ();
        typeof (ChatStatisticsInteractionInfo).ensure ();
        typeof (ChatStatisticsMessageSenderInfo).ensure ();
        typeof (ChatStatisticsAdministratorActionsInfo).ensure ();
        typeof (ChatStatisticsInviterInfo).ensure ();
        typeof (ChatStatisticsSupergroup).ensure ();
        typeof (ChatStatisticsChannel).ensure ();
        typeof (ChatRevenueAmount).ensure ();
        typeof (ChatRevenueStatistics).ensure ();
        typeof (MessageStatistics).ensure ();
        typeof (StoryStatistics).ensure ();
        typeof (RevenueWithdrawalStatePending).ensure ();
        typeof (RevenueWithdrawalStateSucceeded).ensure ();
        typeof (RevenueWithdrawalStateFailed).ensure ();
        typeof (ChatRevenueTransactionTypeEarnings).ensure ();
        typeof (ChatRevenueTransactionTypeWithdrawal).ensure ();
        typeof (ChatRevenueTransactionTypeRefund).ensure ();
        typeof (ChatRevenueTransaction).ensure ();
        typeof (ChatRevenueTransactions).ensure ();
        typeof (StarRevenueStatus).ensure ();
        typeof (StarRevenueStatistics).ensure ();
        typeof (Point).ensure ();
        typeof (VectorPathCommandLine).ensure ();
        typeof (VectorPathCommandCubicBezierCurve).ensure ();
        typeof (BotCommandScopeDefault).ensure ();
        typeof (BotCommandScopeAllPrivateChats).ensure ();
        typeof (BotCommandScopeAllGroupChats).ensure ();
        typeof (BotCommandScopeAllChatAdministrators).ensure ();
        typeof (BotCommandScopeChat).ensure ();
        typeof (BotCommandScopeChatAdministrators).ensure ();
        typeof (BotCommandScopeChatMember).ensure ();
        typeof (PhoneNumberCodeTypeChange).ensure ();
        typeof (PhoneNumberCodeTypeVerify).ensure ();
        typeof (PhoneNumberCodeTypeConfirmOwnership).ensure ();
        typeof (UpdateAuthorizationState).ensure ();
        typeof (UpdateNewMessage).ensure ();
        typeof (UpdateMessageSendAcknowledged).ensure ();
        typeof (UpdateMessageSendSucceeded).ensure ();
        typeof (UpdateMessageSendFailed).ensure ();
        typeof (UpdateMessageContent).ensure ();
        typeof (UpdateMessageEdited).ensure ();
        typeof (UpdateMessageIsPinned).ensure ();
        typeof (UpdateMessageInteractionInfo).ensure ();
        typeof (UpdateMessageContentOpened).ensure ();
        typeof (UpdateMessageMentionRead).ensure ();
        typeof (UpdateMessageUnreadReactions).ensure ();
        typeof (UpdateMessageFactCheck).ensure ();
        typeof (UpdateMessageLiveLocationViewed).ensure ();
        typeof (UpdateVideoPublished).ensure ();
        typeof (UpdateNewChat).ensure ();
        typeof (UpdateChatTitle).ensure ();
        typeof (UpdateChatPhoto).ensure ();
        typeof (UpdateChatAccentColors).ensure ();
        typeof (UpdateChatPermissions).ensure ();
        typeof (UpdateChatLastMessage).ensure ();
        typeof (UpdateChatPosition).ensure ();
        typeof (UpdateChatAddedToList).ensure ();
        typeof (UpdateChatRemovedFromList).ensure ();
        typeof (UpdateChatReadInbox).ensure ();
        typeof (UpdateChatReadOutbox).ensure ();
        typeof (UpdateChatActionBar).ensure ();
        typeof (UpdateChatBusinessBotManageBar).ensure ();
        typeof (UpdateChatAvailableReactions).ensure ();
        typeof (UpdateChatDraftMessage).ensure ();
        typeof (UpdateChatEmojiStatus).ensure ();
        typeof (UpdateChatMessageSender).ensure ();
        typeof (UpdateChatMessageAutoDeleteTime).ensure ();
        typeof (UpdateChatNotificationSettings).ensure ();
        typeof (UpdateChatPendingJoinRequests).ensure ();
        typeof (UpdateChatReplyMarkup).ensure ();
        typeof (UpdateChatBackground).ensure ();
        typeof (UpdateChatTheme).ensure ();
        typeof (UpdateChatUnreadMentionCount).ensure ();
        typeof (UpdateChatUnreadReactionCount).ensure ();
        typeof (UpdateChatVideoChat).ensure ();
        typeof (UpdateChatDefaultDisableNotification).ensure ();
        typeof (UpdateChatHasProtectedContent).ensure ();
        typeof (UpdateChatIsTranslatable).ensure ();
        typeof (UpdateChatIsMarkedAsUnread).ensure ();
        typeof (UpdateChatViewAsTopics).ensure ();
        typeof (UpdateChatBlockList).ensure ();
        typeof (UpdateChatHasScheduledMessages).ensure ();
        typeof (UpdateChatFolders).ensure ();
        typeof (UpdateChatOnlineMemberCount).ensure ();
        typeof (UpdateSavedMessagesTopic).ensure ();
        typeof (UpdateSavedMessagesTopicCount).ensure ();
        typeof (UpdateQuickReplyShortcut).ensure ();
        typeof (UpdateQuickReplyShortcutDeleted).ensure ();
        typeof (UpdateQuickReplyShortcuts).ensure ();
        typeof (UpdateQuickReplyShortcutMessages).ensure ();
        typeof (UpdateForumTopicInfo).ensure ();
        typeof (UpdateScopeNotificationSettings).ensure ();
        typeof (UpdateReactionNotificationSettings).ensure ();
        typeof (UpdateNotification).ensure ();
        typeof (UpdateNotificationGroup).ensure ();
        typeof (UpdateActiveNotifications).ensure ();
        typeof (UpdateHavePendingNotifications).ensure ();
        typeof (UpdateDeleteMessages).ensure ();
        typeof (UpdateChatAction).ensure ();
        typeof (UpdateUserStatus).ensure ();
        typeof (UpdateUser).ensure ();
        typeof (UpdateBasicGroup).ensure ();
        typeof (UpdateSupergroup).ensure ();
        typeof (UpdateSecretChat).ensure ();
        typeof (UpdateUserFullInfo).ensure ();
        typeof (UpdateBasicGroupFullInfo).ensure ();
        typeof (UpdateSupergroupFullInfo).ensure ();
        typeof (UpdateServiceNotification).ensure ();
        typeof (UpdateFile).ensure ();
        typeof (UpdateFileGenerationStart).ensure ();
        typeof (UpdateFileGenerationStop).ensure ();
        typeof (UpdateFileDownloads).ensure ();
        typeof (UpdateFileAddedToDownloads).ensure ();
        typeof (UpdateFileDownload).ensure ();
        typeof (UpdateFileRemovedFromDownloads).ensure ();
        typeof (UpdateApplicationVerificationRequired).ensure ();
        typeof (UpdateApplicationRecaptchaVerificationRequired).ensure ();
        typeof (UpdateCall).ensure ();
        typeof (UpdateGroupCall).ensure ();
        typeof (UpdateGroupCallParticipant).ensure ();
        typeof (UpdateNewCallSignalingData).ensure ();
        typeof (UpdateUserPrivacySettingRules).ensure ();
        typeof (UpdateUnreadMessageCount).ensure ();
        typeof (UpdateUnreadChatCount).ensure ();
        typeof (UpdateStory).ensure ();
        typeof (UpdateStoryDeleted).ensure ();
        typeof (UpdateStorySendSucceeded).ensure ();
        typeof (UpdateStorySendFailed).ensure ();
        typeof (UpdateChatActiveStories).ensure ();
        typeof (UpdateStoryListChatCount).ensure ();
        typeof (UpdateStoryStealthMode).ensure ();
        typeof (UpdateOption).ensure ();
        typeof (UpdateStickerSet).ensure ();
        typeof (UpdateInstalledStickerSets).ensure ();
        typeof (UpdateTrendingStickerSets).ensure ();
        typeof (UpdateRecentStickers).ensure ();
        typeof (UpdateFavoriteStickers).ensure ();
        typeof (UpdateSavedAnimations).ensure ();
        typeof (UpdateSavedNotificationSounds).ensure ();
        typeof (UpdateDefaultBackground).ensure ();
        typeof (UpdateChatThemes).ensure ();
        typeof (UpdateAccentColors).ensure ();
        typeof (UpdateProfileAccentColors).ensure ();
        typeof (UpdateLanguagePackStrings).ensure ();
        typeof (UpdateConnectionState).ensure ();
        typeof (UpdateTermsOfService).ensure ();
        typeof (UpdateUnconfirmedSession).ensure ();
        typeof (UpdateAttachmentMenuBots).ensure ();
        typeof (UpdateWebAppMessageSent).ensure ();
        typeof (UpdateActiveEmojiReactions).ensure ();
        typeof (UpdateAvailableMessageEffects).ensure ();
        typeof (UpdateDefaultReactionType).ensure ();
        typeof (UpdateDefaultPaidReactionType).ensure ();
        typeof (UpdateSavedMessagesTags).ensure ();
        typeof (UpdateActiveLiveLocationMessages).ensure ();
        typeof (UpdateOwnedStarCount).ensure ();
        typeof (UpdateChatRevenueAmount).ensure ();
        typeof (UpdateStarRevenueStatus).ensure ();
        typeof (UpdateSpeechRecognitionTrial).ensure ();
        typeof (UpdateDiceEmojis).ensure ();
        typeof (UpdateAnimatedEmojiMessageClicked).ensure ();
        typeof (UpdateAnimationSearchParameters).ensure ();
        typeof (UpdateSuggestedActions).ensure ();
        typeof (UpdateSpeedLimitNotification).ensure ();
        typeof (UpdateContactCloseBirthdays).ensure ();
        typeof (UpdateAutosaveSettings).ensure ();
        typeof (UpdateBusinessConnection).ensure ();
        typeof (UpdateNewBusinessMessage).ensure ();
        typeof (UpdateBusinessMessageEdited).ensure ();
        typeof (UpdateBusinessMessagesDeleted).ensure ();
        typeof (UpdateNewInlineQuery).ensure ();
        typeof (UpdateNewChosenInlineResult).ensure ();
        typeof (UpdateNewCallbackQuery).ensure ();
        typeof (UpdateNewInlineCallbackQuery).ensure ();
        typeof (UpdateNewBusinessCallbackQuery).ensure ();
        typeof (UpdateNewShippingQuery).ensure ();
        typeof (UpdateNewPreCheckoutQuery).ensure ();
        typeof (UpdateNewCustomEvent).ensure ();
        typeof (UpdateNewCustomQuery).ensure ();
        typeof (UpdatePoll).ensure ();
        typeof (UpdatePollAnswer).ensure ();
        typeof (UpdateChatMember).ensure ();
        typeof (UpdateNewChatJoinRequest).ensure ();
        typeof (UpdateChatBoost).ensure ();
        typeof (UpdateMessageReaction).ensure ();
        typeof (UpdateMessageReactions).ensure ();
        typeof (UpdatePaidMediaPurchased).ensure ();
        typeof (Updates).ensure ();
        typeof (LogStreamDefault).ensure ();
        typeof (LogStreamFile).ensure ();
        typeof (LogStreamEmpty).ensure ();
        typeof (LogVerbosityLevel).ensure ();
        typeof (LogTags).ensure ();
        typeof (UserSupportInfo).ensure ();
        typeof (TestInt).ensure ();
        typeof (TestString).ensure ();
        typeof (TestBytes).ensure ();
        typeof (TestVectorInt).ensure ();
        typeof (TestVectorIntObject).ensure ();
        typeof (TestVectorString).ensure ();
        typeof (TestVectorStringObject).ensure ();
    }

    /**
     * Init client: create request manager and set client_id
     */
    public void init () throws TDLibError {
        client_id = TDJsonApi.create_client_id ();
        request_manager = new RequestManager (this, timeout);
        request_manager.run.begin (() => {
            try {{
                version = ((OptionValueString) get_option_sync ("version")).value;
            }} catch (TDLibError.COMMON e) {{
                warning ("Error while getting init version: %s", e.message);
            }}
        });
    }

    /**
     * Returns the current authorization state; this is an offline request.
     * For informational purposes only. Use updateAuthorizationState instead
     * to maintain the current authorization state. Can be called before
     * initialization
     */
    public async AuthorizationState get_authorization_state () throws TDLibError {
        try {

        var obj = new GetAuthorizationState ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_authorization_state.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (AuthorizationState) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the parameters for TDLib initialization. Works only when the
     * current authorization state is authorizationStateWaitTdlibParameters
     * @param use_test_dc Pass true to use Telegram test environment instead
     * of the production environment
     * @param database_directory The path to the directory for the persistent
     * database; if empty, the current working directory will be used
     * @param files_directory The path to the directory for storing files; if
     * empty, database_directory will be used
     * @param database_encryption_key Encryption key for the database. If the
     * encryption key is invalid, then an error with code 401 will be
     * returned
     * @param use_file_database Pass true to keep information about
     * downloaded and uploaded files between application restarts
     * @param use_chat_info_database Pass true to keep cache of users, basic
     * groups, supergroups, channels and secret chats between restarts.
     * Implies use_file_database
     * @param use_message_database Pass true to keep cache of chats and
     * messages between restarts. Implies use_chat_info_database
     * @param use_secret_chats Pass true to enable support for secret chats
     * @param api_id Application identifier for Telegram API access, which
     * can be obtained at [[https://my.telegram.org]]
     * @param api_hash Application identifier hash for Telegram API access,
     * which can be obtained at [[https://my.telegram.org]]
     * @param system_language_code IETF language tag of the user's operating
     * system language; must be non-empty
     * @param device_model Model of the device the application is being run
     * on; must be non-empty
     * @param system_version Version of the operating system the application
     * is being run on. If empty, the version is automatically detected by
     * TDLib
     * @param application_version Application version; must be non-empty
     */
    public async Ok set_tdlib_parameters (
        bool use_test_dc,
        string database_directory,
        string files_directory,
        Bytes database_encryption_key,
        bool use_file_database,
        bool use_chat_info_database,
        bool use_message_database,
        bool use_secret_chats,
        int32 api_id,
        string api_hash,
        string system_language_code,
        string device_model,
        string system_version,
        string application_version
    ) throws TDLibError {
        try {

        var obj = new SetTdlibParameters (
            use_test_dc,
            database_directory,
            files_directory,
            database_encryption_key,
            use_file_database,
            use_chat_info_database,
            use_message_database,
            use_secret_chats,
            api_id,
            api_hash,
            system_language_code,
            device_model,
            system_version,
            application_version
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_tdlib_parameters.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the phone number of the user and sends an authentication code to
     * the user. Works only when the current authorization state is
     * authorizationStateWaitPhoneNumber,
     * or if there is no pending authentication query and the current
     * authorization state is authorizationStateWaitEmailAddress,
     * authorizationStateWaitEmailCode, authorizationStateWaitCode,
     * authorizationStateWaitRegistration, or authorizationStateWaitPassword
     * @param phone_number The phone number of the user, in international
     * format
     * @param settings Settings for the authentication of the user's phone
     * number; pass null to use default settings
     */
    public async Ok set_authentication_phone_number (
        string phone_number,
        PhoneNumberAuthenticationSettings settings
    ) throws TDLibError {
        try {

        var obj = new SetAuthenticationPhoneNumber (
            phone_number,
            settings
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_authentication_phone_number.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the email address of the user and sends an authentication code to
     * the email address. Works only when the current authorization state is
     * authorizationStateWaitEmailAddress
     * @param email_address The email address of the user
     */
    public async Ok set_authentication_email_address (
        string email_address
    ) throws TDLibError {
        try {

        var obj = new SetAuthenticationEmailAddress (
            email_address
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_authentication_email_address.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Resends an authentication code to the user. Works only when the
     * current authorization state is authorizationStateWaitCode, the
     * next_code_type of the result is not null
     * and the server-specified timeout has passed, or when the current
     * authorization state is authorizationStateWaitEmailCode
     * @param reason Reason of code resending; pass null if unknown
     */
    public async Ok resend_authentication_code (
        ResendCodeReason reason
    ) throws TDLibError {
        try {

        var obj = new ResendAuthenticationCode (
            reason
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (resend_authentication_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks the authentication of an email address. Works only when the
     * current authorization state is authorizationStateWaitEmailCode
     * @param code Email address authentication to check
     */
    public async Ok check_authentication_email_code (
        EmailAddressAuthentication code
    ) throws TDLibError {
        try {

        var obj = new CheckAuthenticationEmailCode (
            code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_authentication_email_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks the authentication code. Works only when the current
     * authorization state is authorizationStateWaitCode
     * @param code Authentication code to check
     */
    public async Ok check_authentication_code (
        string code
    ) throws TDLibError {
        try {

        var obj = new CheckAuthenticationCode (
            code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_authentication_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Requests QR code authentication by scanning a QR code on another
     * logged in device. Works only when the current authorization state is
     * authorizationStateWaitPhoneNumber,
     * or if there is no pending authentication query and the current
     * authorization state is authorizationStateWaitEmailAddress,
     * authorizationStateWaitEmailCode, authorizationStateWaitCode,
     * authorizationStateWaitRegistration, or authorizationStateWaitPassword
     * @param other_user_ids List of user identifiers of other users
     * currently using the application
     */
    public async Ok request_qr_code_authentication (
        Gee.ArrayList<int64?> other_user_ids
    ) throws TDLibError {
        try {

        var obj = new RequestQrCodeAuthentication (
            other_user_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (request_qr_code_authentication.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Finishes user registration. Works only when the current authorization
     * state is authorizationStateWaitRegistration
     * @param first_name The first name of the user; 1-64 characters
     * @param last_name The last name of the user; 0-64 characters
     * @param disable_notification Pass true to disable notification about
     * the current user joining Telegram for other users that added them to
     * contact list
     */
    public async Ok register_user (
        string first_name,
        string last_name,
        bool disable_notification
    ) throws TDLibError {
        try {

        var obj = new RegisterUser (
            first_name,
            last_name,
            disable_notification
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (register_user.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Resets the login email address. May return an error with a message
     * "TASK_ALREADY_EXISTS" if reset is still pending.
     * Works only when the current authorization state is
     * authorizationStateWaitEmailCode and
     * authorization_state.can_reset_email_address == true
     */
    public async Ok reset_authentication_email_address () throws TDLibError {
        try {

        var obj = new ResetAuthenticationEmailAddress ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reset_authentication_email_address.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks the 2-step verification password for correctness. Works only
     * when the current authorization state is authorizationStateWaitPassword
     * @param password The 2-step verification password to check
     */
    public async Ok check_authentication_password (
        string password
    ) throws TDLibError {
        try {

        var obj = new CheckAuthenticationPassword (
            password
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_authentication_password.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Requests to send a 2-step verification password recovery code to an
     * email address that was previously set up. Works only when the current
     * authorization state is authorizationStateWaitPassword
     */
    public async Ok request_authentication_password_recovery () throws TDLibError {
        try {

        var obj = new RequestAuthenticationPasswordRecovery ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (request_authentication_password_recovery.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks whether a 2-step verification password recovery code sent to an
     * email address is valid. Works only when the current authorization
     * state is authorizationStateWaitPassword
     * @param recovery_code Recovery code to check
     */
    public async Ok check_authentication_password_recovery_code (
        string recovery_code
    ) throws TDLibError {
        try {

        var obj = new CheckAuthenticationPasswordRecoveryCode (
            recovery_code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_authentication_password_recovery_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Recovers the 2-step verification password with a password recovery
     * code sent to an email address that was previously set up. Works only
     * when the current authorization state is authorizationStateWaitPassword
     * @param recovery_code Recovery code to check
     * @param new_password New 2-step verification password of the user; may
     * be empty to remove the password
     * @param new_hint New password hint; may be empty
     */
    public async Ok recover_authentication_password (
        string recovery_code,
        string new_password,
        string new_hint
    ) throws TDLibError {
        try {

        var obj = new RecoverAuthenticationPassword (
            recovery_code,
            new_password,
            new_hint
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (recover_authentication_password.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends Firebase Authentication SMS to the phone number of the user.
     * Works only when the current authorization state is
     * authorizationStateWaitCode and the server returned code of the type
     * authenticationCodeTypeFirebaseAndroid or
     * authenticationCodeTypeFirebaseIos
     * @param token Play Integrity API or SafetyNet Attestation API token for
     * the Android application, or secret from push notification for the iOS
     * application
     */
    public async Ok send_authentication_firebase_sms (
        string token
    ) throws TDLibError {
        try {

        var obj = new SendAuthenticationFirebaseSms (
            token
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_authentication_firebase_sms.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Reports that authentication code wasn't delivered via SMS; for
     * official mobile applications only. Works only when the current
     * authorization state is authorizationStateWaitCode
     * @param mobile_network_code Current mobile network code
     */
    public async Ok report_authentication_code_missing (
        string mobile_network_code
    ) throws TDLibError {
        try {

        var obj = new ReportAuthenticationCodeMissing (
            mobile_network_code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_authentication_code_missing.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks the authentication token of a bot; to log in as a bot. Works
     * only when the current authorization state is
     * authorizationStateWaitPhoneNumber. Can be used instead of
     * {@link Client.set_authentication_phone_number} and
     * {@link Client.check_authentication_code} to log in
     * @param token The bot token
     */
    public async Ok check_authentication_bot_token (
        string token
    ) throws TDLibError {
        try {

        var obj = new CheckAuthenticationBotToken (
            token
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_authentication_bot_token.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Closes the TDLib instance after a proper logout. Requires an available
     * network connection. All local data will be destroyed. After the logout
     * completes, updateAuthorizationState with authorizationStateClosed will
     * be sent
     */
    public async Ok log_out () throws TDLibError {
        try {

        var obj = new LogOut ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (log_out.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Closes the TDLib instance. All databases will be flushed to disk and
     * properly closed. After the {@link Client.close} completes,
     * updateAuthorizationState with authorizationStateClosed will be sent.
     * Can be called before initialization
     */
    public async Ok close () throws TDLibError {
        try {

        var obj = new Close ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (close.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Closes the TDLib instance, destroying all local data without a proper
     * logout. The current user session will remain in the list of all active
     * sessions. All local data will be destroyed.
     * After the destruction completes updateAuthorizationState with
     * authorizationStateClosed will be sent. Can be called before
     * authorization
     */
    public async Ok destroy () throws TDLibError {
        try {

        var obj = new Destroy ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (destroy.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Confirms QR code authentication on another device. Returns created
     * session on success
     * @param link A link from a QR code. The link must be scanned by the
     * in-app camera
     */
    public async Session confirm_qr_code_authentication (
        string link
    ) throws TDLibError {
        try {

        var obj = new ConfirmQrCodeAuthentication (
            link
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (confirm_qr_code_authentication.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Session) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns all updates needed to restore current TDLib state, i.e. all
     * actual updateAuthorizationState/updateUser/updateNewChat and others.
     * This is especially useful if TDLib is run in a separate process. Can
     * be called before initialization
     */
    public async Updates get_current_state () throws TDLibError {
        try {

        var obj = new GetCurrentState ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_current_state.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Updates) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the database encryption key. Usually the encryption key is
     * never changed and is stored in some OS keychain
     * @param new_encryption_key New encryption key
     */
    public async Ok set_database_encryption_key (
        Bytes new_encryption_key
    ) throws TDLibError {
        try {

        var obj = new SetDatabaseEncryptionKey (
            new_encryption_key
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_database_encryption_key.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the current state of 2-step verification
     */
    public async PasswordState get_password_state () throws TDLibError {
        try {

        var obj = new GetPasswordState ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_password_state.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PasswordState) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the 2-step verification password for the current user. If a
     * new recovery email address is specified, then the change will not be
     * applied until the new recovery email address is confirmed
     * @param old_password Previous 2-step verification password of the user
     * @param new_password New 2-step verification password of the user; may
     * be empty to remove the password
     * @param new_hint New password hint; may be empty
     * @param set_recovery_email_address Pass true to change also the
     * recovery email address
     * @param new_recovery_email_address New recovery email address; may be
     * empty
     */
    public async PasswordState set_password (
        string old_password,
        string new_password,
        string new_hint,
        bool set_recovery_email_address,
        string new_recovery_email_address
    ) throws TDLibError {
        try {

        var obj = new SetPassword (
            old_password,
            new_password,
            new_hint,
            set_recovery_email_address,
            new_recovery_email_address
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_password.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PasswordState) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the login email address of the user. The email address can be
     * changed only if the current user already has login email and
     * passwordState.login_email_address_pattern is non-empty.
     * The change will not be applied until the new login email address is
     * confirmed with {@link Client.check_login_email_address_code} To use
     * Apple ID/Google ID instead of an email address, call
     * {@link Client.check_login_email_address_code} directly
     * @param new_login_email_address New login email address
     */
    public async EmailAddressAuthenticationCodeInfo set_login_email_address (
        string new_login_email_address
    ) throws TDLibError {
        try {

        var obj = new SetLoginEmailAddress (
            new_login_email_address
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_login_email_address.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (EmailAddressAuthenticationCodeInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Resends the login email address verification code
     */
    public async EmailAddressAuthenticationCodeInfo resend_login_email_address_code () throws TDLibError {
        try {

        var obj = new ResendLoginEmailAddressCode ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (resend_login_email_address_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (EmailAddressAuthenticationCodeInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks the login email address authentication
     * @param code Email address authentication to check
     */
    public async Ok check_login_email_address_code (
        EmailAddressAuthentication code
    ) throws TDLibError {
        try {

        var obj = new CheckLoginEmailAddressCode (
            code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_login_email_address_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a 2-step verification recovery email address that was
     * previously set up. This method can be used to verify a password
     * provided by the user
     * @param password The 2-step verification password for the current user
     */
    public async RecoveryEmailAddress get_recovery_email_address (
        string password
    ) throws TDLibError {
        try {

        var obj = new GetRecoveryEmailAddress (
            password
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_recovery_email_address.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (RecoveryEmailAddress) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the 2-step verification recovery email address of the user. If
     * a new recovery email address is specified, then the change will not be
     * applied until the new recovery email address is confirmed.
     * If new_recovery_email_address is the same as the email address that is
     * currently set up, this call succeeds immediately and aborts all other
     * requests waiting for an email confirmation
     * @param password The 2-step verification password of the current user
     * @param new_recovery_email_address New recovery email address
     */
    public async PasswordState set_recovery_email_address (
        string password,
        string new_recovery_email_address
    ) throws TDLibError {
        try {

        var obj = new SetRecoveryEmailAddress (
            password,
            new_recovery_email_address
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_recovery_email_address.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PasswordState) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks the 2-step verification recovery email address verification
     * code
     * @param code Verification code to check
     */
    public async PasswordState check_recovery_email_address_code (
        string code
    ) throws TDLibError {
        try {

        var obj = new CheckRecoveryEmailAddressCode (
            code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_recovery_email_address_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PasswordState) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Resends the 2-step verification recovery email address verification
     * code
     */
    public async PasswordState resend_recovery_email_address_code () throws TDLibError {
        try {

        var obj = new ResendRecoveryEmailAddressCode ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (resend_recovery_email_address_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PasswordState) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Cancels verification of the 2-step verification recovery email address
     */
    public async PasswordState cancel_recovery_email_address_verification () throws TDLibError {
        try {

        var obj = new CancelRecoveryEmailAddressVerification ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (cancel_recovery_email_address_verification.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PasswordState) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Requests to send a 2-step verification password recovery code to an
     * email address that was previously set up
     */
    public async EmailAddressAuthenticationCodeInfo request_password_recovery () throws TDLibError {
        try {

        var obj = new RequestPasswordRecovery ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (request_password_recovery.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (EmailAddressAuthenticationCodeInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks whether a 2-step verification password recovery code sent to an
     * email address is valid
     * @param recovery_code Recovery code to check
     */
    public async Ok check_password_recovery_code (
        string recovery_code
    ) throws TDLibError {
        try {

        var obj = new CheckPasswordRecoveryCode (
            recovery_code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_password_recovery_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Recovers the 2-step verification password using a recovery code sent
     * to an email address that was previously set up
     * @param recovery_code Recovery code to check
     * @param new_password New 2-step verification password of the user; may
     * be empty to remove the password
     * @param new_hint New password hint; may be empty
     */
    public async PasswordState recover_password (
        string recovery_code,
        string new_password,
        string new_hint
    ) throws TDLibError {
        try {

        var obj = new RecoverPassword (
            recovery_code,
            new_password,
            new_hint
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (recover_password.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PasswordState) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes 2-step verification password without previous password and
     * access to recovery email address. The password can't be reset
     * immediately and the request needs to be repeated after the specified
     * time
     */
    public async ResetPasswordResult reset_password () throws TDLibError {
        try {

        var obj = new ResetPassword ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reset_password.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ResetPasswordResult) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Cancels reset of 2-step verification password. The method can be
     * called if passwordState.pending_reset_date > 0
     */
    public async Ok cancel_password_reset () throws TDLibError {
        try {

        var obj = new CancelPasswordReset ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (cancel_password_reset.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Creates a new temporary password for processing payments
     * @param password The 2-step verification password of the current user
     * @param valid_for Time during which the temporary password will be
     * valid, in seconds; must be between 60 and 86400
     */
    public async TemporaryPasswordState create_temporary_password (
        string password,
        int32 valid_for
    ) throws TDLibError {
        try {

        var obj = new CreateTemporaryPassword (
            password,
            valid_for
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_temporary_password.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (TemporaryPasswordState) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about the current temporary password
     */
    public async TemporaryPasswordState get_temporary_password_state () throws TDLibError {
        try {

        var obj = new GetTemporaryPasswordState ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_temporary_password_state.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (TemporaryPasswordState) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the current user
     */
    public async User get_me () throws TDLibError {
        try {

        var obj = new GetMe ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_me.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (User) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a user by their identifier. This is an
     * offline request if the current user is not a bot
     * @param user_id User identifier
     */
    public async User get_user (
        int64 user_id
    ) throws TDLibError {
        try {

        var obj = new GetUser (
            user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_user.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (User) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns full information about a user by their identifier
     * @param user_id User identifier
     */
    public async UserFullInfo get_user_full_info (
        int64 user_id
    ) throws TDLibError {
        try {

        var obj = new GetUserFullInfo (
            user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_user_full_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (UserFullInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a basic group by its identifier. This is an
     * offline request if the current user is not a bot
     * @param basic_group_id Basic group identifier
     */
    public async BasicGroup get_basic_group (
        int64 basic_group_id
    ) throws TDLibError {
        try {

        var obj = new GetBasicGroup (
            basic_group_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_basic_group.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BasicGroup) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns full information about a basic group by its identifier
     * @param basic_group_id Basic group identifier
     */
    public async BasicGroupFullInfo get_basic_group_full_info (
        int64 basic_group_id
    ) throws TDLibError {
        try {

        var obj = new GetBasicGroupFullInfo (
            basic_group_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_basic_group_full_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BasicGroupFullInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a supergroup or a channel by its identifier.
     * This is an offline request if the current user is not a bot
     * @param supergroup_id Supergroup or channel identifier
     */
    public async Supergroup get_supergroup (
        int64 supergroup_id
    ) throws TDLibError {
        try {

        var obj = new GetSupergroup (
            supergroup_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_supergroup.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Supergroup) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns full information about a supergroup or a channel by its
     * identifier, cached for up to 1 minute
     * @param supergroup_id Supergroup or channel identifier
     */
    public async SupergroupFullInfo get_supergroup_full_info (
        int64 supergroup_id
    ) throws TDLibError {
        try {

        var obj = new GetSupergroupFullInfo (
            supergroup_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_supergroup_full_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (SupergroupFullInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a secret chat by its identifier. This is an
     * offline request
     * @param secret_chat_id Secret chat identifier
     */
    public async SecretChat get_secret_chat (
        int32 secret_chat_id
    ) throws TDLibError {
        try {

        var obj = new GetSecretChat (
            secret_chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_secret_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (SecretChat) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a chat by its identifier; this is an offline
     * request if the current user is not a bot
     * @param chat_id Chat identifier
     */
    public async Chat get_chat (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetChat (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chat) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a message. Returns a 404 error if the
     * message doesn't exist
     * @param chat_id Identifier of the chat the message belongs to
     * @param message_id Identifier of the message to get
     */
    public async Message get_message (
        int64 chat_id,
        int64 message_id
    ) throws TDLibError {
        try {

        var obj = new GetMessage (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Message) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a message, if it is available without
     * sending network request. Returns a 404 error if message isn't
     * available locally. This is an offline request
     * @param chat_id Identifier of the chat the message belongs to
     * @param message_id Identifier of the message to get
     */
    public async Message get_message_locally (
        int64 chat_id,
        int64 message_id
    ) throws TDLibError {
        try {

        var obj = new GetMessageLocally (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_locally.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Message) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a non-bundled message that is replied by a
     * given message. Also, returns the pinned message, the game message, the
     * invoice message,
     * the message with a previously set same background, the giveaway
     * message, and the topic creation message for messages of the types
     * messagePinMessage, messageGameScore, messagePaymentSuccessful,
     * messageChatSetBackground, messageGiveawayCompleted and topic messages
     * without non-bundled replied message respectively.
     * Returns a 404 error if the message doesn't exist
     * @param chat_id Identifier of the chat the message belongs to
     * @param message_id Identifier of the reply message
     */
    public async Message get_replied_message (
        int64 chat_id,
        int64 message_id
    ) throws TDLibError {
        try {

        var obj = new GetRepliedMessage (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_replied_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Message) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a newest pinned message in the chat. Returns
     * a 404 error if the message doesn't exist
     * @param chat_id Identifier of the chat the message belongs to
     */
    public async Message get_chat_pinned_message (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetChatPinnedMessage (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_pinned_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Message) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a message with the callback button that
     * originated a callback query; for bots only
     * @param chat_id Identifier of the chat the message belongs to
     * @param message_id Message identifier
     * @param callback_query_id Identifier of the callback query
     */
    public async Message get_callback_query_message (
        int64 chat_id,
        int64 message_id,
        int64 callback_query_id
    ) throws TDLibError {
        try {

        var obj = new GetCallbackQueryMessage (
            chat_id,
            message_id,
            callback_query_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_callback_query_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Message) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about messages. If a message is not found, returns
     * null on the corresponding position of the result
     * @param chat_id Identifier of the chat the messages belong to
     * @param message_ids Identifiers of the messages to get
     */
    public async Messages get_messages (
        int64 chat_id,
        Gee.ArrayList<int64?> message_ids
    ) throws TDLibError {
        try {

        var obj = new GetMessages (
            chat_id,
            message_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Messages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns properties of a message; this is an offline request
     * @param chat_id Chat identifier
     * @param message_id Identifier of the message
     */
    public async MessageProperties get_message_properties (
        int64 chat_id,
        int64 message_id
    ) throws TDLibError {
        try {

        var obj = new GetMessageProperties (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_properties.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MessageProperties) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a message thread. Can be used only if
     * messageProperties.can_get_message_thread == true
     * @param chat_id Chat identifier
     * @param message_id Identifier of the message
     */
    public async MessageThreadInfo get_message_thread (
        int64 chat_id,
        int64 message_id
    ) throws TDLibError {
        try {

        var obj = new GetMessageThread (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_thread.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MessageThreadInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns read date of a recent outgoing message in a private chat. The
     * method can be called if messageProperties.can_get_read_date == true
     * @param chat_id Chat identifier
     * @param message_id Identifier of the message
     */
    public async MessageReadDate get_message_read_date (
        int64 chat_id,
        int64 message_id
    ) throws TDLibError {
        try {

        var obj = new GetMessageReadDate (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_read_date.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MessageReadDate) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns viewers of a recent outgoing message in a basic group or a
     * supergroup chat. For video notes and voice notes only users, opened
     * content of the message, are returned. The method can be called if
     * messageProperties.can_get_viewers == true
     * @param chat_id Chat identifier
     * @param message_id Identifier of the message
     */
    public async MessageViewers get_message_viewers (
        int64 chat_id,
        int64 message_id
    ) throws TDLibError {
        try {

        var obj = new GetMessageViewers (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_viewers.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MessageViewers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a file; this is an offline request
     * @param file_id Identifier of the file to get
     */
    public async File get_file (
        int32 file_id
    ) throws TDLibError {
        try {

        var obj = new GetFile (
            file_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_file.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (File) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a file by its remote identifier; this is an
     * offline request. Can be used to register a URL as a file for further
     * uploading, or sending as a message. Even the request succeeds, the
     * file can be used only if it is still accessible to the user.
     * For example, if the file is from a message, then the message must be
     * not deleted and accessible to the user. If the file database is
     * disabled, then the corresponding object with the file must be
     * preloaded by the application
     * @param remote_file_id Remote identifier of the file to get
     * @param file_type File type; pass null if unknown
     */
    public async File get_remote_file (
        string remote_file_id,
        FileType file_type
    ) throws TDLibError {
        try {

        var obj = new GetRemoteFile (
            remote_file_id,
            file_type
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_remote_file.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (File) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Loads more chats from a chat list. The loaded chats and their
     * positions in the chat list will be sent through updates. Chats are
     * sorted by the pair (chat.position.order, chat.id) in descending order.
     * Returns a 404 error if all chats have been loaded
     * @param chat_list The chat list in which to load chats; pass null to
     * load chats from the main chat list
     * @param limit The maximum number of chats to be loaded. For optimal
     * performance, the number of loaded chats is chosen by TDLib and can be
     * smaller than the specified limit, even if the end of the list is not
     * reached
     */
    public async Ok load_chats (
        ChatList chat_list,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new LoadChats (
            chat_list,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (load_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an ordered list of chats from the beginning of a chat list.
     * For informational purposes only. Use {@link Client.load_chats} and
     * updates processing instead to maintain chat lists in a consistent
     * state
     * @param chat_list The chat list in which to return chats; pass null to
     * get chats from the main chat list
     * @param limit The maximum number of chats to be returned
     */
    public async Chats get_chats (
        ChatList chat_list,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetChats (
            chat_list,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches a public chat by its username. Currently, only private chats,
     * supergroups and channels can be public. Returns the chat if found;
     * otherwise, an error is returned
     * @param username Username to be resolved
     */
    public async Chat search_public_chat (
        string username
    ) throws TDLibError {
        try {

        var obj = new SearchPublicChat (
            username
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_public_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chat) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches public chats by looking for specified query in their username
     * and title. Currently, only private chats, supergroups and channels can
     * be public. Returns a meaningful number of results.
     * Excludes private chats with contacts and chats from the chat list from
     * the results
     * @param query Query to search for
     */
    public async Chats search_public_chats (
        string query
    ) throws TDLibError {
        try {

        var obj = new SearchPublicChats (
            query
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_public_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for the specified query in the title and username of already
     * known chats; this is an offline request. Returns chats in the order
     * seen in the main chat list
     * @param query Query to search for. If the query is empty, returns up to
     * 50 recently found chats
     * @param limit The maximum number of chats to be returned
     */
    public async Chats search_chats (
        string query,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new SearchChats (
            query,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for the specified query in the title and username of already
     * known chats via request to the server. Returns chats in the order seen
     * in the main chat list
     * @param query Query to search for
     * @param limit The maximum number of chats to be returned
     */
    public async Chats search_chats_on_server (
        string query,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new SearchChatsOnServer (
            query,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_chats_on_server.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a list of channel chats recommended to the current user
     */
    public async Chats get_recommended_chats () throws TDLibError {
        try {

        var obj = new GetRecommendedChats ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_recommended_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a list of chats similar to the given chat
     * @param chat_id Identifier of the target chat; must be an identifier of
     * a channel chat
     */
    public async Chats get_chat_similar_chats (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetChatSimilarChats (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_similar_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns approximate number of chats similar to the given chat
     * @param chat_id Identifier of the target chat; must be an identifier of
     * a channel chat
     * @param return_local Pass true to get the number of chats without
     * sending network requests, or -1 if the number of chats is unknown
     * locally
     */
    public async Count get_chat_similar_chat_count (
        int64 chat_id,
        bool return_local
    ) throws TDLibError {
        try {

        var obj = new GetChatSimilarChatCount (
            chat_id,
            return_local
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_similar_chat_count.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Count) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs TDLib that a chat was opened from the list of similar chats.
     * The method is independent of {@link Client.open_chat} and
     * {@link Client.close_chat} methods
     * @param chat_id Identifier of the original chat, which similar chats
     * were requested
     * @param opened_chat_id Identifier of the opened chat
     */
    public async Ok open_chat_similar_chat (
        int64 chat_id,
        int64 opened_chat_id
    ) throws TDLibError {
        try {

        var obj = new OpenChatSimilarChat (
            chat_id,
            opened_chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (open_chat_similar_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a list of bots similar to the given bot
     * @param bot_user_id User identifier of the target bot
     */
    public async Users get_bot_similar_bots (
        int64 bot_user_id
    ) throws TDLibError {
        try {

        var obj = new GetBotSimilarBots (
            bot_user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_bot_similar_bots.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Users) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns approximate number of bots similar to the given bot
     * @param bot_user_id User identifier of the target bot
     * @param return_local Pass true to get the number of bots without
     * sending network requests, or -1 if the number of bots is unknown
     * locally
     */
    public async Count get_bot_similar_bot_count (
        int64 bot_user_id,
        bool return_local
    ) throws TDLibError {
        try {

        var obj = new GetBotSimilarBotCount (
            bot_user_id,
            return_local
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_bot_similar_bot_count.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Count) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs TDLib that a bot was opened from the list of similar bots
     * @param bot_user_id Identifier of the original bot, which similar bots
     * were requested
     * @param opened_bot_user_id Identifier of the opened bot
     */
    public async Ok open_bot_similar_bot (
        int64 bot_user_id,
        int64 opened_bot_user_id
    ) throws TDLibError {
        try {

        var obj = new OpenBotSimilarBot (
            bot_user_id,
            opened_bot_user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (open_bot_similar_bot.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a list of frequently used chats
     * @param category Category of chats to be returned
     * @param limit The maximum number of chats to be returned; up to 30
     */
    public async Chats get_top_chats (
        TopChatCategory category,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetTopChats (
            category,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_top_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes a chat from the list of frequently used chats. Supported only
     * if the chat info database is enabled
     * @param category Category of frequently used chats
     * @param chat_id Chat identifier
     */
    public async Ok remove_top_chat (
        TopChatCategory category,
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new RemoveTopChat (
            category,
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_top_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for the specified query in the title and username of up to 50
     * recently found chats; this is an offline request
     * @param query Query to search for
     * @param limit The maximum number of chats to be returned
     */
    public async Chats search_recently_found_chats (
        string query,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new SearchRecentlyFoundChats (
            query,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_recently_found_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a chat to the list of recently found chats. The chat is added to
     * the beginning of the list. If the chat is already in the list, it will
     * be removed from the list first
     * @param chat_id Identifier of the chat to add
     */
    public async Ok add_recently_found_chat (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new AddRecentlyFoundChat (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_recently_found_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes a chat from the list of recently found chats
     * @param chat_id Identifier of the chat to be removed
     */
    public async Ok remove_recently_found_chat (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new RemoveRecentlyFoundChat (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_recently_found_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Clears the list of recently found chats
     */
    public async Ok clear_recently_found_chats () throws TDLibError {
        try {

        var obj = new ClearRecentlyFoundChats ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clear_recently_found_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns recently opened chats; this is an offline request. Returns
     * chats in the order of last opening
     * @param limit The maximum number of chats to be returned
     */
    public async Chats get_recently_opened_chats (
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetRecentlyOpenedChats (
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_recently_opened_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks whether a username can be set for a chat
     * @param chat_id Chat identifier; must be identifier of a supergroup
     * chat, or a channel chat, or a private chat with self, or 0 if the chat
     * is being created
     * @param username Username to be checked
     */
    public async CheckChatUsernameResult check_chat_username (
        int64 chat_id,
        string username
    ) throws TDLibError {
        try {

        var obj = new CheckChatUsername (
            chat_id,
            username
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_chat_username.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (CheckChatUsernameResult) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a list of public chats of the specified type, owned by the
     * user
     * @param type_ Type of the public chats to return
     */
    public async Chats get_created_public_chats (
        PublicChatType type_
    ) throws TDLibError {
        try {

        var obj = new GetCreatedPublicChats (
            type_
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_created_public_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks whether the maximum number of owned public chats has been
     * reached. Returns corresponding error if the limit was reached. The
     * limit can be increased with Telegram Premium
     * @param type_ Type of the public chats, for which to check the limit
     */
    public async Ok check_created_public_chats_limit (
        PublicChatType type_
    ) throws TDLibError {
        try {

        var obj = new CheckCreatedPublicChatsLimit (
            type_
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_created_public_chats_limit.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a list of basic group and supergroup chats, which can be used
     * as a discussion group for a channel. Returned basic group chats must
     * be first upgraded to supergroups before they can be set as a
     * discussion group.
     * To set a returned supergroup as a discussion group, access to its old
     * messages must be enabled using
     * {@link Client.toggle_supergroup_is_all_history_available} first
     */
    public async Chats get_suitable_discussion_chats () throws TDLibError {
        try {

        var obj = new GetSuitableDiscussionChats ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_suitable_discussion_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a list of recently inactive supergroups and channels. Can be
     * used when user reaches limit on the number of joined supergroups and
     * channels and receives CHANNELS_TOO_MUCH error. Also, the limit can be
     * increased with Telegram Premium
     */
    public async Chats get_inactive_supergroup_chats () throws TDLibError {
        try {

        var obj = new GetInactiveSupergroupChats ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_inactive_supergroup_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a list of channel chats, which can be used as a personal chat
     */
    public async Chats get_suitable_personal_chats () throws TDLibError {
        try {

        var obj = new GetSuitablePersonalChats ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_suitable_personal_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Loads more Saved Messages topics. The loaded topics will be sent
     * through updateSavedMessagesTopic. Topics are sorted by their
     * topic.order in descending order. Returns a 404 error if all topics
     * have been loaded
     * @param limit The maximum number of topics to be loaded. For optimal
     * performance, the number of loaded topics is chosen by TDLib and can be
     * smaller than the specified limit, even if the end of the list is not
     * reached
     */
    public async Ok load_saved_messages_topics (
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new LoadSavedMessagesTopics (
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (load_saved_messages_topics.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns messages in a Saved Messages topic. The messages are returned
     * in reverse chronological order (i.e., in order of decreasing
     * message_id)
     * @param saved_messages_topic_id Identifier of Saved Messages topic
     * which messages will be fetched
     * @param from_message_id Identifier of the message starting from which
     * messages must be fetched; use 0 to get results from the last message
     * @param offset Specify 0 to get results from exactly the message
     * from_message_id or a negative offset up to 99 to get additionally some
     * newer messages
     * @param limit The maximum number of messages to be returned; must be
     * positive and can't be greater than 100. If the offset is negative, the
     * limit must be greater than or equal to -offset. For optimal
     * performance, the number of returned messages is chosen by TDLib and
     * can be smaller than the specified limit
     */
    public async Messages get_saved_messages_topic_history (
        int64 saved_messages_topic_id,
        int64 from_message_id,
        int32 offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetSavedMessagesTopicHistory (
            saved_messages_topic_id,
            from_message_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_saved_messages_topic_history.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Messages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the last message sent in a Saved Messages topic no later than
     * the specified date
     * @param saved_messages_topic_id Identifier of Saved Messages topic
     * which message will be returned
     * @param date Point in time (Unix timestamp) relative to which to search
     * for messages
     */
    public async Message get_saved_messages_topic_message_by_date (
        int64 saved_messages_topic_id,
        int32 date
    ) throws TDLibError {
        try {

        var obj = new GetSavedMessagesTopicMessageByDate (
            saved_messages_topic_id,
            date
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_saved_messages_topic_message_by_date.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Message) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes all messages in a Saved Messages topic
     * @param saved_messages_topic_id Identifier of Saved Messages topic
     * which messages will be deleted
     */
    public async Ok delete_saved_messages_topic_history (
        int64 saved_messages_topic_id
    ) throws TDLibError {
        try {

        var obj = new DeleteSavedMessagesTopicHistory (
            saved_messages_topic_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_saved_messages_topic_history.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes all messages between the specified dates in a Saved Messages
     * topic. Messages sent in the last 30 seconds will not be deleted
     * @param saved_messages_topic_id Identifier of Saved Messages topic
     * which messages will be deleted
     * @param min_date The minimum date of the messages to delete
     * @param max_date The maximum date of the messages to delete
     */
    public async Ok delete_saved_messages_topic_messages_by_date (
        int64 saved_messages_topic_id,
        int32 min_date,
        int32 max_date
    ) throws TDLibError {
        try {

        var obj = new DeleteSavedMessagesTopicMessagesByDate (
            saved_messages_topic_id,
            min_date,
            max_date
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_saved_messages_topic_messages_by_date.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the pinned state of a Saved Messages topic. There can be up to
     * getOption("pinned_saved_messages_topic_count_max") pinned topics. The
     * limit can be increased with Telegram Premium
     * @param saved_messages_topic_id Identifier of Saved Messages topic to
     * pin or unpin
     * @param is_pinned Pass true to pin the topic; pass false to unpin it
     */
    public async Ok toggle_saved_messages_topic_is_pinned (
        int64 saved_messages_topic_id,
        bool is_pinned
    ) throws TDLibError {
        try {

        var obj = new ToggleSavedMessagesTopicIsPinned (
            saved_messages_topic_id,
            is_pinned
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_saved_messages_topic_is_pinned.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the order of pinned Saved Messages topics
     * @param saved_messages_topic_ids Identifiers of the new pinned Saved
     * Messages topics
     */
    public async Ok set_pinned_saved_messages_topics (
        Gee.ArrayList<int64?> saved_messages_topic_ids
    ) throws TDLibError {
        try {

        var obj = new SetPinnedSavedMessagesTopics (
            saved_messages_topic_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_pinned_saved_messages_topics.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a list of common group chats with a given user. Chats are
     * sorted by their type and creation date
     * @param user_id User identifier
     * @param offset_chat_id Chat identifier starting from which to return
     * chats; use 0 for the first request
     * @param limit The maximum number of chats to be returned; up to 100
     */
    public async Chats get_groups_in_common (
        int64 user_id,
        int64 offset_chat_id,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetGroupsInCommon (
            user_id,
            offset_chat_id,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_groups_in_common.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns messages in a chat. The messages are returned in reverse
     * chronological order (i.e., in order of decreasing message_id).
     * For optimal performance, the number of returned messages is chosen by
     * TDLib. This is an offline request if only_local is true
     * @param chat_id Chat identifier
     * @param from_message_id Identifier of the message starting from which
     * history must be fetched; use 0 to get results from the last message
     * @param offset Specify 0 to get results from exactly the message
     * from_message_id or a negative offset up to 99 to get additionally some
     * newer messages
     * @param limit The maximum number of messages to be returned; must be
     * positive and can't be greater than 100. If the offset is negative, the
     * limit must be greater than or equal to -offset. For optimal
     * performance, the number of returned messages is chosen by TDLib and
     * can be smaller than the specified limit
     * @param only_local Pass true to get only messages that are available
     * without sending network requests
     */
    public async Messages get_chat_history (
        int64 chat_id,
        int64 from_message_id,
        int32 offset,
        int32 limit,
        bool only_local
    ) throws TDLibError {
        try {

        var obj = new GetChatHistory (
            chat_id,
            from_message_id,
            offset,
            limit,
            only_local
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_history.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Messages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns messages in a message thread of a message. Can be used only if
     * messageProperties.can_get_message_thread == true. Message thread of a
     * channel message is in the channel's linked supergroup.
     * The messages are returned in reverse chronological order (i.e., in
     * order of decreasing message_id). For optimal performance, the number
     * of returned messages is chosen by TDLib
     * @param chat_id Chat identifier
     * @param message_id Message identifier, which thread history needs to be
     * returned
     * @param from_message_id Identifier of the message starting from which
     * history must be fetched; use 0 to get results from the last message
     * @param offset Specify 0 to get results from exactly the message
     * from_message_id or a negative offset up to 99 to get additionally some
     * newer messages
     * @param limit The maximum number of messages to be returned; must be
     * positive and can't be greater than 100. If the offset is negative, the
     * limit must be greater than or equal to -offset. For optimal
     * performance, the number of returned messages is chosen by TDLib and
     * can be smaller than the specified limit
     */
    public async Messages get_message_thread_history (
        int64 chat_id,
        int64 message_id,
        int64 from_message_id,
        int32 offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetMessageThreadHistory (
            chat_id,
            message_id,
            from_message_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_thread_history.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Messages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes all messages in the chat. Use
     * chat.can_be_deleted_only_for_self and
     * chat.can_be_deleted_for_all_users fields to find whether and how the
     * method can be applied to the chat
     * @param chat_id Chat identifier
     * @param remove_from_chat_list Pass true to remove the chat from all
     * chat lists
     * @param revoke Pass true to delete chat history for all users
     */
    public async Ok delete_chat_history (
        int64 chat_id,
        bool remove_from_chat_list,
        bool revoke
    ) throws TDLibError {
        try {

        var obj = new DeleteChatHistory (
            chat_id,
            remove_from_chat_list,
            revoke
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_chat_history.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes a chat along with all messages in the corresponding chat for
     * all chat members. For group chats this will release the usernames and
     * remove all members.
     * Use the field chat.can_be_deleted_for_all_users to find whether the
     * method can be applied to the chat
     * @param chat_id Chat identifier
     */
    public async Ok delete_chat (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new DeleteChat (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for messages with given words in the chat. Returns the
     * results in reverse chronological order, i.e. in order of decreasing
     * message_id. Cannot be used in secret chats with a non-empty query
     * {@link Client.search_secret_messages} must be used instead), or
     * without an enabled message database. For optimal performance, the
     * number of returned messages is chosen by TDLib and can be smaller than
     * the specified limit.
     * A combination of query, sender_id, filter and message_thread_id search
     * criteria is expected to be supported, only if it is required for
     * Telegram official application implementation
     * @param chat_id Identifier of the chat in which to search messages
     * @param query Query to search for
     * @param sender_id Identifier of the sender of messages to search for;
     * pass null to search for messages from any sender. Not supported in
     * secret chats
     * @param from_message_id Identifier of the message starting from which
     * history must be fetched; use 0 to get results from the last message
     * @param offset Specify 0 to get results from exactly the message
     * from_message_id or a negative offset to get the specified message and
     * some newer messages
     * @param limit The maximum number of messages to be returned; must be
     * positive and can't be greater than 100. If the offset is negative, the
     * limit must be greater than -offset. For optimal performance, the
     * number of returned messages is chosen by TDLib and can be smaller than
     * the specified limit
     * @param filter Additional filter for messages to search; pass null to
     * search for all messages
     * @param message_thread_id If not 0, only messages in the specified
     * thread will be returned; supergroups only
     * @param saved_messages_topic_id If not 0, only messages in the
     * specified Saved Messages topic will be returned; pass 0 to return all
     * messages, or for chats other than Saved Messages
     */
    public async FoundChatMessages search_chat_messages (
        int64 chat_id,
        string query,
        MessageSender sender_id,
        int64 from_message_id,
        int32 offset,
        int32 limit,
        SearchMessagesFilter filter,
        int64 message_thread_id,
        int64 saved_messages_topic_id
    ) throws TDLibError {
        try {

        var obj = new SearchChatMessages (
            chat_id,
            query,
            sender_id,
            from_message_id,
            offset,
            limit,
            filter,
            message_thread_id,
            saved_messages_topic_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_chat_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundChatMessages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for messages in all chats except secret chats. Returns the
     * results in reverse chronological order (i.e., in order of decreasing
     * (date, chat_id, message_id)).
     * For optimal performance, the number of returned messages is chosen by
     * TDLib and can be smaller than the specified limit
     * @param chat_list Chat list in which to search messages; pass null to
     * search in all chats regardless of their chat list. Only Main and
     * Archive chat lists are supported
     * @param query Query to search for
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of messages to be returned; up to 100.
     * For optimal performance, the number of returned messages is chosen by
     * TDLib and can be smaller than the specified limit
     * @param filter Additional filter for messages to search; pass null to
     * search for all messages. Filters searchMessagesFilterMention,
     * searchMessagesFilterUnreadMention, searchMessagesFilterUnreadReaction,
     * searchMessagesFilterFailedToSend, and searchMessagesFilterPinned are
     * unsupported in this function
     * @param chat_type_filter Additional filter for type of the chat of the
     * searched messages; pass null to search for messages in all chats
     * @param min_date If not 0, the minimum date of the messages to return
     * @param max_date If not 0, the maximum date of the messages to return
     */
    public async FoundMessages search_messages (
        ChatList chat_list,
        string query,
        string offset,
        int32 limit,
        SearchMessagesFilter filter,
        SearchMessagesChatTypeFilter chat_type_filter,
        int32 min_date,
        int32 max_date
    ) throws TDLibError {
        try {

        var obj = new SearchMessages (
            chat_list,
            query,
            offset,
            limit,
            filter,
            chat_type_filter,
            min_date,
            max_date
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundMessages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for messages in secret chats. Returns the results in reverse
     * chronological order. For optimal performance, the number of returned
     * messages is chosen by TDLib
     * @param chat_id Identifier of the chat in which to search. Specify 0 to
     * search in all secret chats
     * @param query Query to search for. If empty,
     * {@link Client.search_chat_messages} must be used instead
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of messages to be returned; up to 100.
     * For optimal performance, the number of returned messages is chosen by
     * TDLib and can be smaller than the specified limit
     * @param filter Additional filter for messages to search; pass null to
     * search for all messages
     */
    public async FoundMessages search_secret_messages (
        int64 chat_id,
        string query,
        string offset,
        int32 limit,
        SearchMessagesFilter filter
    ) throws TDLibError {
        try {

        var obj = new SearchSecretMessages (
            chat_id,
            query,
            offset,
            limit,
            filter
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_secret_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundMessages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for messages tagged by the given reaction and with the given
     * words in the Saved Messages chat; for Telegram Premium users only.
     * Returns the results in reverse chronological order, i.e. in order of
     * decreasing message_id.
     * For optimal performance, the number of returned messages is chosen by
     * TDLib and can be smaller than the specified limit
     * @param saved_messages_topic_id If not 0, only messages in the
     * specified Saved Messages topic will be considered; pass 0 to consider
     * all messages
     * @param tag Tag to search for; pass null to return all suitable
     * messages
     * @param query Query to search for
     * @param from_message_id Identifier of the message starting from which
     * messages must be fetched; use 0 to get results from the last message
     * @param offset Specify 0 to get results from exactly the message
     * from_message_id or a negative offset to get the specified message and
     * some newer messages
     * @param limit The maximum number of messages to be returned; must be
     * positive and can't be greater than 100. If the offset is negative, the
     * limit must be greater than -offset. For optimal performance, the
     * number of returned messages is chosen by TDLib and can be smaller than
     * the specified limit
     */
    public async FoundChatMessages search_saved_messages (
        int64 saved_messages_topic_id,
        ReactionType tag,
        string query,
        int64 from_message_id,
        int32 offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new SearchSavedMessages (
            saved_messages_topic_id,
            tag,
            query,
            from_message_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_saved_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundChatMessages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for call messages. Returns the results in reverse
     * chronological order (i.e., in order of decreasing message_id). For
     * optimal performance, the number of returned messages is chosen by
     * TDLib
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of messages to be returned; up to 100.
     * For optimal performance, the number of returned messages is chosen by
     * TDLib and can be smaller than the specified limit
     * @param only_missed Pass true to search only for messages with
     * missed/declined calls
     */
    public async FoundMessages search_call_messages (
        string offset,
        int32 limit,
        bool only_missed
    ) throws TDLibError {
        try {

        var obj = new SearchCallMessages (
            offset,
            limit,
            only_missed
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_call_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundMessages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for outgoing messages with content of the type
     * messageDocument in all chats except secret chats. Returns the results
     * in reverse chronological order
     * @param query Query to search for in document file name and message
     * caption
     * @param limit The maximum number of messages to be returned; up to 100
     */
    public async FoundMessages search_outgoing_document_messages (
        string query,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new SearchOutgoingDocumentMessages (
            query,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_outgoing_document_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundMessages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for public channel posts containing the given hashtag or
     * cashtag. For optimal performance, the number of returned messages is
     * chosen by TDLib and can be smaller than the specified limit
     * @param tag Hashtag or cashtag to search for
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of messages to be returned; up to 100.
     * For optimal performance, the number of returned messages is chosen by
     * TDLib and can be smaller than the specified limit
     */
    public async FoundMessages search_public_messages_by_tag (
        string tag,
        string offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new SearchPublicMessagesByTag (
            tag,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_public_messages_by_tag.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundMessages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for public stories containing the given hashtag or cashtag.
     * For optimal performance, the number of returned stories is chosen by
     * TDLib and can be smaller than the specified limit
     * @param story_sender_chat_id Identifier of the chat that posted the
     * stories to search for; pass 0 to search stories in all chats
     * @param tag Hashtag or cashtag to search for
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of stories to be returned; up to 100.
     * For optimal performance, the number of returned stories is chosen by
     * TDLib and can be smaller than the specified limit
     */
    public async FoundStories search_public_stories_by_tag (
        int64 story_sender_chat_id,
        string tag,
        string offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new SearchPublicStoriesByTag (
            story_sender_chat_id,
            tag,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_public_stories_by_tag.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundStories) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for public stories by the given address location. For optimal
     * performance, the number of returned stories is chosen by TDLib and can
     * be smaller than the specified limit
     * @param address Address of the location
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of stories to be returned; up to 100.
     * For optimal performance, the number of returned stories is chosen by
     * TDLib and can be smaller than the specified limit
     */
    public async FoundStories search_public_stories_by_location (
        LocationAddress address,
        string offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new SearchPublicStoriesByLocation (
            address,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_public_stories_by_location.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundStories) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for public stories from the given venue. For optimal
     * performance, the number of returned stories is chosen by TDLib and can
     * be smaller than the specified limit
     * @param venue_provider Provider of the venue
     * @param venue_id Identifier of the venue in the provider database
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of stories to be returned; up to 100.
     * For optimal performance, the number of returned stories is chosen by
     * TDLib and can be smaller than the specified limit
     */
    public async FoundStories search_public_stories_by_venue (
        string venue_provider,
        string venue_id,
        string offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new SearchPublicStoriesByVenue (
            venue_provider,
            venue_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_public_stories_by_venue.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundStories) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns recently searched for hashtags or cashtags by their prefix
     * @param tag_prefix Prefix of hashtags or cashtags to return
     * @param limit The maximum number of items to be returned
     */
    public async Hashtags get_searched_for_tags (
        string tag_prefix,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetSearchedForTags (
            tag_prefix,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_searched_for_tags.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Hashtags) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes a hashtag or a cashtag from the list of recently searched for
     * hashtags or cashtags
     * @param tag Hashtag or cashtag to delete
     */
    public async Ok remove_searched_for_tag (
        string tag
    ) throws TDLibError {
        try {

        var obj = new RemoveSearchedForTag (
            tag
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_searched_for_tag.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Clears the list of recently searched for hashtags or cashtags
     * @param clear_cashtags Pass true to clear the list of recently searched
     * for cashtags; otherwise, the list of recently searched for hashtags
     * will be cleared
     */
    public async Ok clear_searched_for_tags (
        bool clear_cashtags
    ) throws TDLibError {
        try {

        var obj = new ClearSearchedForTags (
            clear_cashtags
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clear_searched_for_tags.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes all call messages
     * @param revoke Pass true to delete the messages for all users
     */
    public async Ok delete_all_call_messages (
        bool revoke
    ) throws TDLibError {
        try {

        var obj = new DeleteAllCallMessages (
            revoke
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_all_call_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about the recent locations of chat members that
     * were sent to the chat. Returns up to 1 location message per user
     * @param chat_id Chat identifier
     * @param limit The maximum number of messages to be returned
     */
    public async Messages search_chat_recent_location_messages (
        int64 chat_id,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new SearchChatRecentLocationMessages (
            chat_id,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_chat_recent_location_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Messages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the last message sent in a chat no later than the specified
     * date. Returns a 404 error if such message doesn't exist
     * @param chat_id Chat identifier
     * @param date Point in time (Unix timestamp) relative to which to search
     * for messages
     */
    public async Message get_chat_message_by_date (
        int64 chat_id,
        int32 date
    ) throws TDLibError {
        try {

        var obj = new GetChatMessageByDate (
            chat_id,
            date
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_message_by_date.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Message) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns sparse positions of messages of the specified type in the chat
     * to be used for shared media scroll implementation. Returns the results
     * in reverse chronological order (i.e., in order of decreasing
     * message_id).
     * Cannot be used in secret chats or with
     * searchMessagesFilterFailedToSend filter without an enabled message
     * database
     * @param chat_id Identifier of the chat in which to return information
     * about message positions
     * @param filter Filter for message content. Filters
     * searchMessagesFilterEmpty, searchMessagesFilterMention,
     * searchMessagesFilterUnreadMention, and
     * searchMessagesFilterUnreadReaction are unsupported in this function
     * @param from_message_id The message identifier from which to return
     * information about message positions
     * @param limit The expected number of message positions to be returned;
     * 50-2000. A smaller number of positions can be returned, if there are
     * not enough appropriate messages
     * @param saved_messages_topic_id If not 0, only messages in the
     * specified Saved Messages topic will be considered; pass 0 to consider
     * all messages, or for chats other than Saved Messages
     */
    public async MessagePositions get_chat_sparse_message_positions (
        int64 chat_id,
        SearchMessagesFilter filter,
        int64 from_message_id,
        int32 limit,
        int64 saved_messages_topic_id
    ) throws TDLibError {
        try {

        var obj = new GetChatSparseMessagePositions (
            chat_id,
            filter,
            from_message_id,
            limit,
            saved_messages_topic_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_sparse_message_positions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MessagePositions) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about the next messages of the specified type in
     * the chat split by days. Returns the results in reverse chronological
     * order. Can return partial result for the last returned day. Behavior
     * of this method depends on the value of the option "utc_time_offset"
     * @param chat_id Identifier of the chat in which to return information
     * about messages
     * @param filter Filter for message content. Filters
     * searchMessagesFilterEmpty, searchMessagesFilterMention,
     * searchMessagesFilterUnreadMention, and
     * searchMessagesFilterUnreadReaction are unsupported in this function
     * @param from_message_id The message identifier from which to return
     * information about messages; use 0 to get results from the last message
     * @param saved_messages_topic_id If not0, only messages in the specified
     * Saved Messages topic will be considered; pass 0 to consider all
     * messages, or for chats other than Saved Messages
     */
    public async MessageCalendar get_chat_message_calendar (
        int64 chat_id,
        SearchMessagesFilter filter,
        int64 from_message_id,
        int64 saved_messages_topic_id
    ) throws TDLibError {
        try {

        var obj = new GetChatMessageCalendar (
            chat_id,
            filter,
            from_message_id,
            saved_messages_topic_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_message_calendar.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MessageCalendar) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns approximate number of messages of the specified type in the
     * chat
     * @param chat_id Identifier of the chat in which to count messages
     * @param filter Filter for message content; searchMessagesFilterEmpty is
     * unsupported in this function
     * @param saved_messages_topic_id If not 0, only messages in the
     * specified Saved Messages topic will be counted; pass 0 to count all
     * messages, or for chats other than Saved Messages
     * @param return_local Pass true to get the number of messages without
     * sending network requests, or -1 if the number of messages is unknown
     * locally
     */
    public async Count get_chat_message_count (
        int64 chat_id,
        SearchMessagesFilter filter,
        int64 saved_messages_topic_id,
        bool return_local
    ) throws TDLibError {
        try {

        var obj = new GetChatMessageCount (
            chat_id,
            filter,
            saved_messages_topic_id,
            return_local
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_message_count.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Count) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns approximate 1-based position of a message among messages,
     * which can be found by the specified filter in the chat. Cannot be used
     * in secret chats
     * @param chat_id Identifier of the chat in which to find message
     * position
     * @param message_id Message identifier
     * @param filter Filter for message content; searchMessagesFilterEmpty,
     * searchMessagesFilterUnreadMention, searchMessagesFilterUnreadReaction,
     * and searchMessagesFilterFailedToSend are unsupported in this function
     * @param message_thread_id If not 0, only messages in the specified
     * thread will be considered; supergroups only
     * @param saved_messages_topic_id If not 0, only messages in the
     * specified Saved Messages topic will be considered; pass 0 to consider
     * all relevant messages, or for chats other than Saved Messages
     */
    public async Count get_chat_message_position (
        int64 chat_id,
        int64 message_id,
        SearchMessagesFilter filter,
        int64 message_thread_id,
        int64 saved_messages_topic_id
    ) throws TDLibError {
        try {

        var obj = new GetChatMessagePosition (
            chat_id,
            message_id,
            filter,
            message_thread_id,
            saved_messages_topic_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_message_position.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Count) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns all scheduled messages in a chat. The messages are returned in
     * reverse chronological order (i.e., in order of decreasing message_id)
     * @param chat_id Chat identifier
     */
    public async Messages get_chat_scheduled_messages (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetChatScheduledMessages (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_scheduled_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Messages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns sponsored messages to be shown in a chat; for channel chats
     * and chats with bots only
     * @param chat_id Identifier of the chat
     */
    public async SponsoredMessages get_chat_sponsored_messages (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetChatSponsoredMessages (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_sponsored_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (SponsoredMessages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs TDLib that the user opened the sponsored chat via the button,
     * the name, the chat photo, a mention in the sponsored message text, or
     * the media in the sponsored message
     * @param chat_id Chat identifier of the sponsored message
     * @param message_id Identifier of the sponsored message
     * @param is_media_click Pass true if the media was clicked in the
     * sponsored message
     * @param from_fullscreen Pass true if the user expanded the video from
     * the sponsored message fullscreen before the click
     */
    public async Ok click_chat_sponsored_message (
        int64 chat_id,
        int64 message_id,
        bool is_media_click,
        bool from_fullscreen
    ) throws TDLibError {
        try {

        var obj = new ClickChatSponsoredMessage (
            chat_id,
            message_id,
            is_media_click,
            from_fullscreen
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (click_chat_sponsored_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Reports a sponsored message to Telegram moderators
     * @param chat_id Chat identifier of the sponsored message
     * @param message_id Identifier of the sponsored message
     * @param option_id Option identifier chosen by the user; leave empty for
     * the initial request
     */
    public async ReportChatSponsoredMessageResult report_chat_sponsored_message (
        int64 chat_id,
        int64 message_id,
        Bytes option_id
    ) throws TDLibError {
        try {

        var obj = new ReportChatSponsoredMessage (
            chat_id,
            message_id,
            option_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_chat_sponsored_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ReportChatSponsoredMessageResult) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes an active notification from notification list. Needs to be
     * called only if the notification is removed by the current user
     * @param notification_group_id Identifier of notification group to which
     * the notification belongs
     * @param notification_id Identifier of removed notification
     */
    public async Ok remove_notification (
        int32 notification_group_id,
        int32 notification_id
    ) throws TDLibError {
        try {

        var obj = new RemoveNotification (
            notification_group_id,
            notification_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_notification.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes a group of active notifications. Needs to be called only if
     * the notification group is removed by the current user
     * @param notification_group_id Notification group identifier
     * @param max_notification_id The maximum identifier of removed
     * notifications
     */
    public async Ok remove_notification_group (
        int32 notification_group_id,
        int32 max_notification_id
    ) throws TDLibError {
        try {

        var obj = new RemoveNotificationGroup (
            notification_group_id,
            max_notification_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_notification_group.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an HTTPS link to a message in a chat. Available only if
     * messageProperties.can_get_link, or if
     * messageProperties.can_get_media_timestamp_links and a media timestamp
     * link is generated. This is an offline request
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param media_timestamp If not 0, timestamp from which the
     * video/audio/video note/voice note/story playing must start, in
     * seconds. The media can be in the message content or in its link
     * preview
     * @param for_album Pass true to create a link for the whole media album
     * @param in_message_thread Pass true to create a link to the message as
     * a channel post comment, in a message thread, or a forum topic
     */
    public async MessageLink get_message_link (
        int64 chat_id,
        int64 message_id,
        int32 media_timestamp,
        bool for_album,
        bool in_message_thread
    ) throws TDLibError {
        try {

        var obj = new GetMessageLink (
            chat_id,
            message_id,
            media_timestamp,
            for_album,
            in_message_thread
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MessageLink) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an HTML code for embedding the message. Available only if
     * messageProperties.can_get_embedding_code
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param for_album Pass true to return an HTML code for embedding of the
     * whole media album
     */
    public async Text get_message_embedding_code (
        int64 chat_id,
        int64 message_id,
        bool for_album
    ) throws TDLibError {
        try {

        var obj = new GetMessageEmbeddingCode (
            chat_id,
            message_id,
            for_album
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_embedding_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a public or private message link. Can be
     * called for any internal link of the type internalLinkTypeMessage
     * @param url The message link
     */
    public async MessageLinkInfo get_message_link_info (
        string url
    ) throws TDLibError {
        try {

        var obj = new GetMessageLinkInfo (
            url
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_link_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MessageLinkInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Translates a text to the given language. If the current user is a
     * Telegram Premium user, then text formatting is preserved
     * @param text Text to translate
     * @param to_language_code Language code of the language to which the
     * message is translated. Must be one of "af", "sq", "am", "ar", "hy",
     * "az", "eu", "be", "bn", "bs", "bg", "ca", "ceb", "zh-CN", "zh",
     * "zh-Hans", "zh-TW", "zh-Hant", "co", "hr", "cs", "da", "nl", "en",
     * "eo", "et", "fi", "fr", "fy", "gl", "ka", "de", "el", "gu", "ht",
     * "ha", "haw", "he", "iw", "hi", "hmn", "hu", "is", "ig", "id", "in",
     * "ga", "it", "ja", "jv", "kn", "kk", "km", "rw", "ko", "ku", "ky",
     * "lo", "la", "lv", "lt", "lb", "mk", "mg", "ms", "ml", "mt", "mi",
     * "mr", "mn", "my", "ne", "no", "ny", "or", "ps", "fa", "pl", "pt",
     * "pa", "ro", "ru", "sm", "gd", "sr", "st", "sn", "sd", "si", "sk",
     * "sl", "so", "es", "su", "sw", "sv", "tl", "tg", "ta", "tt", "te",
     * "th", "tr", "tk", "uk", "ur", "ug", "uz", "vi", "cy", "xh", "yi",
     * "ji", "yo", "zu"
     */
    public async FormattedText translate_text (
        FormattedText text,
        string to_language_code
    ) throws TDLibError {
        try {

        var obj = new TranslateText (
            text,
            to_language_code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (translate_text.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FormattedText) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Extracts text or caption of the given message and translates it to the
     * given language. If the current user is a Telegram Premium user, then
     * text formatting is preserved
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param to_language_code Language code of the language to which the
     * message is translated. Must be one of "af", "sq", "am", "ar", "hy",
     * "az", "eu", "be", "bn", "bs", "bg", "ca", "ceb", "zh-CN", "zh",
     * "zh-Hans", "zh-TW", "zh-Hant", "co", "hr", "cs", "da", "nl", "en",
     * "eo", "et", "fi", "fr", "fy", "gl", "ka", "de", "el", "gu", "ht",
     * "ha", "haw", "he", "iw", "hi", "hmn", "hu", "is", "ig", "id", "in",
     * "ga", "it", "ja", "jv", "kn", "kk", "km", "rw", "ko", "ku", "ky",
     * "lo", "la", "lv", "lt", "lb", "mk", "mg", "ms", "ml", "mt", "mi",
     * "mr", "mn", "my", "ne", "no", "ny", "or", "ps", "fa", "pl", "pt",
     * "pa", "ro", "ru", "sm", "gd", "sr", "st", "sn", "sd", "si", "sk",
     * "sl", "so", "es", "su", "sw", "sv", "tl", "tg", "ta", "tt", "te",
     * "th", "tr", "tk", "uk", "ur", "ug", "uz", "vi", "cy", "xh", "yi",
     * "ji", "yo", "zu"
     */
    public async FormattedText translate_message_text (
        int64 chat_id,
        int64 message_id,
        string to_language_code
    ) throws TDLibError {
        try {

        var obj = new TranslateMessageText (
            chat_id,
            message_id,
            to_language_code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (translate_message_text.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FormattedText) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Recognizes speech in a video note or a voice note message
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message. Use
     * messageProperties.can_recognize_speech to check whether the message is
     * suitable
     */
    public async Ok recognize_speech (
        int64 chat_id,
        int64 message_id
    ) throws TDLibError {
        try {

        var obj = new RecognizeSpeech (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (recognize_speech.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Rates recognized speech in a video note or a voice note message
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param is_good Pass true if the speech recognition is good
     */
    public async Ok rate_speech_recognition (
        int64 chat_id,
        int64 message_id,
        bool is_good
    ) throws TDLibError {
        try {

        var obj = new RateSpeechRecognition (
            chat_id,
            message_id,
            is_good
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (rate_speech_recognition.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of message sender identifiers, which can be used to
     * send messages in a chat
     * @param chat_id Chat identifier
     */
    public async ChatMessageSenders get_chat_available_message_senders (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetChatAvailableMessageSenders (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_available_message_senders.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatMessageSenders) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Selects a message sender to send messages in a chat
     * @param chat_id Chat identifier
     * @param message_sender_id New message sender for the chat
     */
    public async Ok set_chat_message_sender (
        int64 chat_id,
        MessageSender message_sender_id
    ) throws TDLibError {
        try {

        var obj = new SetChatMessageSender (
            chat_id,
            message_sender_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_message_sender.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends a message. Returns the sent message
     * @param chat_id Target chat
     * @param message_thread_id If not 0, the message thread identifier in
     * which the message will be sent
     * @param reply_to Information about the message or story to be replied;
     * pass null if none
     * @param options Options to be used to send the message; pass null to
     * use default options
     * @param reply_markup Markup for replying to the message; pass null if
     * none; for bots only
     * @param input_message_content The content of the message to be sent
     */
    public async Message send_message (
        int64 chat_id,
        int64 message_thread_id,
        InputMessageReplyTo reply_to,
        MessageSendOptions options,
        ReplyMarkup reply_markup,
        InputMessageContent input_message_content
    ) throws TDLibError {
        try {

        var obj = new SendMessage (
            chat_id,
            message_thread_id,
            reply_to,
            options,
            reply_markup,
            input_message_content
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Message) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends 2-10 messages grouped together into an album. Currently, only
     * audio, document, photo and video messages can be grouped into an
     * album.
     * Documents and audio files can be only grouped in an album with
     * messages of the same type. Returns sent messages
     * @param chat_id Target chat
     * @param message_thread_id If not 0, the message thread identifier in
     * which the messages will be sent
     * @param reply_to Information about the message or story to be replied;
     * pass null if none
     * @param options Options to be used to send the messages; pass null to
     * use default options
     * @param input_message_contents Contents of messages to be sent. At most
     * 10 messages can be added to an album. All messages must have the same
     * value of show_caption_above_media
     */
    public async Messages send_message_album (
        int64 chat_id,
        int64 message_thread_id,
        InputMessageReplyTo reply_to,
        MessageSendOptions options,
        Gee.ArrayList<InputMessageContent?> input_message_contents
    ) throws TDLibError {
        try {

        var obj = new SendMessageAlbum (
            chat_id,
            message_thread_id,
            reply_to,
            options,
            input_message_contents
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_message_album.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Messages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Invites a bot to a chat (if it is not yet a member) and sends it the
     * /start command; requires can_invite_users member right. Bots can't be
     * invited to a private chat other than the chat with the bot.
     * Bots can't be invited to channels (although they can be added as
     * admins) and secret chats. Returns the sent message
     * @param bot_user_id Identifier of the bot
     * @param chat_id Identifier of the target chat
     * @param parameter A hidden parameter sent to the bot for deep linking
     * purposes ([[https://core.telegram.org/bots#deep-linking]])
     */
    public async Message send_bot_start_message (
        int64 bot_user_id,
        int64 chat_id,
        string parameter
    ) throws TDLibError {
        try {

        var obj = new SendBotStartMessage (
            bot_user_id,
            chat_id,
            parameter
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_bot_start_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Message) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends the result of an inline query as a message. Returns the sent
     * message. Always clears a chat draft message
     * @param chat_id Target chat
     * @param message_thread_id If not 0, the message thread identifier in
     * which the message will be sent
     * @param reply_to Information about the message or story to be replied;
     * pass null if none
     * @param options Options to be used to send the message; pass null to
     * use default options
     * @param query_id Identifier of the inline query
     * @param result_id Identifier of the inline query result
     * @param hide_via_bot Pass true to hide the bot, via which the message
     * is sent. Can be used only for bots
     * getOption("animation_search_bot_username"),
     * getOption("photo_search_bot_username"), and
     * getOption("venue_search_bot_username")
     */
    public async Message send_inline_query_result_message (
        int64 chat_id,
        int64 message_thread_id,
        InputMessageReplyTo reply_to,
        MessageSendOptions options,
        int64 query_id,
        string result_id,
        bool hide_via_bot
    ) throws TDLibError {
        try {

        var obj = new SendInlineQueryResultMessage (
            chat_id,
            message_thread_id,
            reply_to,
            options,
            query_id,
            result_id,
            hide_via_bot
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_inline_query_result_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Message) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Forwards previously sent messages. Returns the forwarded messages in
     * the same order as the message identifiers passed in message_ids. If a
     * message can't be forwarded, null will be returned instead of the
     * message
     * @param chat_id Identifier of the chat to which to forward messages
     * @param message_thread_id If not 0, the message thread identifier in
     * which the message will be sent; for forum threads only
     * @param from_chat_id Identifier of the chat from which to forward
     * messages
     * @param message_ids Identifiers of the messages to forward. Message
     * identifiers must be in a strictly increasing order. At most 100
     * messages can be forwarded simultaneously. A message can be forwarded
     * only if messageProperties.can_be_forwarded
     * @param options Options to be used to send the messages; pass null to
     * use default options
     * @param send_copy Pass true to copy content of the messages without
     * reference to the original sender. Always true if the messages are
     * forwarded to a secret chat or are local. Use
     * messageProperties.can_be_saved and
     * messageProperties.can_be_copied_to_secret_chat to check whether the
     * message is suitable
     * @param remove_caption Pass true to remove media captions of message
     * copies. Ignored if send_copy is false
     */
    public async Messages forward_messages (
        int64 chat_id,
        int64 message_thread_id,
        int64 from_chat_id,
        Gee.ArrayList<int64?> message_ids,
        MessageSendOptions options,
        bool send_copy,
        bool remove_caption
    ) throws TDLibError {
        try {

        var obj = new ForwardMessages (
            chat_id,
            message_thread_id,
            from_chat_id,
            message_ids,
            options,
            send_copy,
            remove_caption
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (forward_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Messages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends messages from a quick reply shortcut. Requires Telegram Business
     * subscription
     * @param chat_id Identifier of the chat to which to send messages. The
     * chat must be a private chat with a regular user
     * @param shortcut_id Unique identifier of the quick reply shortcut
     * @param sending_id Non-persistent identifier, which will be returned
     * back in messageSendingStatePending object and can be used to match
     * sent messages and corresponding updateNewMessage updates
     */
    public async Messages send_quick_reply_shortcut_messages (
        int64 chat_id,
        int32 shortcut_id,
        int32 sending_id
    ) throws TDLibError {
        try {

        var obj = new SendQuickReplyShortcutMessages (
            chat_id,
            shortcut_id,
            sending_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_quick_reply_shortcut_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Messages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Resends messages which failed to send. Can be called only for messages
     * for which messageSendingStateFailed.can_retry is true and after
     * specified in messageSendingStateFailed.retry_after time passed.
     * If a message is re-sent, the corresponding failed to send message is
     * deleted. Returns the sent messages in the same order as the message
     * identifiers passed in message_ids. If a message can't be re-sent, null
     * will be returned instead of the message
     * @param chat_id Identifier of the chat to send messages
     * @param message_ids Identifiers of the messages to resend. Message
     * identifiers must be in a strictly increasing order
     * @param quote New manually chosen quote from the message to be replied;
     * pass null if none. Ignored if more than one message is re-sent, or if
     * messageSendingStateFailed.need_another_reply_quote == false
     */
    public async Messages resend_messages (
        int64 chat_id,
        Gee.ArrayList<int64?> message_ids,
        InputTextQuote quote
    ) throws TDLibError {
        try {

        var obj = new ResendMessages (
            chat_id,
            message_ids,
            quote
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (resend_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Messages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a local message to a chat. The message is persistent across
     * application restarts only if the message database is used. Returns the
     * added message
     * @param chat_id Target chat
     * @param sender_id Identifier of the sender of the message
     * @param reply_to Information about the message or story to be replied;
     * pass null if none
     * @param disable_notification Pass true to disable notification for the
     * message
     * @param input_message_content The content of the message to be added
     */
    public async Message add_local_message (
        int64 chat_id,
        MessageSender sender_id,
        InputMessageReplyTo reply_to,
        bool disable_notification,
        InputMessageContent input_message_content
    ) throws TDLibError {
        try {

        var obj = new AddLocalMessage (
            chat_id,
            sender_id,
            reply_to,
            disable_notification,
            input_message_content
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_local_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Message) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes messages
     * @param chat_id Chat identifier
     * @param message_ids Identifiers of the messages to be deleted. Use
     * messageProperties.can_be_deleted_only_for_self and
     * messageProperties.can_be_deleted_for_all_users to get suitable
     * messages
     * @param revoke Pass true to delete messages for all chat members.
     * Always true for supergroups, channels and secret chats
     */
    public async Ok delete_messages (
        int64 chat_id,
        Gee.ArrayList<int64?> message_ids,
        bool revoke
    ) throws TDLibError {
        try {

        var obj = new DeleteMessages (
            chat_id,
            message_ids,
            revoke
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes all messages sent by the specified message sender in a chat.
     * Supported only for supergroups; requires can_delete_messages
     * administrator right
     * @param chat_id Chat identifier
     * @param sender_id Identifier of the sender of messages to delete
     */
    public async Ok delete_chat_messages_by_sender (
        int64 chat_id,
        MessageSender sender_id
    ) throws TDLibError {
        try {

        var obj = new DeleteChatMessagesBySender (
            chat_id,
            sender_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_chat_messages_by_sender.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes all messages between the specified dates in a chat. Supported
     * only for private chats and basic groups. Messages sent in the last 30
     * seconds will not be deleted
     * @param chat_id Chat identifier
     * @param min_date The minimum date of the messages to delete
     * @param max_date The maximum date of the messages to delete
     * @param revoke Pass true to delete chat messages for all users; private
     * chats only
     */
    public async Ok delete_chat_messages_by_date (
        int64 chat_id,
        int32 min_date,
        int32 max_date,
        bool revoke
    ) throws TDLibError {
        try {

        var obj = new DeleteChatMessagesByDate (
            chat_id,
            min_date,
            max_date,
            revoke
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_chat_messages_by_date.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits the text of a message (or a text of a game message). Returns the
     * edited message after the edit is completed on the server side
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message. Use
     * messageProperties.can_be_edited to check whether the message can be
     * edited
     * @param reply_markup The new message reply markup; pass null if none;
     * for bots only
     * @param input_message_content New text content of the message. Must be
     * of type inputMessageText
     */
    public async Message edit_message_text (
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup,
        InputMessageContent input_message_content
    ) throws TDLibError {
        try {

        var obj = new EditMessageText (
            chat_id,
            message_id,
            reply_markup,
            input_message_content
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_message_text.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Message) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits the message content of a live location. Messages can be edited
     * for a limited period of time specified in the live location.
     * Returns the edited message after the edit is completed on the server
     * side
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message. Use
     * messageProperties.can_be_edited to check whether the message can be
     * edited
     * @param reply_markup The new message reply markup; pass null if none;
     * for bots only
     * @param location New location content of the message; pass null to stop
     * sharing the live location
     * @param live_period New time relative to the message send date, for
     * which the location can be updated, in seconds. If 0x7FFFFFFF
     * specified, then the location can be updated forever. Otherwise, must
     * not exceed the current live_period by more than a day, and the live
     * location expiration date must remain in the next 90 days. Pass 0 to
     * keep the current live_period
     * @param heading The new direction in which the location moves, in
     * degrees; 1-360. Pass 0 if unknown
     * @param proximity_alert_radius The new maximum distance for proximity
     * alerts, in meters (0-100000). Pass 0 if the notification is disabled
     */
    public async Message edit_message_live_location (
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup,
        Location location,
        int32 live_period,
        int32 heading,
        int32 proximity_alert_radius
    ) throws TDLibError {
        try {

        var obj = new EditMessageLiveLocation (
            chat_id,
            message_id,
            reply_markup,
            location,
            live_period,
            heading,
            proximity_alert_radius
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_message_live_location.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Message) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits the media content of a message, including message caption. If
     * only the caption needs to be edited, use
     * {@link Client.edit_message_caption} instead.
     * The type of message content in an album can't be changed with
     * exception of replacing a photo with a video or vice versa. Returns the
     * edited message after the edit is completed on the server side
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message. Use
     * messageProperties.can_edit_media to check whether the message can be
     * edited
     * @param reply_markup The new message reply markup; pass null if none;
     * for bots only
     * @param input_message_content New content of the message. Must be one
     * of the following types: inputMessageAnimation, inputMessageAudio,
     * inputMessageDocument, inputMessagePhoto or inputMessageVideo
     */
    public async Message edit_message_media (
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup,
        InputMessageContent input_message_content
    ) throws TDLibError {
        try {

        var obj = new EditMessageMedia (
            chat_id,
            message_id,
            reply_markup,
            input_message_content
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_message_media.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Message) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits the message content caption. Returns the edited message after
     * the edit is completed on the server side
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message. Use
     * messageProperties.can_be_edited to check whether the message can be
     * edited
     * @param reply_markup The new message reply markup; pass null if none;
     * for bots only
     * @param caption New message content caption;
     * 0-getOption("message_caption_length_max") characters; pass null to
     * remove caption
     * @param show_caption_above_media Pass true to show the caption above
     * the media; otherwise, the caption will be shown below the media. May
     * be true only for animation, photo, and video messages
     */
    public async Message edit_message_caption (
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup,
        FormattedText caption,
        bool show_caption_above_media
    ) throws TDLibError {
        try {

        var obj = new EditMessageCaption (
            chat_id,
            message_id,
            reply_markup,
            caption,
            show_caption_above_media
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_message_caption.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Message) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits the message reply markup; for bots only. Returns the edited
     * message after the edit is completed on the server side
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message. Use
     * messageProperties.can_be_edited to check whether the message can be
     * edited
     * @param reply_markup The new message reply markup; pass null if none
     */
    public async Message edit_message_reply_markup (
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup
    ) throws TDLibError {
        try {

        var obj = new EditMessageReplyMarkup (
            chat_id,
            message_id,
            reply_markup
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_message_reply_markup.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Message) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits the text of an inline text or game message sent via a bot; for
     * bots only
     * @param inline_message_id Inline message identifier
     * @param reply_markup The new message reply markup; pass null if none
     * @param input_message_content New text content of the message. Must be
     * of type inputMessageText
     */
    public async Ok edit_inline_message_text (
        string inline_message_id,
        ReplyMarkup reply_markup,
        InputMessageContent input_message_content
    ) throws TDLibError {
        try {

        var obj = new EditInlineMessageText (
            inline_message_id,
            reply_markup,
            input_message_content
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_inline_message_text.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits the content of a live location in an inline message sent via a
     * bot; for bots only
     * @param inline_message_id Inline message identifier
     * @param reply_markup The new message reply markup; pass null if none
     * @param location New location content of the message; pass null to stop
     * sharing the live location
     * @param live_period New time relative to the message send date, for
     * which the location can be updated, in seconds. If 0x7FFFFFFF
     * specified, then the location can be updated forever. Otherwise, must
     * not exceed the current live_period by more than a day, and the live
     * location expiration date must remain in the next 90 days. Pass 0 to
     * keep the current live_period
     * @param heading The new direction in which the location moves, in
     * degrees; 1-360. Pass 0 if unknown
     * @param proximity_alert_radius The new maximum distance for proximity
     * alerts, in meters (0-100000). Pass 0 if the notification is disabled
     */
    public async Ok edit_inline_message_live_location (
        string inline_message_id,
        ReplyMarkup reply_markup,
        Location location,
        int32 live_period,
        int32 heading,
        int32 proximity_alert_radius
    ) throws TDLibError {
        try {

        var obj = new EditInlineMessageLiveLocation (
            inline_message_id,
            reply_markup,
            location,
            live_period,
            heading,
            proximity_alert_radius
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_inline_message_live_location.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits the media content of a message with a text, an animation, an
     * audio, a document, a photo or a video in an inline message sent via a
     * bot; for bots only
     * @param inline_message_id Inline message identifier
     * @param reply_markup The new message reply markup; pass null if none;
     * for bots only
     * @param input_message_content New content of the message. Must be one
     * of the following types: inputMessageAnimation, inputMessageAudio,
     * inputMessageDocument, inputMessagePhoto or inputMessageVideo
     */
    public async Ok edit_inline_message_media (
        string inline_message_id,
        ReplyMarkup reply_markup,
        InputMessageContent input_message_content
    ) throws TDLibError {
        try {

        var obj = new EditInlineMessageMedia (
            inline_message_id,
            reply_markup,
            input_message_content
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_inline_message_media.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits the caption of an inline message sent via a bot; for bots only
     * @param inline_message_id Inline message identifier
     * @param reply_markup The new message reply markup; pass null if none
     * @param caption New message content caption; pass null to remove
     * caption; 0-getOption("message_caption_length_max") characters
     * @param show_caption_above_media Pass true to show the caption above
     * the media; otherwise, the caption will be shown below the media. May
     * be true only for animation, photo, and video messages
     */
    public async Ok edit_inline_message_caption (
        string inline_message_id,
        ReplyMarkup reply_markup,
        FormattedText caption,
        bool show_caption_above_media
    ) throws TDLibError {
        try {

        var obj = new EditInlineMessageCaption (
            inline_message_id,
            reply_markup,
            caption,
            show_caption_above_media
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_inline_message_caption.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits the reply markup of an inline message sent via a bot; for bots
     * only
     * @param inline_message_id Inline message identifier
     * @param reply_markup The new message reply markup; pass null if none
     */
    public async Ok edit_inline_message_reply_markup (
        string inline_message_id,
        ReplyMarkup reply_markup
    ) throws TDLibError {
        try {

        var obj = new EditInlineMessageReplyMarkup (
            inline_message_id,
            reply_markup
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_inline_message_reply_markup.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits the time when a scheduled message will be sent. Scheduling state
     * of all messages in the same album or forwarded together with the
     * message will be also changed
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message. Use
     * messageProperties.can_edit_scheduling_state to check whether the
     * message is suitable
     * @param scheduling_state The new message scheduling state; pass null to
     * send the message immediately. Must be null for messages in the state
     * messageSchedulingStateSendWhenVideoProcessed
     */
    public async Ok edit_message_scheduling_state (
        int64 chat_id,
        int64 message_id,
        MessageSchedulingState scheduling_state
    ) throws TDLibError {
        try {

        var obj = new EditMessageSchedulingState (
            chat_id,
            message_id,
            scheduling_state
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_message_scheduling_state.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the fact-check of a message. Can be only used if
     * messageProperties.can_set_fact_check == true
     * @param chat_id The channel chat the message belongs to
     * @param message_id Identifier of the message
     * @param text New text of the fact-check;
     * 0-getOption("fact_check_length_max") characters; pass null to remove
     * it. Only Bold, Italic, and TextUrl entities with [[https://t.me/]]
     * links are supported
     */
    public async Ok set_message_fact_check (
        int64 chat_id,
        int64 message_id,
        FormattedText text
    ) throws TDLibError {
        try {

        var obj = new SetMessageFactCheck (
            chat_id,
            message_id,
            text
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_message_fact_check.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends a message on behalf of a business account; for bots only.
     * Returns the message after it was sent
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which to send the request
     * @param chat_id Target chat
     * @param reply_to Information about the message to be replied; pass null
     * if none
     * @param disable_notification Pass true to disable notification for the
     * message
     * @param protect_content Pass true if the content of the message must be
     * protected from forwarding and saving
     * @param effect_id Identifier of the effect to apply to the message
     * @param reply_markup Markup for replying to the message; pass null if
     * none
     * @param input_message_content The content of the message to be sent
     */
    public async BusinessMessage send_business_message (
        string business_connection_id,
        int64 chat_id,
        InputMessageReplyTo reply_to,
        bool disable_notification,
        bool protect_content,
        int64 effect_id,
        ReplyMarkup reply_markup,
        InputMessageContent input_message_content
    ) throws TDLibError {
        try {

        var obj = new SendBusinessMessage (
            business_connection_id,
            chat_id,
            reply_to,
            disable_notification,
            protect_content,
            effect_id,
            reply_markup,
            input_message_content
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_business_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BusinessMessage) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends 2-10 messages grouped together into an album on behalf of a
     * business account; for bots only. Currently, only audio, document,
     * photo and video messages can be grouped into an album.
     * Documents and audio files can be only grouped in an album with
     * messages of the same type. Returns sent messages
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which to send the request
     * @param chat_id Target chat
     * @param reply_to Information about the message to be replied; pass null
     * if none
     * @param disable_notification Pass true to disable notification for the
     * message
     * @param protect_content Pass true if the content of the message must be
     * protected from forwarding and saving
     * @param effect_id Identifier of the effect to apply to the message
     * @param input_message_contents Contents of messages to be sent. At most
     * 10 messages can be added to an album. All messages must have the same
     * value of show_caption_above_media
     */
    public async BusinessMessages send_business_message_album (
        string business_connection_id,
        int64 chat_id,
        InputMessageReplyTo reply_to,
        bool disable_notification,
        bool protect_content,
        int64 effect_id,
        Gee.ArrayList<InputMessageContent?> input_message_contents
    ) throws TDLibError {
        try {

        var obj = new SendBusinessMessageAlbum (
            business_connection_id,
            chat_id,
            reply_to,
            disable_notification,
            protect_content,
            effect_id,
            input_message_contents
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_business_message_album.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BusinessMessages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits the text of a text or game message sent on behalf of a business
     * account; for bots only
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which the message was sent
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message
     * @param reply_markup The new message reply markup; pass null if none
     * @param input_message_content New text content of the message. Must be
     * of type inputMessageText
     */
    public async BusinessMessage edit_business_message_text (
        string business_connection_id,
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup,
        InputMessageContent input_message_content
    ) throws TDLibError {
        try {

        var obj = new EditBusinessMessageText (
            business_connection_id,
            chat_id,
            message_id,
            reply_markup,
            input_message_content
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_business_message_text.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BusinessMessage) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits the content of a live location in a message sent on behalf of a
     * business account; for bots only
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which the message was sent
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message
     * @param reply_markup The new message reply markup; pass null if none
     * @param location New location content of the message; pass null to stop
     * sharing the live location
     * @param live_period New time relative to the message send date, for
     * which the location can be updated, in seconds. If 0x7FFFFFFF
     * specified, then the location can be updated forever. Otherwise, must
     * not exceed the current live_period by more than a day, and the live
     * location expiration date must remain in the next 90 days. Pass 0 to
     * keep the current live_period
     * @param heading The new direction in which the location moves, in
     * degrees; 1-360. Pass 0 if unknown
     * @param proximity_alert_radius The new maximum distance for proximity
     * alerts, in meters (0-100000). Pass 0 if the notification is disabled
     */
    public async BusinessMessage edit_business_message_live_location (
        string business_connection_id,
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup,
        Location location,
        int32 live_period,
        int32 heading,
        int32 proximity_alert_radius
    ) throws TDLibError {
        try {

        var obj = new EditBusinessMessageLiveLocation (
            business_connection_id,
            chat_id,
            message_id,
            reply_markup,
            location,
            live_period,
            heading,
            proximity_alert_radius
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_business_message_live_location.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BusinessMessage) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits the media content of a message with a text, an animation, an
     * audio, a document, a photo or a video in a message sent on behalf of a
     * business account; for bots only
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which the message was sent
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message
     * @param reply_markup The new message reply markup; pass null if none;
     * for bots only
     * @param input_message_content New content of the message. Must be one
     * of the following types: inputMessageAnimation, inputMessageAudio,
     * inputMessageDocument, inputMessagePhoto or inputMessageVideo
     */
    public async BusinessMessage edit_business_message_media (
        string business_connection_id,
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup,
        InputMessageContent input_message_content
    ) throws TDLibError {
        try {

        var obj = new EditBusinessMessageMedia (
            business_connection_id,
            chat_id,
            message_id,
            reply_markup,
            input_message_content
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_business_message_media.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BusinessMessage) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits the caption of a message sent on behalf of a business account;
     * for bots only
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which the message was sent
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message
     * @param reply_markup The new message reply markup; pass null if none
     * @param caption New message content caption; pass null to remove
     * caption; 0-getOption("message_caption_length_max") characters
     * @param show_caption_above_media Pass true to show the caption above
     * the media; otherwise, the caption will be shown below the media. May
     * be true only for animation, photo, and video messages
     */
    public async BusinessMessage edit_business_message_caption (
        string business_connection_id,
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup,
        FormattedText caption,
        bool show_caption_above_media
    ) throws TDLibError {
        try {

        var obj = new EditBusinessMessageCaption (
            business_connection_id,
            chat_id,
            message_id,
            reply_markup,
            caption,
            show_caption_above_media
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_business_message_caption.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BusinessMessage) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits the reply markup of a message sent on behalf of a business
     * account; for bots only
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which the message was sent
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message
     * @param reply_markup The new message reply markup; pass null if none
     */
    public async BusinessMessage edit_business_message_reply_markup (
        string business_connection_id,
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup
    ) throws TDLibError {
        try {

        var obj = new EditBusinessMessageReplyMarkup (
            business_connection_id,
            chat_id,
            message_id,
            reply_markup
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_business_message_reply_markup.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BusinessMessage) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Stops a poll sent on behalf of a business account; for bots only
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which the message with the poll was sent
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message containing the poll
     * @param reply_markup The new message reply markup; pass null if none
     */
    public async BusinessMessage stop_business_poll (
        string business_connection_id,
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup
    ) throws TDLibError {
        try {

        var obj = new StopBusinessPoll (
            business_connection_id,
            chat_id,
            message_id,
            reply_markup
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (stop_business_poll.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BusinessMessage) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Pins or unpins a message sent on behalf of a business account; for
     * bots only
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which the message was sent
     * @param chat_id The chat the message belongs to
     * @param message_id Identifier of the message
     * @param is_pinned Pass true to pin the message, pass false to unpin it
     */
    public async Ok set_business_message_is_pinned (
        string business_connection_id,
        int64 chat_id,
        int64 message_id,
        bool is_pinned
    ) throws TDLibError {
        try {

        var obj = new SetBusinessMessageIsPinned (
            business_connection_id,
            chat_id,
            message_id,
            is_pinned
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_business_message_is_pinned.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks validness of a name for a quick reply shortcut. Can be called
     * synchronously
     * @param name The name of the shortcut; 1-32 characters
     */
    public Ok check_quick_reply_shortcut_name_sync (
        string name
    ) throws TDLibError {
        try {

        var obj = new CheckQuickReplyShortcutName (
            name
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks validness of a name for a quick reply shortcut. Can be called
     * synchronously
     * @param name The name of the shortcut; 1-32 characters
     */
    public async Ok check_quick_reply_shortcut_name (
        string name
    ) throws TDLibError {
        try {

        var obj = new CheckQuickReplyShortcutName (
            name
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_quick_reply_shortcut_name.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Loads quick reply shortcuts created by the current user. The loaded
     * data will be sent through updateQuickReplyShortcut and
     * updateQuickReplyShortcuts
     */
    public async Ok load_quick_reply_shortcuts () throws TDLibError {
        try {

        var obj = new LoadQuickReplyShortcuts ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (load_quick_reply_shortcuts.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes name of a quick reply shortcut
     * @param shortcut_id Unique identifier of the quick reply shortcut
     * @param name New name for the shortcut. Use
     * {@link Client.check_quick_reply_shortcut_name} to check its validness
     */
    public async Ok set_quick_reply_shortcut_name (
        int32 shortcut_id,
        string name
    ) throws TDLibError {
        try {

        var obj = new SetQuickReplyShortcutName (
            shortcut_id,
            name
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_quick_reply_shortcut_name.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes a quick reply shortcut
     * @param shortcut_id Unique identifier of the quick reply shortcut
     */
    public async Ok delete_quick_reply_shortcut (
        int32 shortcut_id
    ) throws TDLibError {
        try {

        var obj = new DeleteQuickReplyShortcut (
            shortcut_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_quick_reply_shortcut.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the order of quick reply shortcuts
     * @param shortcut_ids The new order of quick reply shortcuts
     */
    public async Ok reorder_quick_reply_shortcuts (
        Gee.ArrayList<int32?> shortcut_ids
    ) throws TDLibError {
        try {

        var obj = new ReorderQuickReplyShortcuts (
            shortcut_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reorder_quick_reply_shortcuts.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Loads quick reply messages that can be sent by a given quick reply
     * shortcut. The loaded messages will be sent through
     * updateQuickReplyShortcutMessages
     * @param shortcut_id Unique identifier of the quick reply shortcut
     */
    public async Ok load_quick_reply_shortcut_messages (
        int32 shortcut_id
    ) throws TDLibError {
        try {

        var obj = new LoadQuickReplyShortcutMessages (
            shortcut_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (load_quick_reply_shortcut_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes specified quick reply messages
     * @param shortcut_id Unique identifier of the quick reply shortcut to
     * which the messages belong
     * @param message_ids Unique identifiers of the messages
     */
    public async Ok delete_quick_reply_shortcut_messages (
        int32 shortcut_id,
        Gee.ArrayList<int64?> message_ids
    ) throws TDLibError {
        try {

        var obj = new DeleteQuickReplyShortcutMessages (
            shortcut_id,
            message_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_quick_reply_shortcut_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a message to a quick reply shortcut. If shortcut doesn't exist
     * and there are less than getOption("quick_reply_shortcut_count_max")
     * shortcuts, then a new shortcut is created.
     * The shortcut must not contain more than
     * getOption("quick_reply_shortcut_message_count_max") messages after
     * adding the new message. Returns the added message
     * @param shortcut_name Name of the target shortcut
     * @param reply_to_message_id Identifier of a quick reply message in the
     * same shortcut to be replied; pass 0 if none
     * @param input_message_content The content of the message to be added;
     * inputMessagePoll, inputMessageForwarded and inputMessageLocation with
     * live_period aren't supported
     */
    public async QuickReplyMessage add_quick_reply_shortcut_message (
        string shortcut_name,
        int64 reply_to_message_id,
        InputMessageContent input_message_content
    ) throws TDLibError {
        try {

        var obj = new AddQuickReplyShortcutMessage (
            shortcut_name,
            reply_to_message_id,
            input_message_content
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_quick_reply_shortcut_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (QuickReplyMessage) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a message to a quick reply shortcut via inline bot. If shortcut
     * doesn't exist and there are less than
     * getOption("quick_reply_shortcut_count_max") shortcuts, then a new
     * shortcut is created.
     * The shortcut must not contain more than
     * getOption("quick_reply_shortcut_message_count_max") messages after
     * adding the new message. Returns the added message
     * @param shortcut_name Name of the target shortcut
     * @param reply_to_message_id Identifier of a quick reply message in the
     * same shortcut to be replied; pass 0 if none
     * @param query_id Identifier of the inline query
     * @param result_id Identifier of the inline query result
     * @param hide_via_bot Pass true to hide the bot, via which the message
     * is sent. Can be used only for bots
     * getOption("animation_search_bot_username"),
     * getOption("photo_search_bot_username"), and
     * getOption("venue_search_bot_username")
     */
    public async QuickReplyMessage add_quick_reply_shortcut_inline_query_result_message (
        string shortcut_name,
        int64 reply_to_message_id,
        int64 query_id,
        string result_id,
        bool hide_via_bot
    ) throws TDLibError {
        try {

        var obj = new AddQuickReplyShortcutInlineQueryResultMessage (
            shortcut_name,
            reply_to_message_id,
            query_id,
            result_id,
            hide_via_bot
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_quick_reply_shortcut_inline_query_result_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (QuickReplyMessage) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds 2-10 messages grouped together into an album to a quick reply
     * shortcut. Currently, only audio, document, photo and video messages
     * can be grouped into an album.
     * Documents and audio files can be only grouped in an album with
     * messages of the same type. Returns sent messages
     * @param shortcut_name Name of the target shortcut
     * @param reply_to_message_id Identifier of a quick reply message in the
     * same shortcut to be replied; pass 0 if none
     * @param input_message_contents Contents of messages to be sent. At most
     * 10 messages can be added to an album. All messages must have the same
     * value of show_caption_above_media
     */
    public async QuickReplyMessages add_quick_reply_shortcut_message_album (
        string shortcut_name,
        int64 reply_to_message_id,
        Gee.ArrayList<InputMessageContent?> input_message_contents
    ) throws TDLibError {
        try {

        var obj = new AddQuickReplyShortcutMessageAlbum (
            shortcut_name,
            reply_to_message_id,
            input_message_contents
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_quick_reply_shortcut_message_album.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (QuickReplyMessages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Readds quick reply messages which failed to add. Can be called only
     * for messages for which messageSendingStateFailed.can_retry is true and
     * after specified in messageSendingStateFailed.retry_after time passed.
     * If a message is readded, the corresponding failed to send message is
     * deleted. Returns the sent messages in the same order as the message
     * identifiers passed in message_ids. If a message can't be readded, null
     * will be returned instead of the message
     * @param shortcut_name Name of the target shortcut
     * @param message_ids Identifiers of the quick reply messages to readd.
     * Message identifiers must be in a strictly increasing order
     */
    public async QuickReplyMessages readd_quick_reply_shortcut_messages (
        string shortcut_name,
        Gee.ArrayList<int64?> message_ids
    ) throws TDLibError {
        try {

        var obj = new ReaddQuickReplyShortcutMessages (
            shortcut_name,
            message_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (readd_quick_reply_shortcut_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (QuickReplyMessages) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Asynchronously edits the text, media or caption of a quick reply
     * message. Use quickReplyMessage.can_be_edited to check whether a
     * message can be edited.
     * Media message can be edited only to a media message. The type of
     * message content in an album can't be changed with exception of
     * replacing a photo with a video or vice versa
     * @param shortcut_id Unique identifier of the quick reply shortcut with
     * the message
     * @param message_id Identifier of the message
     * @param input_message_content New content of the message. Must be one
     * of the following types: inputMessageText, inputMessageAnimation,
     * inputMessageAudio, inputMessageDocument, inputMessagePhoto or
     * inputMessageVideo
     */
    public async Ok edit_quick_reply_message (
        int32 shortcut_id,
        int64 message_id,
        InputMessageContent input_message_content
    ) throws TDLibError {
        try {

        var obj = new EditQuickReplyMessage (
            shortcut_id,
            message_id,
            input_message_content
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_quick_reply_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of custom emoji, which can be used as forum topic
     * icon by all users
     */
    public async Stickers get_forum_topic_default_icons () throws TDLibError {
        try {

        var obj = new GetForumTopicDefaultIcons ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_forum_topic_default_icons.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Stickers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Creates a topic in a forum supergroup chat; requires can_manage_topics
     * administrator or can_create_topics member right in the supergroup
     * @param chat_id Identifier of the chat
     * @param name Name of the topic; 1-128 characters
     * @param icon Icon of the topic. Icon color must be one of 0x6FB9F0,
     * 0xFFD67E, 0xCB86DB, 0x8EEE98, 0xFF93B2, or 0xFB6F5F. Telegram Premium
     * users can use any custom emoji as topic icon, other users can use only
     * a custom emoji returned by
     * {@link Client.get_forum_topic_default_icons}
     */
    public async ForumTopicInfo create_forum_topic (
        int64 chat_id,
        string name,
        ForumTopicIcon icon
    ) throws TDLibError {
        try {

        var obj = new CreateForumTopic (
            chat_id,
            name,
            icon
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_forum_topic.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ForumTopicInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits title and icon of a topic in a forum supergroup chat; requires
     * can_manage_topics right in the supergroup unless the user is creator
     * of the topic
     * @param chat_id Identifier of the chat
     * @param message_thread_id Message thread identifier of the forum topic
     * @param name New name of the topic; 0-128 characters. If empty, the
     * previous topic name is kept
     * @param edit_icon_custom_emoji Pass true to edit the icon of the topic.
     * Icon of the General topic can't be edited
     * @param icon_custom_emoji_id Identifier of the new custom emoji for
     * topic icon; pass 0 to remove the custom emoji. Ignored if
     * edit_icon_custom_emoji is false. Telegram Premium users can use any
     * custom emoji, other users can use only a custom emoji returned by
     * {@link Client.get_forum_topic_default_icons}
     */
    public async Ok edit_forum_topic (
        int64 chat_id,
        int64 message_thread_id,
        string name,
        bool edit_icon_custom_emoji,
        int64 icon_custom_emoji_id
    ) throws TDLibError {
        try {

        var obj = new EditForumTopic (
            chat_id,
            message_thread_id,
            name,
            edit_icon_custom_emoji,
            icon_custom_emoji_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_forum_topic.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a forum topic
     * @param chat_id Identifier of the chat
     * @param message_thread_id Message thread identifier of the forum topic
     */
    public async ForumTopic get_forum_topic (
        int64 chat_id,
        int64 message_thread_id
    ) throws TDLibError {
        try {

        var obj = new GetForumTopic (
            chat_id,
            message_thread_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_forum_topic.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ForumTopic) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an HTTPS link to a topic in a forum chat. This is an offline
     * request
     * @param chat_id Identifier of the chat
     * @param message_thread_id Message thread identifier of the forum topic
     */
    public async MessageLink get_forum_topic_link (
        int64 chat_id,
        int64 message_thread_id
    ) throws TDLibError {
        try {

        var obj = new GetForumTopicLink (
            chat_id,
            message_thread_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_forum_topic_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MessageLink) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns found forum topics in a forum chat. This is a temporary method
     * for getting information about topic list from the server
     * @param chat_id Identifier of the forum chat
     * @param query Query to search for in the forum topic's name
     * @param offset_date The date starting from which the results need to be
     * fetched. Use 0 or any date in the future to get results from the last
     * topic
     * @param offset_message_id The message identifier of the last message in
     * the last found topic, or 0 for the first request
     * @param offset_message_thread_id The message thread identifier of the
     * last found topic, or 0 for the first request
     * @param limit The maximum number of forum topics to be returned; up to
     * 100. For optimal performance, the number of returned forum topics is
     * chosen by TDLib and can be smaller than the specified limit
     */
    public async ForumTopics get_forum_topics (
        int64 chat_id,
        string query,
        int32 offset_date,
        int64 offset_message_id,
        int64 offset_message_thread_id,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetForumTopics (
            chat_id,
            query,
            offset_date,
            offset_message_id,
            offset_message_thread_id,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_forum_topics.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ForumTopics) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the notification settings of a forum topic
     * @param chat_id Chat identifier
     * @param message_thread_id Message thread identifier of the forum topic
     * @param notification_settings New notification settings for the forum
     * topic. If the topic is muted for more than 366 days, it is considered
     * to be muted forever
     */
    public async Ok set_forum_topic_notification_settings (
        int64 chat_id,
        int64 message_thread_id,
        ChatNotificationSettings notification_settings
    ) throws TDLibError {
        try {

        var obj = new SetForumTopicNotificationSettings (
            chat_id,
            message_thread_id,
            notification_settings
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_forum_topic_notification_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether a topic is closed in a forum supergroup chat; requires
     * can_manage_topics right in the supergroup unless the user is creator
     * of the topic
     * @param chat_id Identifier of the chat
     * @param message_thread_id Message thread identifier of the forum topic
     * @param is_closed Pass true to {@link Client.close} the topic; pass
     * false to reopen it
     */
    public async Ok toggle_forum_topic_is_closed (
        int64 chat_id,
        int64 message_thread_id,
        bool is_closed
    ) throws TDLibError {
        try {

        var obj = new ToggleForumTopicIsClosed (
            chat_id,
            message_thread_id,
            is_closed
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_forum_topic_is_closed.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether a General topic is hidden in a forum supergroup chat;
     * requires can_manage_topics right in the supergroup
     * @param chat_id Identifier of the chat
     * @param is_hidden Pass true to hide and {@link Client.close} the
     * General topic; pass false to unhide it
     */
    public async Ok toggle_general_forum_topic_is_hidden (
        int64 chat_id,
        bool is_hidden
    ) throws TDLibError {
        try {

        var obj = new ToggleGeneralForumTopicIsHidden (
            chat_id,
            is_hidden
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_general_forum_topic_is_hidden.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the pinned state of a forum topic; requires can_manage_topics
     * right in the supergroup. There can be up to
     * getOption("pinned_forum_topic_count_max") pinned forum topics
     * @param chat_id Chat identifier
     * @param message_thread_id Message thread identifier of the forum topic
     * @param is_pinned Pass true to pin the topic; pass false to unpin it
     */
    public async Ok toggle_forum_topic_is_pinned (
        int64 chat_id,
        int64 message_thread_id,
        bool is_pinned
    ) throws TDLibError {
        try {

        var obj = new ToggleForumTopicIsPinned (
            chat_id,
            message_thread_id,
            is_pinned
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_forum_topic_is_pinned.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the order of pinned forum topics; requires can_manage_topics
     * right in the supergroup
     * @param chat_id Chat identifier
     * @param message_thread_ids The new list of pinned forum topics
     */
    public async Ok set_pinned_forum_topics (
        int64 chat_id,
        Gee.ArrayList<int64?> message_thread_ids
    ) throws TDLibError {
        try {

        var obj = new SetPinnedForumTopics (
            chat_id,
            message_thread_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_pinned_forum_topics.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes all messages in a forum topic; requires can_delete_messages
     * administrator right in the supergroup unless the user is creator of
     * the topic, the topic has no messages from other users and has at most
     * 11 messages
     * @param chat_id Identifier of the chat
     * @param message_thread_id Message thread identifier of the forum topic
     */
    public async Ok delete_forum_topic (
        int64 chat_id,
        int64 message_thread_id
    ) throws TDLibError {
        try {

        var obj = new DeleteForumTopic (
            chat_id,
            message_thread_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_forum_topic.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about an emoji reaction. Returns a 404 error if
     * the reaction is not found
     * @param emoji Text representation of the reaction
     */
    public async EmojiReaction get_emoji_reaction (
        string emoji
    ) throws TDLibError {
        try {

        var obj = new GetEmojiReaction (
            emoji
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_emoji_reaction.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (EmojiReaction) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns TGS stickers with generic animations for custom emoji
     * reactions
     */
    public async Stickers get_custom_emoji_reaction_animations () throws TDLibError {
        try {

        var obj = new GetCustomEmojiReactionAnimations ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_custom_emoji_reaction_animations.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Stickers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns reactions, which can be added to a message. The list can
     * change after updateActiveEmojiReactions, updateChatAvailableReactions
     * for the chat, or updateMessageInteractionInfo for the message
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param row_size Number of reaction per row, 5-25
     */
    public async AvailableReactions get_message_available_reactions (
        int64 chat_id,
        int64 message_id,
        int32 row_size
    ) throws TDLibError {
        try {

        var obj = new GetMessageAvailableReactions (
            chat_id,
            message_id,
            row_size
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_available_reactions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (AvailableReactions) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Clears the list of recently used reactions
     */
    public async Ok clear_recent_reactions () throws TDLibError {
        try {

        var obj = new ClearRecentReactions ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clear_recent_reactions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a reaction or a tag to a message. Use
     * {@link Client.get_message_available_reactions} to receive the list of
     * available reactions for the message
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param reaction_type Type of the reaction to add. Use
     * {@link Client.add_pending_paid_message_reaction} instead to add the
     * paid reaction
     * @param is_big Pass true if the reaction is added with a big animation
     * @param update_recent_reactions Pass true if the reaction needs to be
     * added to recent reactions; tags are never added to the list of recent
     * reactions
     */
    public async Ok add_message_reaction (
        int64 chat_id,
        int64 message_id,
        ReactionType reaction_type,
        bool is_big,
        bool update_recent_reactions
    ) throws TDLibError {
        try {

        var obj = new AddMessageReaction (
            chat_id,
            message_id,
            reaction_type,
            is_big,
            update_recent_reactions
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_message_reaction.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes a reaction from a message. A chosen reaction can always be
     * removed
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param reaction_type Type of the reaction to remove. The paid reaction
     * can't be removed
     */
    public async Ok remove_message_reaction (
        int64 chat_id,
        int64 message_id,
        ReactionType reaction_type
    ) throws TDLibError {
        try {

        var obj = new RemoveMessageReaction (
            chat_id,
            message_id,
            reaction_type
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_message_reaction.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of message sender identifiers, which can be used to
     * send a paid reaction in a chat
     * @param chat_id Chat identifier
     */
    public async MessageSenders get_chat_available_paid_message_reaction_senders (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetChatAvailablePaidMessageReactionSenders (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_available_paid_message_reaction_senders.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MessageSenders) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds the paid message reaction to a message. Use
     * {@link Client.get_message_available_reactions} to check whether the
     * reaction is available for the message
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param star_count Number of Telegram Stars to be used for the
     * reaction. The total number of pending paid reactions must not exceed
     * getOption("paid_reaction_star_count_max")
     * @param type_ Type of the paid reaction; pass null if the user didn't
     * choose reaction type explicitly, for example, the reaction is set from
     * the message bubble
     */
    public async Ok add_pending_paid_message_reaction (
        int64 chat_id,
        int64 message_id,
        int64 star_count,
        PaidReactionType type_
    ) throws TDLibError {
        try {

        var obj = new AddPendingPaidMessageReaction (
            chat_id,
            message_id,
            star_count,
            type_
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_pending_paid_message_reaction.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Applies all pending paid reactions on a message
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     */
    public async Ok commit_pending_paid_message_reactions (
        int64 chat_id,
        int64 message_id
    ) throws TDLibError {
        try {

        var obj = new CommitPendingPaidMessageReactions (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (commit_pending_paid_message_reactions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes all pending paid reactions on a message
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     */
    public async Ok remove_pending_paid_message_reactions (
        int64 chat_id,
        int64 message_id
    ) throws TDLibError {
        try {

        var obj = new RemovePendingPaidMessageReactions (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_pending_paid_message_reactions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes type of paid message reaction of the current user on a
     * message. The message must have paid reaction added by the current user
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param type_ New type of the paid reaction
     */
    public async Ok set_paid_message_reaction_type (
        int64 chat_id,
        int64 message_id,
        PaidReactionType type_
    ) throws TDLibError {
        try {

        var obj = new SetPaidMessageReactionType (
            chat_id,
            message_id,
            type_
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_paid_message_reaction_type.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets reactions on a message; for bots only
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message
     * @param reaction_types Types of the reaction to set; pass an empty list
     * to remove the reactions
     * @param is_big Pass true if the reactions are added with a big
     * animation
     */
    public async Ok set_message_reactions (
        int64 chat_id,
        int64 message_id,
        Gee.ArrayList<ReactionType?> reaction_types,
        bool is_big
    ) throws TDLibError {
        try {

        var obj = new SetMessageReactions (
            chat_id,
            message_id,
            reaction_types,
            is_big
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_message_reactions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns reactions added for a message, along with their sender
     * @param chat_id Identifier of the chat to which the message belongs
     * @param message_id Identifier of the message. Use
     * message.interaction_info.reactions.can_get_added_reactions to check
     * whether added reactions can be received for the message
     * @param reaction_type Type of the reactions to return; pass null to
     * return all added reactions; reactionTypePaid isn't supported
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of reactions to be returned; must be
     * positive and can't be greater than 100
     */
    public async AddedReactions get_message_added_reactions (
        int64 chat_id,
        int64 message_id,
        ReactionType reaction_type,
        string offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetMessageAddedReactions (
            chat_id,
            message_id,
            reaction_type,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_added_reactions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (AddedReactions) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes type of default reaction for the current user
     * @param reaction_type New type of the default reaction. The paid
     * reaction can't be set as default
     */
    public async Ok set_default_reaction_type (
        ReactionType reaction_type
    ) throws TDLibError {
        try {

        var obj = new SetDefaultReactionType (
            reaction_type
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_default_reaction_type.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns tags used in Saved Messages or a Saved Messages topic
     * @param saved_messages_topic_id Identifier of Saved Messages topic
     * which tags will be returned; pass 0 to get all Saved Messages tags
     */
    public async SavedMessagesTags get_saved_messages_tags (
        int64 saved_messages_topic_id
    ) throws TDLibError {
        try {

        var obj = new GetSavedMessagesTags (
            saved_messages_topic_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_saved_messages_tags.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (SavedMessagesTags) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes label of a Saved Messages tag; for Telegram Premium users only
     * @param tag The tag which label will be changed
     * @param label New label for the tag; 0-12 characters
     */
    public async Ok set_saved_messages_tag_label (
        ReactionType tag,
        string label
    ) throws TDLibError {
        try {

        var obj = new SetSavedMessagesTagLabel (
            tag,
            label
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_saved_messages_tag_label.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a message effect. Returns a 404 error if the
     * effect is not found
     * @param effect_id Unique identifier of the effect
     */
    public async MessageEffect get_message_effect (
        int64 effect_id
    ) throws TDLibError {
        try {

        var obj = new GetMessageEffect (
            effect_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_effect.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MessageEffect) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for a given quote in a text. Returns found quote start
     * position in UTF-16 code units. Returns a 404 error if the quote is not
     * found. Can be called synchronously
     * @param text Text in which to search for the quote
     * @param quote Quote to search for
     * @param quote_position Approximate quote position in UTF-16 code units
     */
    public FoundPosition search_quote_sync (
        FormattedText text,
        FormattedText quote,
        int32 quote_position
    ) throws TDLibError {
        try {

        var obj = new SearchQuote (
            text,
            quote,
            quote_position
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundPosition) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for a given quote in a text. Returns found quote start
     * position in UTF-16 code units. Returns a 404 error if the quote is not
     * found. Can be called synchronously
     * @param text Text in which to search for the quote
     * @param quote Quote to search for
     * @param quote_position Approximate quote position in UTF-16 code units
     */
    public async FoundPosition search_quote (
        FormattedText text,
        FormattedText quote,
        int32 quote_position
    ) throws TDLibError {
        try {

        var obj = new SearchQuote (
            text,
            quote,
            quote_position
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_quote.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundPosition) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns all entities (mentions, hashtags, cashtags, bot commands, bank
     * card numbers, URLs, and email addresses) found in the text. Can be
     * called synchronously
     * @param text The text in which to look for entities
     */
    public TextEntities get_text_entities_sync (
        string text
    ) throws TDLibError {
        try {

        var obj = new GetTextEntities (
            text
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (TextEntities) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns all entities (mentions, hashtags, cashtags, bot commands, bank
     * card numbers, URLs, and email addresses) found in the text. Can be
     * called synchronously
     * @param text The text in which to look for entities
     */
    public async TextEntities get_text_entities (
        string text
    ) throws TDLibError {
        try {

        var obj = new GetTextEntities (
            text
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_text_entities.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (TextEntities) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Parses Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji,
     * BlockQuote, ExpandableBlockQuote, Code, Pre, PreCode, TextUrl
     * and MentionName entities from a marked-up text. Can be called
     * synchronously
     * @param text The text to parse
     * @param parse_mode Text parse mode
     */
    public FormattedText parse_text_entities_sync (
        string text,
        TextParseMode parse_mode
    ) throws TDLibError {
        try {

        var obj = new ParseTextEntities (
            text,
            parse_mode
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FormattedText) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Parses Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji,
     * BlockQuote, ExpandableBlockQuote, Code, Pre, PreCode, TextUrl
     * and MentionName entities from a marked-up text. Can be called
     * synchronously
     * @param text The text to parse
     * @param parse_mode Text parse mode
     */
    public async FormattedText parse_text_entities (
        string text,
        TextParseMode parse_mode
    ) throws TDLibError {
        try {

        var obj = new ParseTextEntities (
            text,
            parse_mode
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (parse_text_entities.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FormattedText) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Parses Markdown entities in a human-friendly format, ignoring markup
     * errors. Can be called synchronously
     * @param text The text to parse. For example, "__italic__
     * ~~strikethrough~~ ||spoiler|| **bold** `code` ```pre``` __[italic__
     * text_url](telegram.org) __italic**bold italic__bold**"
     */
    public FormattedText parse_markdown_sync (
        FormattedText text
    ) throws TDLibError {
        try {

        var obj = new ParseMarkdown (
            text
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FormattedText) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Parses Markdown entities in a human-friendly format, ignoring markup
     * errors. Can be called synchronously
     * @param text The text to parse. For example, "__italic__
     * ~~strikethrough~~ ||spoiler|| **bold** `code` ```pre``` __[italic__
     * text_url](telegram.org) __italic**bold italic__bold**"
     */
    public async FormattedText parse_markdown (
        FormattedText text
    ) throws TDLibError {
        try {

        var obj = new ParseMarkdown (
            text
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (parse_markdown.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FormattedText) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Replaces text entities with Markdown formatting in a human-friendly
     * format. Entities that can't be represented in Markdown unambiguously
     * are kept as is. Can be called synchronously
     * @param text The text
     */
    public FormattedText get_markdown_text_sync (
        FormattedText text
    ) throws TDLibError {
        try {

        var obj = new GetMarkdownText (
            text
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FormattedText) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Replaces text entities with Markdown formatting in a human-friendly
     * format. Entities that can't be represented in Markdown unambiguously
     * are kept as is. Can be called synchronously
     * @param text The text
     */
    public async FormattedText get_markdown_text (
        FormattedText text
    ) throws TDLibError {
        try {

        var obj = new GetMarkdownText (
            text
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_markdown_text.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FormattedText) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an emoji for the given country. Returns an empty string on
     * failure. Can be called synchronously
     * @param country_code A two-letter ISO 3166-1 alpha-2 country code as
     * received from {@link Client.get_countries}
     */
    public Text get_country_flag_emoji_sync (
        string country_code
    ) throws TDLibError {
        try {

        var obj = new GetCountryFlagEmoji (
            country_code
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an emoji for the given country. Returns an empty string on
     * failure. Can be called synchronously
     * @param country_code A two-letter ISO 3166-1 alpha-2 country code as
     * received from {@link Client.get_countries}
     */
    public async Text get_country_flag_emoji (
        string country_code
    ) throws TDLibError {
        try {

        var obj = new GetCountryFlagEmoji (
            country_code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_country_flag_emoji.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the MIME type of a file, guessed by its extension. Returns an
     * empty string on failure. Can be called synchronously
     * @param file_name The name of the file or path to the file
     */
    public Text get_file_mime_type_sync (
        string file_name
    ) throws TDLibError {
        try {

        var obj = new GetFileMimeType (
            file_name
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the MIME type of a file, guessed by its extension. Returns an
     * empty string on failure. Can be called synchronously
     * @param file_name The name of the file or path to the file
     */
    public async Text get_file_mime_type (
        string file_name
    ) throws TDLibError {
        try {

        var obj = new GetFileMimeType (
            file_name
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_file_mime_type.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the extension of a file, guessed by its MIME type. Returns an
     * empty string on failure. Can be called synchronously
     * @param mime_type The MIME type of the file
     */
    public Text get_file_extension_sync (
        string mime_type
    ) throws TDLibError {
        try {

        var obj = new GetFileExtension (
            mime_type
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the extension of a file, guessed by its MIME type. Returns an
     * empty string on failure. Can be called synchronously
     * @param mime_type The MIME type of the file
     */
    public async Text get_file_extension (
        string mime_type
    ) throws TDLibError {
        try {

        var obj = new GetFileExtension (
            mime_type
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_file_extension.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes potentially dangerous characters from the name of a file.
     * Returns an empty string on failure. Can be called synchronously
     * @param file_name File name or path to the file
     */
    public Text clean_file_name_sync (
        string file_name
    ) throws TDLibError {
        try {

        var obj = new CleanFileName (
            file_name
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes potentially dangerous characters from the name of a file.
     * Returns an empty string on failure. Can be called synchronously
     * @param file_name File name or path to the file
     */
    public async Text clean_file_name (
        string file_name
    ) throws TDLibError {
        try {

        var obj = new CleanFileName (
            file_name
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clean_file_name.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a string stored in the local database from the specified
     * localization target and language pack by its key. Returns a 404 error
     * if the string is not found. Can be called synchronously
     * @param language_pack_database_path Path to the language pack database
     * in which strings are stored
     * @param localization_target Localization target to which the language
     * pack belongs
     * @param language_pack_id Language pack identifier
     * @param key Language pack key of the string to be returned
     */
    public LanguagePackStringValue get_language_pack_string_sync (
        string language_pack_database_path,
        string localization_target,
        string language_pack_id,
        string key
    ) throws TDLibError {
        try {

        var obj = new GetLanguagePackString (
            language_pack_database_path,
            localization_target,
            language_pack_id,
            key
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (LanguagePackStringValue) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a string stored in the local database from the specified
     * localization target and language pack by its key. Returns a 404 error
     * if the string is not found. Can be called synchronously
     * @param language_pack_database_path Path to the language pack database
     * in which strings are stored
     * @param localization_target Localization target to which the language
     * pack belongs
     * @param language_pack_id Language pack identifier
     * @param key Language pack key of the string to be returned
     */
    public async LanguagePackStringValue get_language_pack_string (
        string language_pack_database_path,
        string localization_target,
        string language_pack_id,
        string key
    ) throws TDLibError {
        try {

        var obj = new GetLanguagePackString (
            language_pack_database_path,
            localization_target,
            language_pack_id,
            key
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_language_pack_string.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (LanguagePackStringValue) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Converts a JSON-serialized string to corresponding JsonValue object.
     * Can be called synchronously
     * @param json The JSON-serialized string
     */
    public JsonValue get_json_value_sync (
        string json
    ) throws TDLibError {
        try {

        var obj = new GetJsonValue (
            json
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (JsonValue) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Converts a JSON-serialized string to corresponding JsonValue object.
     * Can be called synchronously
     * @param json The JSON-serialized string
     */
    public async JsonValue get_json_value (
        string json
    ) throws TDLibError {
        try {

        var obj = new GetJsonValue (
            json
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_json_value.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (JsonValue) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Converts a JsonValue object to corresponding JSON-serialized string.
     * Can be called synchronously
     * @param json_value The JsonValue object
     */
    public Text get_json_string_sync (
        JsonValue json_value
    ) throws TDLibError {
        try {

        var obj = new GetJsonString (
            json_value
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Converts a JsonValue object to corresponding JSON-serialized string.
     * Can be called synchronously
     * @param json_value The JsonValue object
     */
    public async Text get_json_string (
        JsonValue json_value
    ) throws TDLibError {
        try {

        var obj = new GetJsonString (
            json_value
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_json_string.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Converts a themeParameters object to corresponding JSON-serialized
     * string. Can be called synchronously
     * @param theme Theme parameters to convert to JSON
     */
    public Text get_theme_parameters_json_string_sync (
        ThemeParameters theme
    ) throws TDLibError {
        try {

        var obj = new GetThemeParametersJsonString (
            theme
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Converts a themeParameters object to corresponding JSON-serialized
     * string. Can be called synchronously
     * @param theme Theme parameters to convert to JSON
     */
    public async Text get_theme_parameters_json_string (
        ThemeParameters theme
    ) throws TDLibError {
        try {

        var obj = new GetThemeParametersJsonString (
            theme
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_theme_parameters_json_string.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the user answer to a poll. A poll in quiz mode can be answered
     * only once
     * @param chat_id Identifier of the chat to which the poll belongs
     * @param message_id Identifier of the message containing the poll
     * @param option_ids 0-based identifiers of answer options, chosen by the
     * user. User can choose more than 1 answer option only is the poll
     * allows multiple answers
     */
    public async Ok set_poll_answer (
        int64 chat_id,
        int64 message_id,
        Gee.ArrayList<int32?> option_ids
    ) throws TDLibError {
        try {

        var obj = new SetPollAnswer (
            chat_id,
            message_id,
            option_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_poll_answer.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns message senders voted for the specified option in a
     * non-anonymous polls. For optimal performance, the number of returned
     * users is chosen by TDLib
     * @param chat_id Identifier of the chat to which the poll belongs
     * @param message_id Identifier of the message containing the poll
     * @param option_id 0-based identifier of the answer option
     * @param offset Number of voters to skip in the result; must be
     * non-negative
     * @param limit The maximum number of voters to be returned; must be
     * positive and can't be greater than 50. For optimal performance, the
     * number of returned voters is chosen by TDLib and can be smaller than
     * the specified limit, even if the end of the voter list has not been
     * reached
     */
    public async MessageSenders get_poll_voters (
        int64 chat_id,
        int64 message_id,
        int32 option_id,
        int32 offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetPollVoters (
            chat_id,
            message_id,
            option_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_poll_voters.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MessageSenders) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Stops a poll
     * @param chat_id Identifier of the chat to which the poll belongs
     * @param message_id Identifier of the message containing the poll. Use
     * messageProperties.can_be_edited to check whether the poll can be
     * stopped
     * @param reply_markup The new message reply markup; pass null if none;
     * for bots only
     */
    public async Ok stop_poll (
        int64 chat_id,
        int64 message_id,
        ReplyMarkup reply_markup
    ) throws TDLibError {
        try {

        var obj = new StopPoll (
            chat_id,
            message_id,
            reply_markup
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (stop_poll.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Hides a suggested action
     * @param action Suggested action to hide
     */
    public async Ok hide_suggested_action (
        SuggestedAction action
    ) throws TDLibError {
        try {

        var obj = new HideSuggestedAction (
            action
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (hide_suggested_action.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Hides the list of contacts that have {@link Client.close} birthdays
     * for 24 hours
     */
    public async Ok hide_contact_close_birthdays () throws TDLibError {
        try {

        var obj = new HideContactCloseBirthdays ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (hide_contact_close_birthdays.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a business connection by its identifier; for
     * bots only
     * @param connection_id Identifier of the business connection to return
     */
    public async BusinessConnection get_business_connection (
        string connection_id
    ) throws TDLibError {
        try {

        var obj = new GetBusinessConnection (
            connection_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_business_connection.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BusinessConnection) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a button of type
     * inlineKeyboardButtonTypeLoginUrl. The method needs to be called when
     * the user presses the button
     * @param chat_id Chat identifier of the message with the button
     * @param message_id Message identifier of the message with the button.
     * The message must not be scheduled
     * @param button_id Button identifier
     */
    public async LoginUrlInfo get_login_url_info (
        int64 chat_id,
        int64 message_id,
        int64 button_id
    ) throws TDLibError {
        try {

        var obj = new GetLoginUrlInfo (
            chat_id,
            message_id,
            button_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_login_url_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (LoginUrlInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an HTTP URL which can be used to automatically authorize the
     * user on a website after clicking an inline button of type
     * inlineKeyboardButtonTypeLoginUrl.
     * Use the method {@link Client.get_login_url_info} to find whether a
     * prior user confirmation is needed. If an error is returned, then the
     * button must be handled as an ordinary URL button
     * @param chat_id Chat identifier of the message with the button
     * @param message_id Message identifier of the message with the button
     * @param button_id Button identifier
     * @param allow_write_access Pass true to allow the bot to send messages
     * to the current user
     */
    public async HttpUrl get_login_url (
        int64 chat_id,
        int64 message_id,
        int64 button_id,
        bool allow_write_access
    ) throws TDLibError {
        try {

        var obj = new GetLoginUrl (
            chat_id,
            message_id,
            button_id,
            allow_write_access
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_login_url.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (HttpUrl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Shares users after pressing a keyboardButtonTypeRequestUsers button
     * with the bot
     * @param chat_id Identifier of the chat with the bot
     * @param message_id Identifier of the message with the button
     * @param button_id Identifier of the button
     * @param shared_user_ids Identifiers of the shared users
     * @param only_check Pass true to check that the users can be shared by
     * the button instead of actually sharing them
     */
    public async Ok share_users_with_bot (
        int64 chat_id,
        int64 message_id,
        int32 button_id,
        Gee.ArrayList<int64?> shared_user_ids,
        bool only_check
    ) throws TDLibError {
        try {

        var obj = new ShareUsersWithBot (
            chat_id,
            message_id,
            button_id,
            shared_user_ids,
            only_check
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (share_users_with_bot.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Shares a chat after pressing a keyboardButtonTypeRequestChat button
     * with the bot
     * @param chat_id Identifier of the chat with the bot
     * @param message_id Identifier of the message with the button
     * @param button_id Identifier of the button
     * @param shared_chat_id Identifier of the shared chat
     * @param only_check Pass true to check that the chat can be shared by
     * the button instead of actually sharing it. Doesn't check bot_is_member
     * and bot_administrator_rights restrictions. If the bot must be a
     * member, then all chats from {@link Client.get_groups_in_common} and
     * all chats, where the user can add the bot, are suitable. In the latter
     * case the bot will be automatically added to the chat. If the bot must
     * be an administrator, then all chats, where the bot already has
     * requested rights or can be added to administrators by the user, are
     * suitable. In the latter case the bot will be automatically granted
     * requested rights
     */
    public async Ok share_chat_with_bot (
        int64 chat_id,
        int64 message_id,
        int32 button_id,
        int64 shared_chat_id,
        bool only_check
    ) throws TDLibError {
        try {

        var obj = new ShareChatWithBot (
            chat_id,
            message_id,
            button_id,
            shared_chat_id,
            only_check
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (share_chat_with_bot.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends an inline query to a bot and returns its results. Returns an
     * error with code 502 if the bot fails to answer the query before the
     * query timeout expires
     * @param bot_user_id Identifier of the target bot
     * @param chat_id Identifier of the chat where the query was sent
     * @param user_location Location of the user; pass null if unknown or the
     * bot doesn't need user's location
     * @param query Text of the query
     * @param offset Offset of the first entry to return; use empty string to
     * get the first chunk of results
     */
    public async InlineQueryResults get_inline_query_results (
        int64 bot_user_id,
        int64 chat_id,
        Location user_location,
        string query,
        string offset
    ) throws TDLibError {
        try {

        var obj = new GetInlineQueryResults (
            bot_user_id,
            chat_id,
            user_location,
            query,
            offset
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_inline_query_results.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (InlineQueryResults) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the result of an inline query; for bots only
     * @param inline_query_id Identifier of the inline query
     * @param is_personal Pass true if results may be cached and returned
     * only for the user that sent the query. By default, results may be
     * returned to any user who sends the same query
     * @param button Button to be shown above inline query results; pass null
     * if none
     * @param results The results of the query
     * @param cache_time Allowed time to cache the results of the query, in
     * seconds
     * @param next_offset Offset for the next inline query; pass an empty
     * string if there are no more results
     */
    public async Ok answer_inline_query (
        int64 inline_query_id,
        bool is_personal,
        InlineQueryResultsButton button,
        Gee.ArrayList<InputInlineQueryResult?> results,
        int32 cache_time,
        string next_offset
    ) throws TDLibError {
        try {

        var obj = new AnswerInlineQuery (
            inline_query_id,
            is_personal,
            button,
            results,
            cache_time,
            next_offset
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (answer_inline_query.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Saves an inline message to be sent by the given user; for bots only
     * @param user_id Identifier of the user
     * @param result The description of the message
     * @param chat_types Types of the chats to which the message can be sent
     */
    public async PreparedInlineMessageId save_prepared_inline_message (
        int64 user_id,
        InputInlineQueryResult result,
        TargetChatTypes chat_types
    ) throws TDLibError {
        try {

        var obj = new SavePreparedInlineMessage (
            user_id,
            result,
            chat_types
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (save_prepared_inline_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PreparedInlineMessageId) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Saves an inline message to be sent by the given user
     * @param bot_user_id Identifier of the bot that created the message
     * @param prepared_message_id Identifier of the prepared message
     */
    public async PreparedInlineMessage get_prepared_inline_message (
        int64 bot_user_id,
        string prepared_message_id
    ) throws TDLibError {
        try {

        var obj = new GetPreparedInlineMessage (
            bot_user_id,
            prepared_message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_prepared_inline_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PreparedInlineMessage) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the most grossing Web App bots
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of bots to be returned; up to 100
     */
    public async FoundUsers get_grossing_web_app_bots (
        string offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetGrossingWebAppBots (
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_grossing_web_app_bots.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundUsers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a Web App by its short name. Returns a 404
     * error if the Web App is not found
     * @param bot_user_id Identifier of the target bot
     * @param web_app_short_name Short name of the Web App
     */
    public async FoundWebApp search_web_app (
        int64 bot_user_id,
        string web_app_short_name
    ) throws TDLibError {
        try {

        var obj = new SearchWebApp (
            bot_user_id,
            web_app_short_name
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_web_app.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundWebApp) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a default placeholder for Web Apps of a bot; this is an
     * offline request. Returns a 404 error if the placeholder isn't known
     * @param bot_user_id Identifier of the target bot
     */
    public async Outline get_web_app_placeholder (
        int64 bot_user_id
    ) throws TDLibError {
        try {

        var obj = new GetWebAppPlaceholder (
            bot_user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_web_app_placeholder.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Outline) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an HTTPS URL of a Web App to open after a link of the type
     * internalLinkTypeWebApp is clicked
     * @param chat_id Identifier of the chat in which the link was clicked;
     * pass 0 if none
     * @param bot_user_id Identifier of the target bot
     * @param web_app_short_name Short name of the Web App
     * @param start_parameter Start parameter from internalLinkTypeWebApp
     * @param allow_write_access Pass true if the current user allowed the
     * bot to send them messages
     * @param parameters Parameters to use to open the Web App
     */
    public async HttpUrl get_web_app_link_url (
        int64 chat_id,
        int64 bot_user_id,
        string web_app_short_name,
        string start_parameter,
        bool allow_write_access,
        WebAppOpenParameters parameters
    ) throws TDLibError {
        try {

        var obj = new GetWebAppLinkUrl (
            chat_id,
            bot_user_id,
            web_app_short_name,
            start_parameter,
            allow_write_access,
            parameters
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_web_app_link_url.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (HttpUrl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information needed to open the main Web App of a bot
     * @param chat_id Identifier of the chat in which the Web App is opened;
     * pass 0 if none
     * @param bot_user_id Identifier of the target bot. If the bot is
     * restricted for the current user, then show an error instead of calling
     * the method
     * @param start_parameter Start parameter from internalLinkTypeMainWebApp
     * @param parameters Parameters to use to open the Web App
     */
    public async MainWebApp get_main_web_app (
        int64 chat_id,
        int64 bot_user_id,
        string start_parameter,
        WebAppOpenParameters parameters
    ) throws TDLibError {
        try {

        var obj = new GetMainWebApp (
            chat_id,
            bot_user_id,
            start_parameter,
            parameters
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_main_web_app.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MainWebApp) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an HTTPS URL of a Web App to open from the side menu, a
     * keyboardButtonTypeWebApp button, or an
     * inlineQueryResultsButtonTypeWebApp button
     * @param bot_user_id Identifier of the target bot. If the bot is
     * restricted for the current user, then show an error instead of calling
     * the method
     * @param url The URL from a keyboardButtonTypeWebApp button,
     * inlineQueryResultsButtonTypeWebApp button, or an empty string when the
     * bot is opened from the side menu
     * @param parameters Parameters to use to open the Web App
     */
    public async HttpUrl get_web_app_url (
        int64 bot_user_id,
        string url,
        WebAppOpenParameters parameters
    ) throws TDLibError {
        try {

        var obj = new GetWebAppUrl (
            bot_user_id,
            url,
            parameters
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_web_app_url.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (HttpUrl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends data received from a keyboardButtonTypeWebApp Web App to a bot
     * @param bot_user_id Identifier of the target bot
     * @param button_text Text of the keyboardButtonTypeWebApp button, which
     * opened the Web App
     * @param data The data
     */
    public async Ok send_web_app_data (
        int64 bot_user_id,
        string button_text,
        string data
    ) throws TDLibError {
        try {

        var obj = new SendWebAppData (
            bot_user_id,
            button_text,
            data
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_web_app_data.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs TDLib that a Web App is being opened from the attachment menu,
     * a botMenuButton button, an internalLinkTypeAttachmentMenuBot link, or
     * an inlineKeyboardButtonTypeWebApp button.
     * For each bot, a confirmation alert about data sent to the bot must be
     * shown once
     * @param chat_id Identifier of the chat in which the Web App is opened.
     * The Web App can't be opened in secret chats
     * @param bot_user_id Identifier of the bot, providing the Web App. If
     * the bot is restricted for the current user, then show an error instead
     * of calling the method
     * @param url The URL from an inlineKeyboardButtonTypeWebApp button, a
     * botMenuButton button, an internalLinkTypeAttachmentMenuBot link, or an
     * empty string otherwise
     * @param message_thread_id If not 0, the message thread identifier in
     * which the message will be sent
     * @param reply_to Information about the message or story to be replied
     * in the message sent by the Web App; pass null if none
     * @param parameters Parameters to use to open the Web App
     */
    public async WebAppInfo open_web_app (
        int64 chat_id,
        int64 bot_user_id,
        string url,
        int64 message_thread_id,
        InputMessageReplyTo reply_to,
        WebAppOpenParameters parameters
    ) throws TDLibError {
        try {

        var obj = new OpenWebApp (
            chat_id,
            bot_user_id,
            url,
            message_thread_id,
            reply_to,
            parameters
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (open_web_app.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (WebAppInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs TDLib that a previously opened Web App was closed
     * @param web_app_launch_id Identifier of Web App launch, received from
     * {@link Client.open_web_app}
     */
    public async Ok close_web_app (
        int64 web_app_launch_id
    ) throws TDLibError {
        try {

        var obj = new CloseWebApp (
            web_app_launch_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (close_web_app.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the result of interaction with a Web App and sends corresponding
     * message on behalf of the user to the chat from which the query
     * originated; for bots only
     * @param web_app_query_id Identifier of the Web App query
     * @param result The result of the query
     */
    public async SentWebAppMessage answer_web_app_query (
        string web_app_query_id,
        InputInlineQueryResult result
    ) throws TDLibError {
        try {

        var obj = new AnswerWebAppQuery (
            web_app_query_id,
            result
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (answer_web_app_query.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (SentWebAppMessage) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks whether a file can be downloaded and saved locally by Web App
     * request
     * @param bot_user_id Identifier of the bot, providing the Web App
     * @param file_name Name of the file
     * @param url URL of the file
     */
    public async Ok check_web_app_file_download (
        int64 bot_user_id,
        string file_name,
        string url
    ) throws TDLibError {
        try {

        var obj = new CheckWebAppFileDownload (
            bot_user_id,
            file_name,
            url
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_web_app_file_download.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends a callback query to a bot and returns an answer. Returns an
     * error with code 502 if the bot fails to answer the query before the
     * query timeout expires
     * @param chat_id Identifier of the chat with the message
     * @param message_id Identifier of the message from which the query
     * originated. The message must not be scheduled
     * @param payload Query payload
     */
    public async CallbackQueryAnswer get_callback_query_answer (
        int64 chat_id,
        int64 message_id,
        CallbackQueryPayload payload
    ) throws TDLibError {
        try {

        var obj = new GetCallbackQueryAnswer (
            chat_id,
            message_id,
            payload
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_callback_query_answer.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (CallbackQueryAnswer) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the result of a callback query; for bots only
     * @param callback_query_id Identifier of the callback query
     * @param text Text of the answer
     * @param show_alert Pass true to show an alert to the user instead of a
     * toast notification
     * @param url URL to be opened
     * @param cache_time Time during which the result of the query can be
     * cached, in seconds
     */
    public async Ok answer_callback_query (
        int64 callback_query_id,
        string text,
        bool show_alert,
        string url,
        int32 cache_time
    ) throws TDLibError {
        try {

        var obj = new AnswerCallbackQuery (
            callback_query_id,
            text,
            show_alert,
            url,
            cache_time
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (answer_callback_query.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the result of a shipping query; for bots only
     * @param shipping_query_id Identifier of the shipping query
     * @param shipping_options Available shipping options
     * @param error_message An error message, empty on success
     */
    public async Ok answer_shipping_query (
        int64 shipping_query_id,
        Gee.ArrayList<ShippingOption?> shipping_options,
        string error_message
    ) throws TDLibError {
        try {

        var obj = new AnswerShippingQuery (
            shipping_query_id,
            shipping_options,
            error_message
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (answer_shipping_query.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the result of a pre-checkout query; for bots only
     * @param pre_checkout_query_id Identifier of the pre-checkout query
     * @param error_message An error message, empty on success
     */
    public async Ok answer_pre_checkout_query (
        int64 pre_checkout_query_id,
        string error_message
    ) throws TDLibError {
        try {

        var obj = new AnswerPreCheckoutQuery (
            pre_checkout_query_id,
            error_message
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (answer_pre_checkout_query.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Updates the game score of the specified user in the game; for bots
     * only
     * @param chat_id The chat to which the message with the game belongs
     * @param message_id Identifier of the message
     * @param edit_message Pass true to edit the game message to include the
     * current scoreboard
     * @param user_id User identifier
     * @param score The new score
     * @param force Pass true to update the score even if it decreases. If
     * the score is 0, the user will be deleted from the high score table
     */
    public async Message set_game_score (
        int64 chat_id,
        int64 message_id,
        bool edit_message,
        int64 user_id,
        int32 score,
        bool force
    ) throws TDLibError {
        try {

        var obj = new SetGameScore (
            chat_id,
            message_id,
            edit_message,
            user_id,
            score,
            force
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_game_score.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Message) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Updates the game score of the specified user in a game; for bots only
     * @param inline_message_id Inline message identifier
     * @param edit_message Pass true to edit the game message to include the
     * current scoreboard
     * @param user_id User identifier
     * @param score The new score
     * @param force Pass true to update the score even if it decreases. If
     * the score is 0, the user will be deleted from the high score table
     */
    public async Ok set_inline_game_score (
        string inline_message_id,
        bool edit_message,
        int64 user_id,
        int32 score,
        bool force
    ) throws TDLibError {
        try {

        var obj = new SetInlineGameScore (
            inline_message_id,
            edit_message,
            user_id,
            score,
            force
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_inline_game_score.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the high scores for a game and some part of the high score
     * table in the range of the specified user; for bots only
     * @param chat_id The chat that contains the message with the game
     * @param message_id Identifier of the message
     * @param user_id User identifier
     */
    public async GameHighScores get_game_high_scores (
        int64 chat_id,
        int64 message_id,
        int64 user_id
    ) throws TDLibError {
        try {

        var obj = new GetGameHighScores (
            chat_id,
            message_id,
            user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_game_high_scores.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (GameHighScores) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns game high scores and some part of the high score table in the
     * range of the specified user; for bots only
     * @param inline_message_id Inline message identifier
     * @param user_id User identifier
     */
    public async GameHighScores get_inline_game_high_scores (
        string inline_message_id,
        int64 user_id
    ) throws TDLibError {
        try {

        var obj = new GetInlineGameHighScores (
            inline_message_id,
            user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_inline_game_high_scores.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (GameHighScores) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes the default reply markup from a chat. Must be called after a
     * one-time keyboard or a replyMarkupForceReply reply markup has been
     * used. An updateChatReplyMarkup update will be sent if the reply markup
     * is changed
     * @param chat_id Chat identifier
     * @param message_id The message identifier of the used keyboard
     */
    public async Ok delete_chat_reply_markup (
        int64 chat_id,
        int64 message_id
    ) throws TDLibError {
        try {

        var obj = new DeleteChatReplyMarkup (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_chat_reply_markup.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends a notification about user activity in a chat
     * @param chat_id Chat identifier
     * @param message_thread_id If not 0, the message thread identifier in
     * which the action was performed
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which to send the request; for bots only
     * @param action The action description; pass null to cancel the
     * currently active action
     */
    public async Ok send_chat_action (
        int64 chat_id,
        int64 message_thread_id,
        string business_connection_id,
        ChatAction action
    ) throws TDLibError {
        try {

        var obj = new SendChatAction (
            chat_id,
            message_thread_id,
            business_connection_id,
            action
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_chat_action.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs TDLib that the chat is opened by the user. Many useful
     * activities depend on the chat being opened or closed (e.g., in
     * supergroups and channels all updates are received only for opened
     * chats)
     * @param chat_id Chat identifier
     */
    public async Ok open_chat (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new OpenChat (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (open_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs TDLib that the chat is closed by the user. Many useful
     * activities depend on the chat being opened or closed
     * @param chat_id Chat identifier
     */
    public async Ok close_chat (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new CloseChat (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (close_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs TDLib that messages are being viewed by the user. Sponsored
     * messages must be marked as viewed only when the entire text of the
     * message is shown on the screen (excluding the button).
     * Many useful activities depend on whether the messages are currently
     * being viewed or not (e.g., marking messages as read, incrementing a
     * view counter, updating a view counter, removing deleted messages in
     * supergroups and channels)
     * @param chat_id Chat identifier
     * @param message_ids The identifiers of the messages being viewed
     * @param source Source of the message view; pass null to guess the
     * source based on chat open state
     * @param force_read Pass true to mark as read the specified messages
     * even the chat is closed
     */
    public async Ok view_messages (
        int64 chat_id,
        Gee.ArrayList<int64?> message_ids,
        MessageSource source,
        bool force_read
    ) throws TDLibError {
        try {

        var obj = new ViewMessages (
            chat_id,
            message_ids,
            source,
            force_read
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (view_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs TDLib that the message content has been opened (e.g., the user
     * has opened a photo, video, document, location or venue, or has
     * listened to an audio file or voice note message).
     * An updateMessageContentOpened update will be generated if something
     * has changed
     * @param chat_id Chat identifier of the message
     * @param message_id Identifier of the message with the opened content
     */
    public async Ok open_message_content (
        int64 chat_id,
        int64 message_id
    ) throws TDLibError {
        try {

        var obj = new OpenMessageContent (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (open_message_content.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs TDLib that a message with an animated emoji was clicked by the
     * user. Returns a big animated sticker to be played or a 404 error if
     * usual animation needs to be played
     * @param chat_id Chat identifier of the message
     * @param message_id Identifier of the clicked message
     */
    public async Sticker click_animated_emoji_message (
        int64 chat_id,
        int64 message_id
    ) throws TDLibError {
        try {

        var obj = new ClickAnimatedEmojiMessage (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (click_animated_emoji_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Sticker) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an HTTPS or a tg: link with the given type. Can be called
     * before authorization
     * @param type_ Expected type of the link
     * @param is_http Pass true to create an HTTPS link (only available for
     * some link types); pass false to create a tg: link
     */
    public async HttpUrl get_internal_link (
        InternalLinkType type_,
        bool is_http
    ) throws TDLibError {
        try {

        var obj = new GetInternalLink (
            type_,
            is_http
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_internal_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (HttpUrl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about the type of internal link. Returns a 404
     * error if the link is not internal. Can be called before authorization
     * @param link The link
     */
    public async InternalLinkType get_internal_link_type (
        string link
    ) throws TDLibError {
        try {

        var obj = new GetInternalLinkType (
            link
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_internal_link_type.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (InternalLinkType) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about an action to be done when the current user
     * clicks an external link. Don't use this method for links from secret
     * chats if link preview is disabled in secret chats
     * @param link The link
     */
    public async LoginUrlInfo get_external_link_info (
        string link
    ) throws TDLibError {
        try {

        var obj = new GetExternalLinkInfo (
            link
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_external_link_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (LoginUrlInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an HTTP URL which can be used to automatically authorize the
     * current user on a website after clicking an HTTP link. Use the method
     * {@link Client.get_external_link_info} to find whether a prior user
     * confirmation is needed
     * @param link The HTTP link
     * @param allow_write_access Pass true if the current user allowed the
     * bot, returned in {@link Client.get_external_link_info} to send them
     * messages
     */
    public async HttpUrl get_external_link (
        string link,
        bool allow_write_access
    ) throws TDLibError {
        try {

        var obj = new GetExternalLink (
            link,
            allow_write_access
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_external_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (HttpUrl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Marks all mentions in a chat as read
     * @param chat_id Chat identifier
     */
    public async Ok read_all_chat_mentions (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new ReadAllChatMentions (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (read_all_chat_mentions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Marks all mentions in a forum topic as read
     * @param chat_id Chat identifier
     * @param message_thread_id Message thread identifier in which mentions
     * are marked as read
     */
    public async Ok read_all_message_thread_mentions (
        int64 chat_id,
        int64 message_thread_id
    ) throws TDLibError {
        try {

        var obj = new ReadAllMessageThreadMentions (
            chat_id,
            message_thread_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (read_all_message_thread_mentions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Marks all reactions in a chat or a forum topic as read
     * @param chat_id Chat identifier
     */
    public async Ok read_all_chat_reactions (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new ReadAllChatReactions (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (read_all_chat_reactions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Marks all reactions in a forum topic as read
     * @param chat_id Chat identifier
     * @param message_thread_id Message thread identifier in which reactions
     * are marked as read
     */
    public async Ok read_all_message_thread_reactions (
        int64 chat_id,
        int64 message_thread_id
    ) throws TDLibError {
        try {

        var obj = new ReadAllMessageThreadReactions (
            chat_id,
            message_thread_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (read_all_message_thread_reactions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an existing chat corresponding to a given user
     * @param user_id User identifier
     * @param force Pass true to create the chat without a network request.
     * In this case all information about the chat except its type, title and
     * photo can be incorrect
     */
    public async Chat create_private_chat (
        int64 user_id,
        bool force
    ) throws TDLibError {
        try {

        var obj = new CreatePrivateChat (
            user_id,
            force
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_private_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chat) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an existing chat corresponding to a known basic group
     * @param basic_group_id Basic group identifier
     * @param force Pass true to create the chat without a network request.
     * In this case all information about the chat except its type, title and
     * photo can be incorrect
     */
    public async Chat create_basic_group_chat (
        int64 basic_group_id,
        bool force
    ) throws TDLibError {
        try {

        var obj = new CreateBasicGroupChat (
            basic_group_id,
            force
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_basic_group_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chat) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an existing chat corresponding to a known supergroup or
     * channel
     * @param supergroup_id Supergroup or channel identifier
     * @param force Pass true to create the chat without a network request.
     * In this case all information about the chat except its type, title and
     * photo can be incorrect
     */
    public async Chat create_supergroup_chat (
        int64 supergroup_id,
        bool force
    ) throws TDLibError {
        try {

        var obj = new CreateSupergroupChat (
            supergroup_id,
            force
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_supergroup_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chat) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an existing chat corresponding to a known secret chat
     * @param secret_chat_id Secret chat identifier
     */
    public async Chat create_secret_chat (
        int32 secret_chat_id
    ) throws TDLibError {
        try {

        var obj = new CreateSecretChat (
            secret_chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_secret_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chat) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Creates a new basic group and sends a corresponding
     * messageBasicGroupChatCreate. Returns information about the newly
     * created chat
     * @param user_ids Identifiers of users to be added to the basic group;
     * may be empty to create a basic group without other members
     * @param title Title of the new basic group; 1-128 characters
     * @param message_auto_delete_time Message auto-delete time value, in
     * seconds; must be from 0 up to 365 * 86400 and be divisible by 86400.
     * If 0, then messages aren't deleted automatically
     */
    public async CreatedBasicGroupChat create_new_basic_group_chat (
        Gee.ArrayList<int64?> user_ids,
        string title,
        int32 message_auto_delete_time
    ) throws TDLibError {
        try {

        var obj = new CreateNewBasicGroupChat (
            user_ids,
            title,
            message_auto_delete_time
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_new_basic_group_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (CreatedBasicGroupChat) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Creates a new supergroup or channel and sends a corresponding
     * messageSupergroupChatCreate. Returns the newly created chat
     * @param title Title of the new chat; 1-128 characters
     * @param is_forum Pass true to create a forum supergroup chat
     * @param is_channel Pass true to create a channel chat; ignored if a
     * forum is created
     * @param description Chat description; 0-255 characters
     * @param location Chat location if a location-based supergroup is being
     * created; pass null to create an ordinary supergroup chat
     * @param message_auto_delete_time Message auto-delete time value, in
     * seconds; must be from 0 up to 365 * 86400 and be divisible by 86400.
     * If 0, then messages aren't deleted automatically
     * @param for_import Pass true to create a supergroup for importing
     * messages using {@link Client.import_messages}
     */
    public async Chat create_new_supergroup_chat (
        string title,
        bool is_forum,
        bool is_channel,
        string description,
        ChatLocation location,
        int32 message_auto_delete_time,
        bool for_import
    ) throws TDLibError {
        try {

        var obj = new CreateNewSupergroupChat (
            title,
            is_forum,
            is_channel,
            description,
            location,
            message_auto_delete_time,
            for_import
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_new_supergroup_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chat) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Creates a new secret chat. Returns the newly created chat
     * @param user_id Identifier of the target user
     */
    public async Chat create_new_secret_chat (
        int64 user_id
    ) throws TDLibError {
        try {

        var obj = new CreateNewSecretChat (
            user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_new_secret_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chat) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Creates a new supergroup from an existing basic group and sends a
     * corresponding messageChatUpgradeTo and messageChatUpgradeFrom;
     * requires owner privileges. Deactivates the original basic group
     * @param chat_id Identifier of the chat to upgrade
     */
    public async Chat upgrade_basic_group_chat_to_supergroup_chat (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new UpgradeBasicGroupChatToSupergroupChat (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (upgrade_basic_group_chat_to_supergroup_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chat) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns chat lists to which the chat can be added. This is an offline
     * request
     * @param chat_id Chat identifier
     */
    public async ChatLists get_chat_lists_to_add_chat (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetChatListsToAddChat (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_lists_to_add_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatLists) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a chat to a chat list. A chat can't be simultaneously in Main and
     * Archive chat lists, so it is automatically removed from another one if
     * needed
     * @param chat_id Chat identifier
     * @param chat_list The chat list. Use
     * {@link Client.get_chat_lists_to_add_chat} to get suitable chat lists
     */
    public async Ok add_chat_to_list (
        int64 chat_id,
        ChatList chat_list
    ) throws TDLibError {
        try {

        var obj = new AddChatToList (
            chat_id,
            chat_list
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_chat_to_list.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a chat folder by its identifier
     * @param chat_folder_id Chat folder identifier
     */
    public async ChatFolder get_chat_folder (
        int32 chat_folder_id
    ) throws TDLibError {
        try {

        var obj = new GetChatFolder (
            chat_folder_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_folder.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatFolder) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Creates new chat folder. Returns information about the created chat
     * folder. There can be up to getOption("chat_folder_count_max") chat
     * folders, but the limit can be increased with Telegram Premium
     * @param folder The new chat folder
     */
    public async ChatFolderInfo create_chat_folder (
        ChatFolder folder
    ) throws TDLibError {
        try {

        var obj = new CreateChatFolder (
            folder
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_chat_folder.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatFolderInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits existing chat folder. Returns information about the edited chat
     * folder
     * @param chat_folder_id Chat folder identifier
     * @param folder The edited chat folder
     */
    public async ChatFolderInfo edit_chat_folder (
        int32 chat_folder_id,
        ChatFolder folder
    ) throws TDLibError {
        try {

        var obj = new EditChatFolder (
            chat_folder_id,
            folder
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_chat_folder.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatFolderInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes existing chat folder
     * @param chat_folder_id Chat folder identifier
     * @param leave_chat_ids Identifiers of the chats to leave. The chats
     * must be pinned or always included in the folder
     */
    public async Ok delete_chat_folder (
        int32 chat_folder_id,
        Gee.ArrayList<int64?> leave_chat_ids
    ) throws TDLibError {
        try {

        var obj = new DeleteChatFolder (
            chat_folder_id,
            leave_chat_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_chat_folder.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns identifiers of pinned or always included chats from a chat
     * folder, which are suggested to be left when the chat folder is deleted
     * @param chat_folder_id Chat folder identifier
     */
    public async Chats get_chat_folder_chats_to_leave (
        int32 chat_folder_id
    ) throws TDLibError {
        try {

        var obj = new GetChatFolderChatsToLeave (
            chat_folder_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_folder_chats_to_leave.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns approximate number of chats in a being created chat folder.
     * Main and archive chat lists must be fully preloaded for this function
     * to work correctly
     * @param folder The new chat folder
     */
    public async Count get_chat_folder_chat_count (
        ChatFolder folder
    ) throws TDLibError {
        try {

        var obj = new GetChatFolderChatCount (
            folder
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_folder_chat_count.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Count) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the order of chat folders
     * @param chat_folder_ids Identifiers of chat folders in the new correct
     * order
     * @param main_chat_list_position Position of the main chat list among
     * chat folders, 0-based. Can be non-zero only for Premium users
     */
    public async Ok reorder_chat_folders (
        Gee.ArrayList<int32?> chat_folder_ids,
        int32 main_chat_list_position
    ) throws TDLibError {
        try {

        var obj = new ReorderChatFolders (
            chat_folder_ids,
            main_chat_list_position
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reorder_chat_folders.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether chat folder tags are enabled
     * @param are_tags_enabled Pass true to enable folder tags; pass false to
     * disable them
     */
    public async Ok toggle_chat_folder_tags (
        bool are_tags_enabled
    ) throws TDLibError {
        try {

        var obj = new ToggleChatFolderTags (
            are_tags_enabled
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_chat_folder_tags.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns recommended chat folders for the current user
     */
    public async RecommendedChatFolders get_recommended_chat_folders () throws TDLibError {
        try {

        var obj = new GetRecommendedChatFolders ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_recommended_chat_folders.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (RecommendedChatFolders) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns default icon name for a folder. Can be called synchronously
     * @param folder Chat folder
     */
    public ChatFolderIcon get_chat_folder_default_icon_name_sync (
        ChatFolder folder
    ) throws TDLibError {
        try {

        var obj = new GetChatFolderDefaultIconName (
            folder
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatFolderIcon) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns default icon name for a folder. Can be called synchronously
     * @param folder Chat folder
     */
    public async ChatFolderIcon get_chat_folder_default_icon_name (
        ChatFolder folder
    ) throws TDLibError {
        try {

        var obj = new GetChatFolderDefaultIconName (
            folder
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_folder_default_icon_name.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatFolderIcon) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns identifiers of chats from a chat folder, suitable for adding
     * to a chat folder invite link
     * @param chat_folder_id Chat folder identifier
     */
    public async Chats get_chats_for_chat_folder_invite_link (
        int32 chat_folder_id
    ) throws TDLibError {
        try {

        var obj = new GetChatsForChatFolderInviteLink (
            chat_folder_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chats_for_chat_folder_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Creates a new invite link for a chat folder. A link can be created for
     * a chat folder if it has only pinned and included chats
     * @param chat_folder_id Chat folder identifier
     * @param name Name of the link; 0-32 characters
     * @param chat_ids Identifiers of chats to be accessible by the invite
     * link. Use {@link Client.get_chats_for_chat_folder_invite_link} to get
     * suitable chats. Basic groups will be automatically converted to
     * supergroups before link creation
     */
    public async ChatFolderInviteLink create_chat_folder_invite_link (
        int32 chat_folder_id,
        string name,
        Gee.ArrayList<int64?> chat_ids
    ) throws TDLibError {
        try {

        var obj = new CreateChatFolderInviteLink (
            chat_folder_id,
            name,
            chat_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_chat_folder_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatFolderInviteLink) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns invite links created by the current user for a shareable chat
     * folder
     * @param chat_folder_id Chat folder identifier
     */
    public async ChatFolderInviteLinks get_chat_folder_invite_links (
        int32 chat_folder_id
    ) throws TDLibError {
        try {

        var obj = new GetChatFolderInviteLinks (
            chat_folder_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_folder_invite_links.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatFolderInviteLinks) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits an invite link for a chat folder
     * @param chat_folder_id Chat folder identifier
     * @param invite_link Invite link to be edited
     * @param name New name of the link; 0-32 characters
     * @param chat_ids New identifiers of chats to be accessible by the
     * invite link. Use {@link Client.get_chats_for_chat_folder_invite_link}
     * to get suitable chats. Basic groups will be automatically converted to
     * supergroups before link editing
     */
    public async ChatFolderInviteLink edit_chat_folder_invite_link (
        int32 chat_folder_id,
        string invite_link,
        string name,
        Gee.ArrayList<int64?> chat_ids
    ) throws TDLibError {
        try {

        var obj = new EditChatFolderInviteLink (
            chat_folder_id,
            invite_link,
            name,
            chat_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_chat_folder_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatFolderInviteLink) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes an invite link for a chat folder
     * @param chat_folder_id Chat folder identifier
     * @param invite_link Invite link to be deleted
     */
    public async Ok delete_chat_folder_invite_link (
        int32 chat_folder_id,
        string invite_link
    ) throws TDLibError {
        try {

        var obj = new DeleteChatFolderInviteLink (
            chat_folder_id,
            invite_link
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_chat_folder_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks the validity of an invite link for a chat folder and returns
     * information about the corresponding chat folder
     * @param invite_link Invite link to be checked
     */
    public async ChatFolderInviteLinkInfo check_chat_folder_invite_link (
        string invite_link
    ) throws TDLibError {
        try {

        var obj = new CheckChatFolderInviteLink (
            invite_link
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_chat_folder_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatFolderInviteLinkInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a chat folder by an invite link
     * @param invite_link Invite link for the chat folder
     * @param chat_ids Identifiers of the chats added to the chat folder. The
     * chats are automatically joined if they aren't joined yet
     */
    public async Ok add_chat_folder_by_invite_link (
        string invite_link,
        Gee.ArrayList<int64?> chat_ids
    ) throws TDLibError {
        try {

        var obj = new AddChatFolderByInviteLink (
            invite_link,
            chat_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_chat_folder_by_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns new chats added to a shareable chat folder by its owner. The
     * method must be called at most once in
     * getOption("chat_folder_new_chats_update_period") for the given chat
     * folder
     * @param chat_folder_id Chat folder identifier
     */
    public async Chats get_chat_folder_new_chats (
        int32 chat_folder_id
    ) throws TDLibError {
        try {

        var obj = new GetChatFolderNewChats (
            chat_folder_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_folder_new_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Process new chats added to a shareable chat folder by its owner
     * @param chat_folder_id Chat folder identifier
     * @param added_chat_ids Identifiers of the new chats, which are added to
     * the chat folder. The chats are automatically joined if they aren't
     * joined yet
     */
    public async Ok process_chat_folder_new_chats (
        int32 chat_folder_id,
        Gee.ArrayList<int64?> added_chat_ids
    ) throws TDLibError {
        try {

        var obj = new ProcessChatFolderNewChats (
            chat_folder_id,
            added_chat_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (process_chat_folder_new_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns settings for automatic moving of chats to and from the Archive
     * chat lists
     */
    public async ArchiveChatListSettings get_archive_chat_list_settings () throws TDLibError {
        try {

        var obj = new GetArchiveChatListSettings ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_archive_chat_list_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ArchiveChatListSettings) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes settings for automatic moving of chats to and from the Archive
     * chat lists
     * @param settings New settings
     */
    public async Ok set_archive_chat_list_settings (
        ArchiveChatListSettings settings
    ) throws TDLibError {
        try {

        var obj = new SetArchiveChatListSettings (
            settings
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_archive_chat_list_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the chat title. Supported only for basic groups, supergroups
     * and channels. Requires can_change_info member right
     * @param chat_id Chat identifier
     * @param title New title of the chat; 1-128 characters
     */
    public async Ok set_chat_title (
        int64 chat_id,
        string title
    ) throws TDLibError {
        try {

        var obj = new SetChatTitle (
            chat_id,
            title
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_title.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the photo of a chat. Supported only for basic groups,
     * supergroups and channels. Requires can_change_info member right
     * @param chat_id Chat identifier
     * @param photo New chat photo; pass null to delete the chat photo
     */
    public async Ok set_chat_photo (
        int64 chat_id,
        InputChatPhoto photo
    ) throws TDLibError {
        try {

        var obj = new SetChatPhoto (
            chat_id,
            photo
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_photo.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes accent color and background custom emoji of a channel chat.
     * Requires can_change_info administrator right
     * @param chat_id Chat identifier
     * @param accent_color_id Identifier of the accent color to use. The chat
     * must have at least accentColor.min_channel_chat_boost_level boost
     * level to pass the corresponding color
     * @param background_custom_emoji_id Identifier of a custom emoji to be
     * shown on the reply header and link preview background; 0 if none. Use
     * chatBoostLevelFeatures.can_set_background_custom_emoji to check
     * whether a custom emoji can be set
     */
    public async Ok set_chat_accent_color (
        int64 chat_id,
        int32 accent_color_id,
        int64 background_custom_emoji_id
    ) throws TDLibError {
        try {

        var obj = new SetChatAccentColor (
            chat_id,
            accent_color_id,
            background_custom_emoji_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_accent_color.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes accent color and background custom emoji for profile of a
     * supergroup or channel chat. Requires can_change_info administrator
     * right
     * @param chat_id Chat identifier
     * @param profile_accent_color_id Identifier of the accent color to use
     * for profile; pass -1 if none. The chat must have at least
     * profileAccentColor.min_supergroup_chat_boost_level for supergroups or
     * profileAccentColor.min_channel_chat_boost_level for channels boost
     * level to pass the corresponding color
     * @param profile_background_custom_emoji_id Identifier of a custom emoji
     * to be shown on the chat's profile photo background; 0 if none. Use
     * chatBoostLevelFeatures.can_set_profile_background_custom_emoji to
     * check whether a custom emoji can be set
     */
    public async Ok set_chat_profile_accent_color (
        int64 chat_id,
        int32 profile_accent_color_id,
        int64 profile_background_custom_emoji_id
    ) throws TDLibError {
        try {

        var obj = new SetChatProfileAccentColor (
            chat_id,
            profile_accent_color_id,
            profile_background_custom_emoji_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_profile_accent_color.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the message auto-delete or self-destruct (for secret chats)
     * time in a chat. Requires change_info administrator right in basic
     * groups, supergroups and channels.
     * Message auto-delete time can't be changed in a chat with the current
     * user (Saved Messages) and the chat 777000 (Telegram).
     * @param chat_id Chat identifier
     * @param message_auto_delete_time New time value, in seconds; unless the
     * chat is secret, it must be from 0 up to 365 * 86400 and be divisible
     * by 86400. If 0, then messages aren't deleted automatically
     */
    public async Ok set_chat_message_auto_delete_time (
        int64 chat_id,
        int32 message_auto_delete_time
    ) throws TDLibError {
        try {

        var obj = new SetChatMessageAutoDeleteTime (
            chat_id,
            message_auto_delete_time
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_message_auto_delete_time.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the emoji status of a chat. Use
     * chatBoostLevelFeatures.can_set_emoji_status to check whether an emoji
     * status can be set. Requires can_change_info administrator right
     * @param chat_id Chat identifier
     * @param emoji_status New emoji status; pass null to remove emoji status
     */
    public async Ok set_chat_emoji_status (
        int64 chat_id,
        EmojiStatus emoji_status
    ) throws TDLibError {
        try {

        var obj = new SetChatEmojiStatus (
            chat_id,
            emoji_status
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_emoji_status.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the chat members permissions. Supported only for basic groups
     * and supergroups. Requires can_restrict_members administrator right
     * @param chat_id Chat identifier
     * @param permissions New non-administrator members permissions in the
     * chat
     */
    public async Ok set_chat_permissions (
        int64 chat_id,
        ChatPermissions permissions
    ) throws TDLibError {
        try {

        var obj = new SetChatPermissions (
            chat_id,
            permissions
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_permissions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the background in a specific chat. Supported only in private and
     * secret chats with non-deleted users, and in chats with sufficient
     * boost level and can_change_info administrator right
     * @param chat_id Chat identifier
     * @param background The input background to use; pass null to create a
     * new filled or chat theme background
     * @param type_ Background type; pass null to use default background type
     * for the chosen background; backgroundTypeChatTheme isn't supported for
     * private and secret chats. Use
     * chatBoostLevelFeatures.chat_theme_background_count and
     * chatBoostLevelFeatures.can_set_custom_background to check whether the
     * background type can be set in the boosted chat
     * @param dark_theme_dimming Dimming of the background in dark themes, as
     * a percentage; 0-100. Applied only to Wallpaper and Fill types of
     * background
     * @param only_for_self Pass true to set background only for self; pass
     * false to set background for all chat users. Always false for
     * backgrounds set in boosted chats. Background can be set for both users
     * only by Telegram Premium users and if set background isn't of the type
     * inputBackgroundPrevious
     */
    public async Ok set_chat_background (
        int64 chat_id,
        InputBackground background,
        BackgroundType type_,
        int32 dark_theme_dimming,
        bool only_for_self
    ) throws TDLibError {
        try {

        var obj = new SetChatBackground (
            chat_id,
            background,
            type_,
            dark_theme_dimming,
            only_for_self
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_background.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes background in a specific chat
     * @param chat_id Chat identifier
     * @param restore_previous Pass true to restore previously set
     * background. Can be used only in private and secret chats with
     * non-deleted users if userFullInfo.set_chat_background == true.
     * Supposed to be used from messageChatSetBackground messages with the
     * currently set background that was set for both sides by the other user
     */
    public async Ok delete_chat_background (
        int64 chat_id,
        bool restore_previous
    ) throws TDLibError {
        try {

        var obj = new DeleteChatBackground (
            chat_id,
            restore_previous
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_chat_background.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the chat theme. Supported only in private and secret chats
     * @param chat_id Chat identifier
     * @param theme_name Name of the new chat theme; pass an empty string to
     * return the default theme
     */
    public async Ok set_chat_theme (
        int64 chat_id,
        string theme_name
    ) throws TDLibError {
        try {

        var obj = new SetChatTheme (
            chat_id,
            theme_name
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_theme.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the draft message in a chat
     * @param chat_id Chat identifier
     * @param message_thread_id If not 0, the message thread identifier in
     * which the draft was changed
     * @param draft_message New draft message; pass null to remove the draft.
     * All files in draft message content must be of the type inputFileLocal.
     * Media thumbnails and captions are ignored
     */
    public async Ok set_chat_draft_message (
        int64 chat_id,
        int64 message_thread_id,
        DraftMessage draft_message
    ) throws TDLibError {
        try {

        var obj = new SetChatDraftMessage (
            chat_id,
            message_thread_id,
            draft_message
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_draft_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the notification settings of a chat. Notification settings of
     * a chat with the current user (Saved Messages) can't be changed
     * @param chat_id Chat identifier
     * @param notification_settings New notification settings for the chat.
     * If the chat is muted for more than 366 days, it is considered to be
     * muted forever
     */
    public async Ok set_chat_notification_settings (
        int64 chat_id,
        ChatNotificationSettings notification_settings
    ) throws TDLibError {
        try {

        var obj = new SetChatNotificationSettings (
            chat_id,
            notification_settings
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_notification_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the ability of users to save, forward, or copy chat content.
     * Supported only for basic groups, supergroups and channels. Requires
     * owner privileges
     * @param chat_id Chat identifier
     * @param has_protected_content New value of has_protected_content
     */
    public async Ok toggle_chat_has_protected_content (
        int64 chat_id,
        bool has_protected_content
    ) throws TDLibError {
        try {

        var obj = new ToggleChatHasProtectedContent (
            chat_id,
            has_protected_content
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_chat_has_protected_content.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the view_as_topics setting of a forum chat or Saved Messages
     * @param chat_id Chat identifier
     * @param view_as_topics New value of view_as_topics
     */
    public async Ok toggle_chat_view_as_topics (
        int64 chat_id,
        bool view_as_topics
    ) throws TDLibError {
        try {

        var obj = new ToggleChatViewAsTopics (
            chat_id,
            view_as_topics
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_chat_view_as_topics.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the translatable state of a chat
     * @param chat_id Chat identifier
     * @param is_translatable New value of is_translatable
     */
    public async Ok toggle_chat_is_translatable (
        int64 chat_id,
        bool is_translatable
    ) throws TDLibError {
        try {

        var obj = new ToggleChatIsTranslatable (
            chat_id,
            is_translatable
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_chat_is_translatable.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the marked as unread state of a chat
     * @param chat_id Chat identifier
     * @param is_marked_as_unread New value of is_marked_as_unread
     */
    public async Ok toggle_chat_is_marked_as_unread (
        int64 chat_id,
        bool is_marked_as_unread
    ) throws TDLibError {
        try {

        var obj = new ToggleChatIsMarkedAsUnread (
            chat_id,
            is_marked_as_unread
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_chat_is_marked_as_unread.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the value of the default disable_notification parameter, used
     * when a message is sent to a chat
     * @param chat_id Chat identifier
     * @param default_disable_notification New value of
     * default_disable_notification
     */
    public async Ok toggle_chat_default_disable_notification (
        int64 chat_id,
        bool default_disable_notification
    ) throws TDLibError {
        try {

        var obj = new ToggleChatDefaultDisableNotification (
            chat_id,
            default_disable_notification
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_chat_default_disable_notification.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes reactions, available in a chat. Available for basic groups,
     * supergroups, and channels. Requires can_change_info member right
     * @param chat_id Identifier of the chat
     * @param available_reactions Reactions available in the chat. All
     * explicitly specified emoji reactions must be active. In channel chats
     * up to the chat's boost level custom emoji reactions can be explicitly
     * specified
     */
    public async Ok set_chat_available_reactions (
        int64 chat_id,
        ChatAvailableReactions available_reactions
    ) throws TDLibError {
        try {

        var obj = new SetChatAvailableReactions (
            chat_id,
            available_reactions
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_available_reactions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes application-specific data associated with a chat
     * @param chat_id Chat identifier
     * @param client_data New value of client_data
     */
    public async Ok set_chat_client_data (
        int64 chat_id,
        string client_data
    ) throws TDLibError {
        try {

        var obj = new SetChatClientData (
            chat_id,
            client_data
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_client_data.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes information about a chat. Available for basic groups,
     * supergroups, and channels. Requires can_change_info member right
     * @param chat_id Identifier of the chat
     * @param description New chat description; 0-255 characters
     */
    public async Ok set_chat_description (
        int64 chat_id,
        string description
    ) throws TDLibError {
        try {

        var obj = new SetChatDescription (
            chat_id,
            description
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_description.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the discussion group of a channel chat; requires
     * can_change_info administrator right in the channel if it is specified
     * @param chat_id Identifier of the channel chat. Pass 0 to remove a link
     * from the supergroup passed in the second argument to a linked channel
     * chat (requires can_pin_messages member right in the supergroup)
     * @param discussion_chat_id Identifier of a new channel's discussion
     * group. Use 0 to remove the discussion group. Use the method
     * {@link Client.get_suitable_discussion_chats} to find all suitable
     * groups. Basic group chats must be first upgraded to supergroup chats.
     * If new chat members don't have access to old messages in the
     * supergroup, then
     * {@link Client.toggle_supergroup_is_all_history_available} must be used
     * first to change that
     */
    public async Ok set_chat_discussion_group (
        int64 chat_id,
        int64 discussion_chat_id
    ) throws TDLibError {
        try {

        var obj = new SetChatDiscussionGroup (
            chat_id,
            discussion_chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_discussion_group.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the location of a chat. Available only for some location-based
     * supergroups, use supergroupFullInfo.can_set_location to check whether
     * the method is allowed to use
     * @param chat_id Chat identifier
     * @param location New location for the chat; must be valid and not null
     */
    public async Ok set_chat_location (
        int64 chat_id,
        ChatLocation location
    ) throws TDLibError {
        try {

        var obj = new SetChatLocation (
            chat_id,
            location
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_location.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the slow mode delay of a chat. Available only for supergroups;
     * requires can_restrict_members right
     * @param chat_id Chat identifier
     * @param slow_mode_delay New slow mode delay for the chat, in seconds;
     * must be one of 0, 10, 30, 60, 300, 900, 3600
     */
    public async Ok set_chat_slow_mode_delay (
        int64 chat_id,
        int32 slow_mode_delay
    ) throws TDLibError {
        try {

        var obj = new SetChatSlowModeDelay (
            chat_id,
            slow_mode_delay
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_slow_mode_delay.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Pins a message in a chat. A message can be pinned only if
     * messageProperties.can_be_pinned
     * @param chat_id Identifier of the chat
     * @param message_id Identifier of the new pinned message
     * @param disable_notification Pass true to disable notification about
     * the pinned message. Notifications are always disabled in channels and
     * private chats
     * @param only_for_self Pass true to pin the message only for self;
     * private chats only
     */
    public async Ok pin_chat_message (
        int64 chat_id,
        int64 message_id,
        bool disable_notification,
        bool only_for_self
    ) throws TDLibError {
        try {

        var obj = new PinChatMessage (
            chat_id,
            message_id,
            disable_notification,
            only_for_self
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (pin_chat_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes a pinned message from a chat; requires can_pin_messages member
     * right if the chat is a basic group or supergroup, or can_edit_messages
     * administrator right if the chat is a channel
     * @param chat_id Identifier of the chat
     * @param message_id Identifier of the removed pinned message
     */
    public async Ok unpin_chat_message (
        int64 chat_id,
        int64 message_id
    ) throws TDLibError {
        try {

        var obj = new UnpinChatMessage (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (unpin_chat_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes all pinned messages from a chat; requires can_pin_messages
     * member right if the chat is a basic group or supergroup, or
     * can_edit_messages administrator right if the chat is a channel
     * @param chat_id Identifier of the chat
     */
    public async Ok unpin_all_chat_messages (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new UnpinAllChatMessages (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (unpin_all_chat_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes all pinned messages from a forum topic; requires
     * can_pin_messages member right in the supergroup
     * @param chat_id Identifier of the chat
     * @param message_thread_id Message thread identifier in which messages
     * will be unpinned
     */
    public async Ok unpin_all_message_thread_messages (
        int64 chat_id,
        int64 message_thread_id
    ) throws TDLibError {
        try {

        var obj = new UnpinAllMessageThreadMessages (
            chat_id,
            message_thread_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (unpin_all_message_thread_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds the current user as a new member to a chat. Private and secret
     * chats can't be joined using this method. May return an error with a
     * message "INVITE_REQUEST_SENT" if only a join request was created
     * @param chat_id Chat identifier
     */
    public async Ok join_chat (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new JoinChat (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (join_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes the current user from chat members. Private and secret chats
     * can't be left using this method
     * @param chat_id Chat identifier
     */
    public async Ok leave_chat (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new LeaveChat (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (leave_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a new member to a chat; requires can_invite_users member right.
     * Members can't be added to private or secret chats. Returns information
     * about members that weren't added
     * @param chat_id Chat identifier
     * @param user_id Identifier of the user
     * @param forward_limit The number of earlier messages from the chat to
     * be forwarded to the new member; up to 100. Ignored for supergroups and
     * channels, or if the added user is a bot
     */
    public async FailedToAddMembers add_chat_member (
        int64 chat_id,
        int64 user_id,
        int32 forward_limit
    ) throws TDLibError {
        try {

        var obj = new AddChatMember (
            chat_id,
            user_id,
            forward_limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_chat_member.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FailedToAddMembers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds multiple new members to a chat; requires can_invite_users member
     * right. Currently, this method is only available for supergroups and
     * channels.
     * This method can't be used to join a chat. Members can't be added to a
     * channel if it has more than 200 members. Returns information about
     * members that weren't added
     * @param chat_id Chat identifier
     * @param user_ids Identifiers of the users to be added to the chat. The
     * maximum number of added users is 20 for supergroups and 100 for
     * channels
     */
    public async FailedToAddMembers add_chat_members (
        int64 chat_id,
        Gee.ArrayList<int64?> user_ids
    ) throws TDLibError {
        try {

        var obj = new AddChatMembers (
            chat_id,
            user_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_chat_members.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FailedToAddMembers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the status of a chat member; requires can_invite_users member
     * right to add a chat member, can_promote_members administrator right to
     * change administrator rights of the member,
     * and can_restrict_members administrator right to change restrictions of
     * a user. This function is currently not suitable for transferring chat
     * ownership; use {@link Client.transfer_chat_ownership} instead.
     * Use {@link Client.add_chat_member} or {@link Client.ban_chat_member}
     * if some additional parameters needs to be passed
     * @param chat_id Chat identifier
     * @param member_id Member identifier. Chats can be only banned and
     * unbanned in supergroups and channels
     * @param status The new status of the member in the chat
     */
    public async Ok set_chat_member_status (
        int64 chat_id,
        MessageSender member_id,
        ChatMemberStatus status
    ) throws TDLibError {
        try {

        var obj = new SetChatMemberStatus (
            chat_id,
            member_id,
            status
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_member_status.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Bans a member in a chat; requires can_restrict_members administrator
     * right. Members can't be banned in private or secret chats. In
     * supergroups and channels, the user will not be able to return to the
     * group on their own using invite links, etc., unless unbanned first
     * @param chat_id Chat identifier
     * @param member_id Member identifier
     * @param banned_until_date Point in time (Unix timestamp) when the user
     * will be unbanned; 0 if never. If the user is banned for more than 366
     * days or for less than 30 seconds from the current time, the user is
     * considered to be banned forever. Ignored in basic groups and if a chat
     * is banned
     * @param revoke_messages Pass true to delete all messages in the chat
     * for the user that is being removed. Always true for supergroups and
     * channels
     */
    public async Ok ban_chat_member (
        int64 chat_id,
        MessageSender member_id,
        int32 banned_until_date,
        bool revoke_messages
    ) throws TDLibError {
        try {

        var obj = new BanChatMember (
            chat_id,
            member_id,
            banned_until_date,
            revoke_messages
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (ban_chat_member.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks whether the current session can be used to transfer a chat
     * ownership to another user
     */
    public async CanTransferOwnershipResult can_transfer_ownership () throws TDLibError {
        try {

        var obj = new CanTransferOwnership ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (can_transfer_ownership.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (CanTransferOwnershipResult) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the owner of a chat; requires owner privileges in the chat.
     * Use the method {@link Client.can_transfer_ownership} to check whether
     * the ownership can be transferred from the current session. Available
     * only for supergroups and channel chats
     * @param chat_id Chat identifier
     * @param user_id Identifier of the user to which transfer the ownership.
     * The ownership can't be transferred to a bot or to a deleted user
     * @param password The 2-step verification password of the current user
     */
    public async Ok transfer_chat_ownership (
        int64 chat_id,
        int64 user_id,
        string password
    ) throws TDLibError {
        try {

        var obj = new TransferChatOwnership (
            chat_id,
            user_id,
            password
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (transfer_chat_ownership.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a single member of a chat
     * @param chat_id Chat identifier
     * @param member_id Member identifier
     */
    public async ChatMember get_chat_member (
        int64 chat_id,
        MessageSender member_id
    ) throws TDLibError {
        try {

        var obj = new GetChatMember (
            chat_id,
            member_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_member.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatMember) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for a specified query in the first name, last name and
     * usernames of the members of a specified chat. Requires administrator
     * rights if the chat is a channel
     * @param chat_id Chat identifier
     * @param query Query to search for
     * @param limit The maximum number of users to be returned; up to 200
     * @param filter The type of users to search for; pass null to search
     * among all chat members
     */
    public async ChatMembers search_chat_members (
        int64 chat_id,
        string query,
        int32 limit,
        ChatMembersFilter filter
    ) throws TDLibError {
        try {

        var obj = new SearchChatMembers (
            chat_id,
            query,
            limit,
            filter
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_chat_members.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatMembers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a list of administrators of the chat with their custom titles
     * @param chat_id Chat identifier
     */
    public async ChatAdministrators get_chat_administrators (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetChatAdministrators (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_administrators.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatAdministrators) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Clears message drafts in all chats
     * @param exclude_secret_chats Pass true to keep local message drafts in
     * secret chats
     */
    public async Ok clear_all_draft_messages (
        bool exclude_secret_chats
    ) throws TDLibError {
        try {

        var obj = new ClearAllDraftMessages (
            exclude_secret_chats
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clear_all_draft_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns saved notification sound by its identifier. Returns a 404
     * error if there is no saved notification sound with the specified
     * identifier
     * @param notification_sound_id Identifier of the notification sound
     */
    public async NotificationSounds get_saved_notification_sound (
        int64 notification_sound_id
    ) throws TDLibError {
        try {

        var obj = new GetSavedNotificationSound (
            notification_sound_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_saved_notification_sound.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (NotificationSounds) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of saved notification sounds. If a sound isn't in the
     * list, then default sound needs to be used
     */
    public async NotificationSounds get_saved_notification_sounds () throws TDLibError {
        try {

        var obj = new GetSavedNotificationSounds ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_saved_notification_sounds.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (NotificationSounds) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a new notification sound to the list of saved notification
     * sounds. The new notification sound is added to the top of the list. If
     * it is already in the list, its position isn't changed
     * @param sound Notification sound file to add
     */
    public async NotificationSound add_saved_notification_sound (
        InputFile sound
    ) throws TDLibError {
        try {

        var obj = new AddSavedNotificationSound (
            sound
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_saved_notification_sound.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (NotificationSound) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes a notification sound from the list of saved notification
     * sounds
     * @param notification_sound_id Identifier of the notification sound
     */
    public async Ok remove_saved_notification_sound (
        int64 notification_sound_id
    ) throws TDLibError {
        try {

        var obj = new RemoveSavedNotificationSound (
            notification_sound_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_saved_notification_sound.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of chats with non-default notification settings for
     * new messages
     * @param scope If specified, only chats from the scope will be returned;
     * pass null to return chats from all scopes
     * @param compare_sound Pass true to include in the response chats with
     * only non-default sound
     */
    public async Chats get_chat_notification_settings_exceptions (
        NotificationSettingsScope scope,
        bool compare_sound
    ) throws TDLibError {
        try {

        var obj = new GetChatNotificationSettingsExceptions (
            scope,
            compare_sound
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_notification_settings_exceptions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the notification settings for chats of a given type
     * @param scope Types of chats for which to return the notification
     * settings information
     */
    public async ScopeNotificationSettings get_scope_notification_settings (
        NotificationSettingsScope scope
    ) throws TDLibError {
        try {

        var obj = new GetScopeNotificationSettings (
            scope
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_scope_notification_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ScopeNotificationSettings) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes notification settings for chats of a given type
     * @param scope Types of chats for which to change the notification
     * settings
     * @param notification_settings The new notification settings for the
     * given scope
     */
    public async Ok set_scope_notification_settings (
        NotificationSettingsScope scope,
        ScopeNotificationSettings notification_settings
    ) throws TDLibError {
        try {

        var obj = new SetScopeNotificationSettings (
            scope,
            notification_settings
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_scope_notification_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes notification settings for reactions
     * @param notification_settings The new notification settings for
     * reactions
     */
    public async Ok set_reaction_notification_settings (
        ReactionNotificationSettings notification_settings
    ) throws TDLibError {
        try {

        var obj = new SetReactionNotificationSettings (
            notification_settings
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_reaction_notification_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Resets all chat and scope notification settings to their default
     * values. By default, all chats are unmuted and message previews are
     * shown
     */
    public async Ok reset_all_notification_settings () throws TDLibError {
        try {

        var obj = new ResetAllNotificationSettings ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reset_all_notification_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the pinned state of a chat. There can be up to
     * getOption("pinned_chat_count_max")/getOption("pinned_archived_chat_count_max")
     * pinned non-secret chats and the same number of secret chats in the
     * main/archive chat list. The limit can be increased with Telegram
     * Premium
     * @param chat_list Chat list in which to change the pinned state of the
     * chat
     * @param chat_id Chat identifier
     * @param is_pinned Pass true to pin the chat; pass false to unpin it
     */
    public async Ok toggle_chat_is_pinned (
        ChatList chat_list,
        int64 chat_id,
        bool is_pinned
    ) throws TDLibError {
        try {

        var obj = new ToggleChatIsPinned (
            chat_list,
            chat_id,
            is_pinned
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_chat_is_pinned.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the order of pinned chats
     * @param chat_list Chat list in which to change the order of pinned
     * chats
     * @param chat_ids The new list of pinned chats
     */
    public async Ok set_pinned_chats (
        ChatList chat_list,
        Gee.ArrayList<int64?> chat_ids
    ) throws TDLibError {
        try {

        var obj = new SetPinnedChats (
            chat_list,
            chat_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_pinned_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Traverse all chats in a chat list and marks all messages in the chats
     * as read
     * @param chat_list Chat list in which to mark all chats as read
     */
    public async Ok read_chat_list (
        ChatList chat_list
    ) throws TDLibError {
        try {

        var obj = new ReadChatList (
            chat_list
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (read_chat_list.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the current weather in the given location
     * @param location The location
     */
    public async CurrentWeather get_current_weather (
        Location location
    ) throws TDLibError {
        try {

        var obj = new GetCurrentWeather (
            location
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_current_weather.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (CurrentWeather) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a story
     * @param story_sender_chat_id Identifier of the chat that posted the
     * story
     * @param story_id Story identifier
     * @param only_local Pass true to get only locally available information
     * without sending network requests
     */
    public async Story get_story (
        int64 story_sender_chat_id,
        int32 story_id,
        bool only_local
    ) throws TDLibError {
        try {

        var obj = new GetStory (
            story_sender_chat_id,
            story_id,
            only_local
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_story.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Story) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns supergroup and channel chats in which the current user has the
     * right to post stories. The chats must be rechecked with
     * {@link Client.can_send_story} before actually trying to post a story
     * there
     */
    public async Chats get_chats_to_send_stories () throws TDLibError {
        try {

        var obj = new GetChatsToSendStories ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chats_to_send_stories.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks whether the current user can send a story on behalf of a chat;
     * requires can_post_stories right for supergroup and channel chats
     * @param chat_id Chat identifier. Pass Saved Messages chat identifier
     * when posting a story on behalf of the current user
     */
    public async CanSendStoryResult can_send_story (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new CanSendStory (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (can_send_story.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (CanSendStoryResult) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends a new story to a chat; requires can_post_stories right for
     * supergroup and channel chats. Returns a temporary story
     * @param chat_id Identifier of the chat that will post the story. Pass
     * Saved Messages chat identifier when posting a story on behalf of the
     * current user
     * @param content Content of the story
     * @param areas Clickable rectangle areas to be shown on the story media;
     * pass null if none
     * @param caption Story caption; pass null to use an empty caption;
     * 0-getOption("story_caption_length_max") characters; can have entities
     * only if getOption("can_use_text_entities_in_story_caption")
     * @param privacy_settings The privacy settings for the story; ignored
     * for stories sent to supergroup and channel chats
     * @param active_period Period after which the story is moved to archive,
     * in seconds; must be one of 6 * 3600, 12 * 3600, 86400, or 2 * 86400
     * for Telegram Premium users, and 86400 otherwise
     * @param from_story_full_id Full identifier of the original story, which
     * content was used to create the story; pass null if the story isn't
     * repost of another story
     * @param is_posted_to_chat_page Pass true to keep the story accessible
     * after expiration
     * @param protect_content Pass true if the content of the story must be
     * protected from forwarding and screenshotting
     */
    public async Story send_story (
        int64 chat_id,
        InputStoryContent content,
        InputStoryAreas areas,
        FormattedText caption,
        StoryPrivacySettings privacy_settings,
        int32 active_period,
        StoryFullId from_story_full_id,
        bool is_posted_to_chat_page,
        bool protect_content
    ) throws TDLibError {
        try {

        var obj = new SendStory (
            chat_id,
            content,
            areas,
            caption,
            privacy_settings,
            active_period,
            from_story_full_id,
            is_posted_to_chat_page,
            protect_content
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_story.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Story) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes content and caption of a story. Can be called only if
     * story.can_be_edited == true
     * @param story_sender_chat_id Identifier of the chat that posted the
     * story
     * @param story_id Identifier of the story to edit
     * @param content New content of the story; pass null to keep the current
     * content
     * @param areas New clickable rectangle areas to be shown on the story
     * media; pass null to keep the current areas. Areas can't be edited if
     * story content isn't changed
     * @param caption New story caption; pass null to keep the current
     * caption
     */
    public async Ok edit_story (
        int64 story_sender_chat_id,
        int32 story_id,
        InputStoryContent content,
        InputStoryAreas areas,
        FormattedText caption
    ) throws TDLibError {
        try {

        var obj = new EditStory (
            story_sender_chat_id,
            story_id,
            content,
            areas,
            caption
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_story.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes cover of a video story. Can be called only if
     * story.can_be_edited == true and the story isn't being edited now
     * @param story_sender_chat_id Identifier of the chat that posted the
     * story
     * @param story_id Identifier of the story to edit
     * @param cover_frame_timestamp New timestamp of the frame, which will be
     * used as video thumbnail
     */
    public async Ok edit_story_cover (
        int64 story_sender_chat_id,
        int32 story_id,
        double cover_frame_timestamp
    ) throws TDLibError {
        try {

        var obj = new EditStoryCover (
            story_sender_chat_id,
            story_id,
            cover_frame_timestamp
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_story_cover.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes privacy settings of a story. The method can be called only for
     * stories posted on behalf of the current user and if
     * story.can_be_edited == true
     * @param story_id Identifier of the story
     * @param privacy_settings The new privacy settings for the story
     */
    public async Ok set_story_privacy_settings (
        int32 story_id,
        StoryPrivacySettings privacy_settings
    ) throws TDLibError {
        try {

        var obj = new SetStoryPrivacySettings (
            story_id,
            privacy_settings
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_story_privacy_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether a story is accessible after expiration. Can be called
     * only if story.can_toggle_is_posted_to_chat_page == true
     * @param story_sender_chat_id Identifier of the chat that posted the
     * story
     * @param story_id Identifier of the story
     * @param is_posted_to_chat_page Pass true to make the story accessible
     * after expiration; pass false to make it private
     */
    public async Ok toggle_story_is_posted_to_chat_page (
        int64 story_sender_chat_id,
        int32 story_id,
        bool is_posted_to_chat_page
    ) throws TDLibError {
        try {

        var obj = new ToggleStoryIsPostedToChatPage (
            story_sender_chat_id,
            story_id,
            is_posted_to_chat_page
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_story_is_posted_to_chat_page.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes a previously sent story. Can be called only if
     * story.can_be_deleted == true
     * @param story_sender_chat_id Identifier of the chat that posted the
     * story
     * @param story_id Identifier of the story to delete
     */
    public async Ok delete_story (
        int64 story_sender_chat_id,
        int32 story_id
    ) throws TDLibError {
        try {

        var obj = new DeleteStory (
            story_sender_chat_id,
            story_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_story.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of chats with non-default notification settings for
     * stories
     */
    public async Chats get_story_notification_settings_exceptions () throws TDLibError {
        try {

        var obj = new GetStoryNotificationSettingsExceptions ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_story_notification_settings_exceptions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chats) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Loads more active stories from a story list. The loaded stories will
     * be sent through updates. Active stories are sorted by
     * the pair (active_stories.order, active_stories.story_sender_chat_id)
     * in descending order. Returns a 404 error if all active stories have
     * been loaded
     * @param story_list The story list in which to load active stories
     */
    public async Ok load_active_stories (
        StoryList story_list
    ) throws TDLibError {
        try {

        var obj = new LoadActiveStories (
            story_list
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (load_active_stories.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes story list in which stories from the chat are shown
     * @param chat_id Identifier of the chat that posted stories
     * @param story_list New list for active stories posted by the chat
     */
    public async Ok set_chat_active_stories_list (
        int64 chat_id,
        StoryList story_list
    ) throws TDLibError {
        try {

        var obj = new SetChatActiveStoriesList (
            chat_id,
            story_list
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_active_stories_list.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of active stories posted by the given chat
     * @param chat_id Chat identifier
     */
    public async ChatActiveStories get_chat_active_stories (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetChatActiveStories (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_active_stories.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatActiveStories) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of stories that posted by the given chat to its chat
     * page. If from_story_id == 0, then pinned stories are returned first.
     * Then, stories are returned in reverse chronological order (i.e., in
     * order of decreasing story_id). For optimal performance, the number of
     * returned stories is chosen by TDLib
     * @param chat_id Chat identifier
     * @param from_story_id Identifier of the story starting from which
     * stories must be returned; use 0 to get results from pinned and the
     * newest story
     * @param limit The maximum number of stories to be returned. For optimal
     * performance, the number of returned stories is chosen by TDLib and can
     * be smaller than the specified limit
     */
    public async Stories get_chat_posted_to_chat_page_stories (
        int64 chat_id,
        int32 from_story_id,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetChatPostedToChatPageStories (
            chat_id,
            from_story_id,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_posted_to_chat_page_stories.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Stories) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of all stories posted by the given chat; requires
     * can_edit_stories right in the chat.
     * The stories are returned in reverse chronological order (i.e., in
     * order of decreasing story_id). For optimal performance, the number of
     * returned stories is chosen by TDLib
     * @param chat_id Chat identifier
     * @param from_story_id Identifier of the story starting from which
     * stories must be returned; use 0 to get results from the last story
     * @param limit The maximum number of stories to be returned. For optimal
     * performance, the number of returned stories is chosen by TDLib and can
     * be smaller than the specified limit
     */
    public async Stories get_chat_archived_stories (
        int64 chat_id,
        int32 from_story_id,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetChatArchivedStories (
            chat_id,
            from_story_id,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_archived_stories.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Stories) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the list of pinned stories on a chat page; requires
     * can_edit_stories right in the chat
     * @param chat_id Identifier of the chat that posted the stories
     * @param story_ids New list of pinned stories. All stories must be
     * posted to the chat page first. There can be up to
     * getOption("pinned_story_count_max") pinned stories on a chat page
     */
    public async Ok set_chat_pinned_stories (
        int64 chat_id,
        Gee.ArrayList<int32?> story_ids
    ) throws TDLibError {
        try {

        var obj = new SetChatPinnedStories (
            chat_id,
            story_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_pinned_stories.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs TDLib that a story is opened and is being viewed by the user
     * @param story_sender_chat_id The identifier of the sender of the opened
     * story
     * @param story_id The identifier of the story
     */
    public async Ok open_story (
        int64 story_sender_chat_id,
        int32 story_id
    ) throws TDLibError {
        try {

        var obj = new OpenStory (
            story_sender_chat_id,
            story_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (open_story.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs TDLib that a story is closed by the user
     * @param story_sender_chat_id The identifier of the sender of the story
     * to {@link Client.close}
     * @param story_id The identifier of the story
     */
    public async Ok close_story (
        int64 story_sender_chat_id,
        int32 story_id
    ) throws TDLibError {
        try {

        var obj = new CloseStory (
            story_sender_chat_id,
            story_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (close_story.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns reactions, which can be chosen for a story
     * @param row_size Number of reaction per row, 5-25
     */
    public async AvailableReactions get_story_available_reactions (
        int32 row_size
    ) throws TDLibError {
        try {

        var obj = new GetStoryAvailableReactions (
            row_size
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_story_available_reactions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (AvailableReactions) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes chosen reaction on a story that has already been sent
     * @param story_sender_chat_id The identifier of the sender of the story
     * @param story_id The identifier of the story
     * @param reaction_type Type of the reaction to set; pass null to remove
     * the reaction. Custom emoji reactions can be used only by Telegram
     * Premium users. Paid reactions can't be set
     * @param update_recent_reactions Pass true if the reaction needs to be
     * added to recent reactions
     */
    public async Ok set_story_reaction (
        int64 story_sender_chat_id,
        int32 story_id,
        ReactionType reaction_type,
        bool update_recent_reactions
    ) throws TDLibError {
        try {

        var obj = new SetStoryReaction (
            story_sender_chat_id,
            story_id,
            reaction_type,
            update_recent_reactions
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_story_reaction.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns interactions with a story. The method can be called only for
     * stories posted on behalf of the current user
     * @param story_id Story identifier
     * @param query Query to search for in names, usernames and titles; may
     * be empty to get all relevant interactions
     * @param only_contacts Pass true to get only interactions by contacts;
     * pass false to get all relevant interactions
     * @param prefer_forwards Pass true to get forwards and reposts first,
     * then reactions, then other views; pass false to get interactions
     * sorted just by interaction date
     * @param prefer_with_reaction Pass true to get interactions with
     * reaction first; pass false to get interactions sorted just by
     * interaction date. Ignored if prefer_forwards == true
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of story interactions to return
     */
    public async StoryInteractions get_story_interactions (
        int32 story_id,
        string query,
        bool only_contacts,
        bool prefer_forwards,
        bool prefer_with_reaction,
        string offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetStoryInteractions (
            story_id,
            query,
            only_contacts,
            prefer_forwards,
            prefer_with_reaction,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_story_interactions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StoryInteractions) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns interactions with a story posted in a chat. Can be used only
     * if story is posted on behalf of a chat and the user is an
     * administrator in the chat
     * @param story_sender_chat_id The identifier of the sender of the story
     * @param story_id Story identifier
     * @param reaction_type Pass the default heart reaction or a suggested
     * reaction type to receive only interactions with the specified reaction
     * type; pass null to receive all interactions; reactionTypePaid isn't
     * supported
     * @param prefer_forwards Pass true to get forwards and reposts first,
     * then reactions, then other views; pass false to get interactions
     * sorted just by interaction date
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of story interactions to return
     */
    public async StoryInteractions get_chat_story_interactions (
        int64 story_sender_chat_id,
        int32 story_id,
        ReactionType reaction_type,
        bool prefer_forwards,
        string offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetChatStoryInteractions (
            story_sender_chat_id,
            story_id,
            reaction_type,
            prefer_forwards,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_story_interactions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StoryInteractions) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Reports a story to the Telegram moderators
     * @param story_sender_chat_id The identifier of the sender of the story
     * to report
     * @param story_id The identifier of the story to report
     * @param option_id Option identifier chosen by the user; leave empty for
     * the initial request
     * @param text Additional report details; 0-1024 characters; leave empty
     * for the initial request
     */
    public async ReportStoryResult report_story (
        int64 story_sender_chat_id,
        int32 story_id,
        Bytes option_id,
        string text
    ) throws TDLibError {
        try {

        var obj = new ReportStory (
            story_sender_chat_id,
            story_id,
            option_id,
            text
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_story.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ReportStoryResult) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Activates stealth mode for stories, which hides all views of stories
     * from the current user in the last "story_stealth_mode_past_period"
     * seconds
     * and for the next "story_stealth_mode_future_period" seconds; for
     * Telegram Premium users only
     */
    public async Ok activate_story_stealth_mode () throws TDLibError {
        try {

        var obj = new ActivateStoryStealthMode ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (activate_story_stealth_mode.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns forwards of a story as a message to public chats and reposts
     * by public channels. Can be used only if the story is posted on behalf
     * of the current user or story.can_get_statistics == true.
     * For optimal performance, the number of returned messages and stories
     * is chosen by TDLib
     * @param story_sender_chat_id The identifier of the sender of the story
     * @param story_id The identifier of the story
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of messages and stories to be
     * returned; must be positive and can't be greater than 100. For optimal
     * performance, the number of returned objects is chosen by TDLib and can
     * be smaller than the specified limit
     */
    public async PublicForwards get_story_public_forwards (
        int64 story_sender_chat_id,
        int32 story_id,
        string offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetStoryPublicForwards (
            story_sender_chat_id,
            story_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_story_public_forwards.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PublicForwards) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of features available on the specific chat boost
     * level; this is an offline request
     * @param is_channel Pass true to get the list of features for channels;
     * pass false to get the list of features for supergroups
     * @param level Chat boost level
     */
    public async ChatBoostLevelFeatures get_chat_boost_level_features (
        bool is_channel,
        int32 level
    ) throws TDLibError {
        try {

        var obj = new GetChatBoostLevelFeatures (
            is_channel,
            level
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_boost_level_features.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatBoostLevelFeatures) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of features available for different chat boost
     * levels; this is an offline request
     * @param is_channel Pass true to get the list of features for channels;
     * pass false to get the list of features for supergroups
     */
    public async ChatBoostFeatures get_chat_boost_features (
        bool is_channel
    ) throws TDLibError {
        try {

        var obj = new GetChatBoostFeatures (
            is_channel
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_boost_features.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatBoostFeatures) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of available chat boost slots for the current user
     */
    public async ChatBoostSlots get_available_chat_boost_slots () throws TDLibError {
        try {

        var obj = new GetAvailableChatBoostSlots ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_available_chat_boost_slots.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatBoostSlots) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the current boost status for a supergroup or a channel chat
     * @param chat_id Identifier of the chat
     */
    public async ChatBoostStatus get_chat_boost_status (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetChatBoostStatus (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_boost_status.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatBoostStatus) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Boosts a chat and returns the list of available chat boost slots for
     * the current user after the boost
     * @param chat_id Identifier of the chat
     * @param slot_ids Identifiers of boost slots of the current user from
     * which to apply boosts to the chat
     */
    public async ChatBoostSlots boost_chat (
        int64 chat_id,
        Gee.ArrayList<int32?> slot_ids
    ) throws TDLibError {
        try {

        var obj = new BoostChat (
            chat_id,
            slot_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (boost_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatBoostSlots) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an HTTPS link to boost the specified supergroup or channel
     * chat
     * @param chat_id Identifier of the chat
     */
    public async ChatBoostLink get_chat_boost_link (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetChatBoostLink (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_boost_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatBoostLink) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a link to boost a chat. Can be called for
     * any internal link of the type internalLinkTypeChatBoost
     * @param url The link to boost a chat
     */
    public async ChatBoostLinkInfo get_chat_boost_link_info (
        string url
    ) throws TDLibError {
        try {

        var obj = new GetChatBoostLinkInfo (
            url
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_boost_link_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatBoostLinkInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of boosts applied to a chat; requires administrator
     * rights in the chat
     * @param chat_id Identifier of the chat
     * @param only_gift_codes Pass true to receive only boosts received from
     * gift codes and giveaways created by the chat
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of boosts to be returned; up to 100.
     * For optimal performance, the number of returned boosts can be smaller
     * than the specified limit
     */
    public async FoundChatBoosts get_chat_boosts (
        int64 chat_id,
        bool only_gift_codes,
        string offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetChatBoosts (
            chat_id,
            only_gift_codes,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_boosts.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundChatBoosts) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of boosts applied to a chat by a given user; requires
     * administrator rights in the chat; for bots only
     * @param chat_id Identifier of the chat
     * @param user_id Identifier of the user
     */
    public async FoundChatBoosts get_user_chat_boosts (
        int64 chat_id,
        int64 user_id
    ) throws TDLibError {
        try {

        var obj = new GetUserChatBoosts (
            chat_id,
            user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_user_chat_boosts.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundChatBoosts) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a bot that can be added to attachment or
     * side menu
     * @param bot_user_id Bot's user identifier
     */
    public async AttachmentMenuBot get_attachment_menu_bot (
        int64 bot_user_id
    ) throws TDLibError {
        try {

        var obj = new GetAttachmentMenuBot (
            bot_user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_attachment_menu_bot.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (AttachmentMenuBot) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds or removes a bot to attachment and side menu. Bot can be added to
     * the menu, only if userTypeBot.can_be_added_to_attachment_menu == true
     * @param bot_user_id Bot's user identifier
     * @param is_added Pass true to add the bot to attachment menu; pass
     * false to remove the bot from attachment menu
     * @param allow_write_access Pass true if the current user allowed the
     * bot to send them messages. Ignored if is_added is false
     */
    public async Ok toggle_bot_is_added_to_attachment_menu (
        int64 bot_user_id,
        bool is_added,
        bool allow_write_access
    ) throws TDLibError {
        try {

        var obj = new ToggleBotIsAddedToAttachmentMenu (
            bot_user_id,
            is_added,
            allow_write_access
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_bot_is_added_to_attachment_menu.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns up to 8 emoji statuses, which must be shown right after the
     * default Premium Badge in the emoji status list for self status
     */
    public async EmojiStatusCustomEmojis get_themed_emoji_statuses () throws TDLibError {
        try {

        var obj = new GetThemedEmojiStatuses ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_themed_emoji_statuses.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (EmojiStatusCustomEmojis) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns recent emoji statuses for self status
     */
    public async EmojiStatuses get_recent_emoji_statuses () throws TDLibError {
        try {

        var obj = new GetRecentEmojiStatuses ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_recent_emoji_statuses.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (EmojiStatuses) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns available upgraded gift emoji statuses for self status
     */
    public async EmojiStatuses get_upgraded_gift_emoji_statuses () throws TDLibError {
        try {

        var obj = new GetUpgradedGiftEmojiStatuses ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_upgraded_gift_emoji_statuses.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (EmojiStatuses) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns default emoji statuses for self status
     */
    public async EmojiStatusCustomEmojis get_default_emoji_statuses () throws TDLibError {
        try {

        var obj = new GetDefaultEmojiStatuses ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_default_emoji_statuses.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (EmojiStatusCustomEmojis) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Clears the list of recently used emoji statuses for self status
     */
    public async Ok clear_recent_emoji_statuses () throws TDLibError {
        try {

        var obj = new ClearRecentEmojiStatuses ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clear_recent_emoji_statuses.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns up to 8 emoji statuses, which must be shown in the emoji
     * status list for chats
     */
    public async EmojiStatusCustomEmojis get_themed_chat_emoji_statuses () throws TDLibError {
        try {

        var obj = new GetThemedChatEmojiStatuses ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_themed_chat_emoji_statuses.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (EmojiStatusCustomEmojis) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns default emoji statuses for chats
     */
    public async EmojiStatusCustomEmojis get_default_chat_emoji_statuses () throws TDLibError {
        try {

        var obj = new GetDefaultChatEmojiStatuses ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_default_chat_emoji_statuses.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (EmojiStatusCustomEmojis) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of emoji statuses, which can't be used as chat emoji
     * status, even they are from a sticker set with
     * is_allowed_as_chat_emoji_status == true
     */
    public async EmojiStatusCustomEmojis get_disallowed_chat_emoji_statuses () throws TDLibError {
        try {

        var obj = new GetDisallowedChatEmojiStatuses ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_disallowed_chat_emoji_statuses.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (EmojiStatusCustomEmojis) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Downloads a file from the cloud. Download progress and completion of
     * the download will be notified through updateFile updates
     * @param file_id Identifier of the file to download
     * @param priority Priority of the download (1-32). The higher the
     * priority, the earlier the file will be downloaded. If the priorities
     * of two files are equal, then the last one for which
     * downloadFile/addFileToDownloads was called will be downloaded first
     * @param offset The starting position from which the file needs to be
     * downloaded
     * @param limit Number of bytes which need to be downloaded starting from
     * the "offset" position before the download will automatically be
     * canceled; use 0 to download without a limit
     * @param synchronous Pass true to return response only after the file
     * download has succeeded, has failed, has been canceled, or a new
     * {@link Client.download_file} request with different offset/limit
     * parameters was sent; pass false to return file state immediately, just
     * after the download has been started
     */
    public async File download_file (
        int32 file_id,
        int32 priority,
        int64 offset,
        int64 limit,
        bool synchronous
    ) throws TDLibError {
        try {

        var obj = new DownloadFile (
            file_id,
            priority,
            offset,
            limit,
            synchronous
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (download_file.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (File) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns file downloaded prefix size from a given offset, in bytes
     * @param file_id Identifier of the file
     * @param offset Offset from which downloaded prefix size needs to be
     * calculated
     */
    public async FileDownloadedPrefixSize get_file_downloaded_prefix_size (
        int32 file_id,
        int64 offset
    ) throws TDLibError {
        try {

        var obj = new GetFileDownloadedPrefixSize (
            file_id,
            offset
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_file_downloaded_prefix_size.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FileDownloadedPrefixSize) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Stops the downloading of a file. If a file has already been
     * downloaded, does nothing
     * @param file_id Identifier of a file to stop downloading
     * @param only_if_pending Pass true to stop downloading only if it hasn't
     * been started, i.e. request hasn't been sent to server
     */
    public async Ok cancel_download_file (
        int32 file_id,
        bool only_if_pending
    ) throws TDLibError {
        try {

        var obj = new CancelDownloadFile (
            file_id,
            only_if_pending
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (cancel_download_file.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns suggested name for saving a file in a given directory
     * @param file_id Identifier of the file
     * @param directory Directory in which the file is expected to be saved
     */
    public async Text get_suggested_file_name (
        int32 file_id,
        string directory
    ) throws TDLibError {
        try {

        var obj = new GetSuggestedFileName (
            file_id,
            directory
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_suggested_file_name.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Preliminary uploads a file to the cloud before sending it in a
     * message, which can be useful for uploading of being recorded voice and
     * video notes.
     * In all other cases there is no need to preliminary upload a file.
     * Updates updateFile will be used to notify about upload progress.
     * The upload will not be completed until the file is sent in a message
     * @param file File to upload
     * @param file_type File type; pass null if unknown
     * @param priority Priority of the upload (1-32). The higher the
     * priority, the earlier the file will be uploaded. If the priorities of
     * two files are equal, then the first one for which
     * {@link Client.preliminary_upload_file} was called will be uploaded
     * first
     */
    public async File preliminary_upload_file (
        InputFile file,
        FileType file_type,
        int32 priority
    ) throws TDLibError {
        try {

        var obj = new PreliminaryUploadFile (
            file,
            file_type,
            priority
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (preliminary_upload_file.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (File) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Stops the preliminary uploading of a file. Supported only for files
     * uploaded by using {@link Client.preliminary_upload_file}
     * @param file_id Identifier of the file to stop uploading
     */
    public async Ok cancel_preliminary_upload_file (
        int32 file_id
    ) throws TDLibError {
        try {

        var obj = new CancelPreliminaryUploadFile (
            file_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (cancel_preliminary_upload_file.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Writes a part of a generated file. This method is intended to be used
     * only if the application has no direct access to TDLib's file system,
     * because it is usually slower than a direct write to the destination
     * file
     * @param generation_id The identifier of the generation process
     * @param offset The offset from which to write the data to the file
     * @param data The data to write
     */
    public async Ok write_generated_file_part (
        int64 generation_id,
        int64 offset,
        Bytes data
    ) throws TDLibError {
        try {

        var obj = new WriteGeneratedFilePart (
            generation_id,
            offset,
            data
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (write_generated_file_part.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs TDLib on a file generation progress
     * @param generation_id The identifier of the generation process
     * @param expected_size Expected size of the generated file, in bytes; 0
     * if unknown
     * @param local_prefix_size The number of bytes already generated
     */
    public async Ok set_file_generation_progress (
        int64 generation_id,
        int64 expected_size,
        int64 local_prefix_size
    ) throws TDLibError {
        try {

        var obj = new SetFileGenerationProgress (
            generation_id,
            expected_size,
            local_prefix_size
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_file_generation_progress.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Finishes the file generation
     * @param generation_id The identifier of the generation process
     * @param error If passed, the file generation has failed and must be
     * terminated; pass null if the file generation succeeded
     */
    public async Ok finish_file_generation (
        int64 generation_id,
        Error error
    ) throws TDLibError {
        try {

        var obj = new FinishFileGeneration (
            generation_id,
            error
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (finish_file_generation.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Reads a part of a file from the TDLib file cache and returns read
     * bytes. This method is intended to be used only if the application has
     * no direct access to TDLib's file system, because it is usually slower
     * than a direct read from the file
     * @param file_id Identifier of the file. The file must be located in the
     * TDLib file cache
     * @param offset The offset from which to read the file
     * @param count Number of bytes to read. An error will be returned if
     * there are not enough bytes available in the file from the specified
     * position. Pass 0 to read all available data from the specified
     * position
     */
    public async FilePart read_file_part (
        int32 file_id,
        int64 offset,
        int64 count
    ) throws TDLibError {
        try {

        var obj = new ReadFilePart (
            file_id,
            offset,
            count
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (read_file_part.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FilePart) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes a file from the TDLib file cache
     * @param file_id Identifier of the file to delete
     */
    public async Ok delete_file (
        int32 file_id
    ) throws TDLibError {
        try {

        var obj = new DeleteFile (
            file_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_file.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a file from a message to the list of file downloads. Download
     * progress and completion of the download will be notified through
     * updateFile updates.
     * If message database is used, the list of file downloads is persistent
     * across application restarts. The downloading is independent of
     * download using {@link Client.download_file} i.e. it continues if
     * {@link Client.download_file} is canceled or is used to download a part
     * of the file
     * @param file_id Identifier of the file to download
     * @param chat_id Chat identifier of the message with the file
     * @param message_id Message identifier
     * @param priority Priority of the download (1-32). The higher the
     * priority, the earlier the file will be downloaded. If the priorities
     * of two files are equal, then the last one for which
     * downloadFile/addFileToDownloads was called will be downloaded first
     */
    public async File add_file_to_downloads (
        int32 file_id,
        int64 chat_id,
        int64 message_id,
        int32 priority
    ) throws TDLibError {
        try {

        var obj = new AddFileToDownloads (
            file_id,
            chat_id,
            message_id,
            priority
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_file_to_downloads.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (File) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes pause state of a file in the file download list
     * @param file_id Identifier of the downloaded file
     * @param is_paused Pass true if the download is paused
     */
    public async Ok toggle_download_is_paused (
        int32 file_id,
        bool is_paused
    ) throws TDLibError {
        try {

        var obj = new ToggleDownloadIsPaused (
            file_id,
            is_paused
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_download_is_paused.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes pause state of all files in the file download list
     * @param are_paused Pass true to pause all downloads; pass false to
     * unpause them
     */
    public async Ok toggle_all_downloads_are_paused (
        bool are_paused
    ) throws TDLibError {
        try {

        var obj = new ToggleAllDownloadsArePaused (
            are_paused
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_all_downloads_are_paused.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes a file from the file download list
     * @param file_id Identifier of the downloaded file
     * @param delete_from_cache Pass true to delete the file from the TDLib
     * file cache
     */
    public async Ok remove_file_from_downloads (
        int32 file_id,
        bool delete_from_cache
    ) throws TDLibError {
        try {

        var obj = new RemoveFileFromDownloads (
            file_id,
            delete_from_cache
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_file_from_downloads.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes all files from the file download list
     * @param only_active Pass true to remove only active downloads,
     * including paused
     * @param only_completed Pass true to remove only completed downloads
     * @param delete_from_cache Pass true to delete the file from the TDLib
     * file cache
     */
    public async Ok remove_all_files_from_downloads (
        bool only_active,
        bool only_completed,
        bool delete_from_cache
    ) throws TDLibError {
        try {

        var obj = new RemoveAllFilesFromDownloads (
            only_active,
            only_completed,
            delete_from_cache
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_all_files_from_downloads.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for files in the file download list or recently downloaded
     * files from the list
     * @param query Query to search for; may be empty to return all
     * downloaded files
     * @param only_active Pass true to search only for active downloads,
     * including paused
     * @param only_completed Pass true to search only for completed downloads
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of files to be returned
     */
    public async FoundFileDownloads search_file_downloads (
        string query,
        bool only_active,
        bool only_completed,
        string offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new SearchFileDownloads (
            query,
            only_active,
            only_completed,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_file_downloads.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundFileDownloads) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Application or reCAPTCHA verification has been completed. Can be
     * called before authorization
     * @param verification_id Unique identifier for the verification process
     * as received from updateApplicationVerificationRequired or
     * updateApplicationRecaptchaVerificationRequired
     * @param token Play Integrity API token for the Android application, or
     * secret from push notification for the iOS application for application
     * verification, or reCAPTCHA token for reCAPTCHA verifications; pass an
     * empty string to abort verification and receive error
     * VERIFICATION_FAILED for the request
     */
    public async Ok set_application_verification_token (
        int64 verification_id,
        string token
    ) throws TDLibError {
        try {

        var obj = new SetApplicationVerificationToken (
            verification_id,
            token
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_application_verification_token.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a file with messages exported from another
     * application
     * @param message_file_head Beginning of the message file; up to 100
     * first lines
     */
    public async MessageFileType get_message_file_type (
        string message_file_head
    ) throws TDLibError {
        try {

        var obj = new GetMessageFileType (
            message_file_head
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_file_type.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MessageFileType) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a confirmation text to be shown to the user before starting
     * message import
     * @param chat_id Identifier of a chat to which the messages will be
     * imported. It must be an identifier of a private chat with a mutual
     * contact or an identifier of a supergroup chat with can_change_info
     * member right
     */
    public async Text get_message_import_confirmation_text (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetMessageImportConfirmationText (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_import_confirmation_text.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Imports messages exported from another app
     * @param chat_id Identifier of a chat to which the messages will be
     * imported. It must be an identifier of a private chat with a mutual
     * contact or an identifier of a supergroup chat with can_change_info
     * member right
     * @param message_file File with messages to import. Only inputFileLocal
     * and inputFileGenerated are supported. The file must not be previously
     * uploaded
     * @param attached_files Files used in the imported messages. Only
     * inputFileLocal and inputFileGenerated are supported. The files must
     * not be previously uploaded
     */
    public async Ok import_messages (
        int64 chat_id,
        InputFile message_file,
        Gee.ArrayList<InputFile?> attached_files
    ) throws TDLibError {
        try {

        var obj = new ImportMessages (
            chat_id,
            message_file,
            attached_files
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (import_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Replaces current primary invite link for a chat with a new primary
     * invite link. Available for basic groups, supergroups, and channels.
     * Requires administrator privileges and can_invite_users right
     * @param chat_id Chat identifier
     */
    public async ChatInviteLink replace_primary_chat_invite_link (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new ReplacePrimaryChatInviteLink (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (replace_primary_chat_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatInviteLink) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Creates a new invite link for a chat. Available for basic groups,
     * supergroups, and channels. Requires administrator privileges and
     * can_invite_users right in the chat
     * @param chat_id Chat identifier
     * @param name Invite link name; 0-32 characters
     * @param expiration_date Point in time (Unix timestamp) when the link
     * will expire; pass 0 if never
     * @param member_limit The maximum number of chat members that can join
     * the chat via the link simultaneously; 0-99999; pass 0 if not limited
     * @param creates_join_request Pass true if users joining the chat via
     * the link need to be approved by chat administrators. In this case,
     * member_limit must be 0
     */
    public async ChatInviteLink create_chat_invite_link (
        int64 chat_id,
        string name,
        int32 expiration_date,
        int32 member_limit,
        bool creates_join_request
    ) throws TDLibError {
        try {

        var obj = new CreateChatInviteLink (
            chat_id,
            name,
            expiration_date,
            member_limit,
            creates_join_request
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_chat_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatInviteLink) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Creates a new subscription invite link for a channel chat. Requires
     * can_invite_users right in the chat
     * @param chat_id Chat identifier
     * @param name Invite link name; 0-32 characters
     * @param subscription_pricing Information about subscription plan that
     * will be applied to the users joining the chat via the link.
     * Subscription period must be 2592000 in production environment, and 60
     * or 300 if Telegram test environment is used
     */
    public async ChatInviteLink create_chat_subscription_invite_link (
        int64 chat_id,
        string name,
        StarSubscriptionPricing subscription_pricing
    ) throws TDLibError {
        try {

        var obj = new CreateChatSubscriptionInviteLink (
            chat_id,
            name,
            subscription_pricing
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_chat_subscription_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatInviteLink) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits a non-primary invite link for a chat. Available for basic
     * groups, supergroups, and channels.
     * If the link creates a subscription, then expiration_date, member_limit
     * and creates_join_request must not be used.
     * Requires administrator privileges and can_invite_users right in the
     * chat for own links and owner privileges for other links
     * @param chat_id Chat identifier
     * @param invite_link Invite link to be edited
     * @param name Invite link name; 0-32 characters
     * @param expiration_date Point in time (Unix timestamp) when the link
     * will expire; pass 0 if never
     * @param member_limit The maximum number of chat members that can join
     * the chat via the link simultaneously; 0-99999; pass 0 if not limited
     * @param creates_join_request Pass true if users joining the chat via
     * the link need to be approved by chat administrators. In this case,
     * member_limit must be 0
     */
    public async ChatInviteLink edit_chat_invite_link (
        int64 chat_id,
        string invite_link,
        string name,
        int32 expiration_date,
        int32 member_limit,
        bool creates_join_request
    ) throws TDLibError {
        try {

        var obj = new EditChatInviteLink (
            chat_id,
            invite_link,
            name,
            expiration_date,
            member_limit,
            creates_join_request
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_chat_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatInviteLink) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits a subscription invite link for a channel chat. Requires
     * can_invite_users right in the chat for own links and owner privileges
     * for other links
     * @param chat_id Chat identifier
     * @param invite_link Invite link to be edited
     * @param name Invite link name; 0-32 characters
     */
    public async ChatInviteLink edit_chat_subscription_invite_link (
        int64 chat_id,
        string invite_link,
        string name
    ) throws TDLibError {
        try {

        var obj = new EditChatSubscriptionInviteLink (
            chat_id,
            invite_link,
            name
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_chat_subscription_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatInviteLink) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about an invite link. Requires administrator
     * privileges and can_invite_users right in the chat to get own links and
     * owner privileges to get other links
     * @param chat_id Chat identifier
     * @param invite_link Invite link to get
     */
    public async ChatInviteLink get_chat_invite_link (
        int64 chat_id,
        string invite_link
    ) throws TDLibError {
        try {

        var obj = new GetChatInviteLink (
            chat_id,
            invite_link
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatInviteLink) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of chat administrators with number of their invite
     * links. Requires owner privileges in the chat
     * @param chat_id Chat identifier
     */
    public async ChatInviteLinkCounts get_chat_invite_link_counts (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetChatInviteLinkCounts (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_invite_link_counts.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatInviteLinkCounts) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns invite links for a chat created by specified administrator.
     * Requires administrator privileges and can_invite_users right in the
     * chat to get own links and owner privileges to get other links
     * @param chat_id Chat identifier
     * @param creator_user_id User identifier of a chat administrator. Must
     * be an identifier of the current user for non-owner
     * @param is_revoked Pass true if revoked links needs to be returned
     * instead of active or expired
     * @param offset_date Creation date of an invite link starting after
     * which to return invite links; use 0 to get results from the beginning
     * @param offset_invite_link Invite link starting after which to return
     * invite links; use empty string to get results from the beginning
     * @param limit The maximum number of invite links to return; up to 100
     */
    public async ChatInviteLinks get_chat_invite_links (
        int64 chat_id,
        int64 creator_user_id,
        bool is_revoked,
        int32 offset_date,
        string offset_invite_link,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetChatInviteLinks (
            chat_id,
            creator_user_id,
            is_revoked,
            offset_date,
            offset_invite_link,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_invite_links.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatInviteLinks) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns chat members joined a chat via an invite link. Requires
     * administrator privileges and can_invite_users right in the chat for
     * own links and owner privileges for other links
     * @param chat_id Chat identifier
     * @param invite_link Invite link for which to return chat members
     * @param only_with_expired_subscription Pass true if the link is a
     * subscription link and only members with expired subscription must be
     * returned
     * @param offset_member A chat member from which to return next chat
     * members; pass null to get results from the beginning
     * @param limit The maximum number of chat members to return; up to 100
     */
    public async ChatInviteLinkMembers get_chat_invite_link_members (
        int64 chat_id,
        string invite_link,
        bool only_with_expired_subscription,
        ChatInviteLinkMember offset_member,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetChatInviteLinkMembers (
            chat_id,
            invite_link,
            only_with_expired_subscription,
            offset_member,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_invite_link_members.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatInviteLinkMembers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Revokes invite link for a chat. Available for basic groups,
     * supergroups, and channels. Requires administrator privileges and
     * can_invite_users right in the chat for own links and owner privileges
     * for other links.
     * If a primary link is revoked, then additionally to the revoked link
     * returns new primary link
     * @param chat_id Chat identifier
     * @param invite_link Invite link to be revoked
     */
    public async ChatInviteLinks revoke_chat_invite_link (
        int64 chat_id,
        string invite_link
    ) throws TDLibError {
        try {

        var obj = new RevokeChatInviteLink (
            chat_id,
            invite_link
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (revoke_chat_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatInviteLinks) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes revoked chat invite links. Requires administrator privileges
     * and can_invite_users right in the chat for own links and owner
     * privileges for other links
     * @param chat_id Chat identifier
     * @param invite_link Invite link to revoke
     */
    public async Ok delete_revoked_chat_invite_link (
        int64 chat_id,
        string invite_link
    ) throws TDLibError {
        try {

        var obj = new DeleteRevokedChatInviteLink (
            chat_id,
            invite_link
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_revoked_chat_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes all revoked chat invite links created by a given chat
     * administrator. Requires administrator privileges and can_invite_users
     * right in the chat for own links and owner privileges for other links
     * @param chat_id Chat identifier
     * @param creator_user_id User identifier of a chat administrator, which
     * links will be deleted. Must be an identifier of the current user for
     * non-owner
     */
    public async Ok delete_all_revoked_chat_invite_links (
        int64 chat_id,
        int64 creator_user_id
    ) throws TDLibError {
        try {

        var obj = new DeleteAllRevokedChatInviteLinks (
            chat_id,
            creator_user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_all_revoked_chat_invite_links.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks the validity of an invite link for a chat and returns
     * information about the corresponding chat
     * @param invite_link Invite link to be checked
     */
    public async ChatInviteLinkInfo check_chat_invite_link (
        string invite_link
    ) throws TDLibError {
        try {

        var obj = new CheckChatInviteLink (
            invite_link
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_chat_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatInviteLinkInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Uses an invite link to add the current user to the chat if possible.
     * May return an error with a message "INVITE_REQUEST_SENT" if only a
     * join request was created
     * @param invite_link Invite link to use
     */
    public async Chat join_chat_by_invite_link (
        string invite_link
    ) throws TDLibError {
        try {

        var obj = new JoinChatByInviteLink (
            invite_link
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (join_chat_by_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chat) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns pending join requests in a chat
     * @param chat_id Chat identifier
     * @param invite_link Invite link for which to return join requests. If
     * empty, all join requests will be returned. Requires administrator
     * privileges and can_invite_users right in the chat for own links and
     * owner privileges for other links
     * @param query A query to search for in the first names, last names and
     * usernames of the users to return
     * @param offset_request A chat join request from which to return next
     * requests; pass null to get results from the beginning
     * @param limit The maximum number of requests to join the chat to return
     */
    public async ChatJoinRequests get_chat_join_requests (
        int64 chat_id,
        string invite_link,
        string query,
        ChatJoinRequest offset_request,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetChatJoinRequests (
            chat_id,
            invite_link,
            query,
            offset_request,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_join_requests.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatJoinRequests) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Handles a pending join request in a chat
     * @param chat_id Chat identifier
     * @param user_id Identifier of the user that sent the request
     * @param approve Pass true to approve the request; pass false to decline
     * it
     */
    public async Ok process_chat_join_request (
        int64 chat_id,
        int64 user_id,
        bool approve
    ) throws TDLibError {
        try {

        var obj = new ProcessChatJoinRequest (
            chat_id,
            user_id,
            approve
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (process_chat_join_request.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Handles all pending join requests for a given link in a chat
     * @param chat_id Chat identifier
     * @param invite_link Invite link for which to process join requests. If
     * empty, all join requests will be processed. Requires administrator
     * privileges and can_invite_users right in the chat for own links and
     * owner privileges for other links
     * @param approve Pass true to approve all requests; pass false to
     * decline them
     */
    public async Ok process_chat_join_requests (
        int64 chat_id,
        string invite_link,
        bool approve
    ) throws TDLibError {
        try {

        var obj = new ProcessChatJoinRequests (
            chat_id,
            invite_link,
            approve
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (process_chat_join_requests.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Creates a new call
     * @param user_id Identifier of the user to be called
     * @param protocol The call protocols supported by the application
     * @param is_video Pass true to create a video call
     * @param group_call_id Identifier of the group call to which the user
     * will be added after exchanging private key via the call; pass 0 if
     * none; currently, ignored
     */
    public async CallId create_call (
        int64 user_id,
        CallProtocol protocol,
        bool is_video,
        int32 group_call_id
    ) throws TDLibError {
        try {

        var obj = new CreateCall (
            user_id,
            protocol,
            is_video,
            group_call_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_call.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (CallId) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Accepts an incoming call
     * @param call_id Call identifier
     * @param protocol The call protocols supported by the application
     */
    public async Ok accept_call (
        int32 call_id,
        CallProtocol protocol
    ) throws TDLibError {
        try {

        var obj = new AcceptCall (
            call_id,
            protocol
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (accept_call.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends call signaling data
     * @param call_id Call identifier
     * @param data The data
     */
    public async Ok send_call_signaling_data (
        int32 call_id,
        Bytes data
    ) throws TDLibError {
        try {

        var obj = new SendCallSignalingData (
            call_id,
            data
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_call_signaling_data.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Discards a call
     * @param call_id Call identifier
     * @param is_disconnected Pass true if the user was disconnected
     * @param duration The call duration, in seconds
     * @param is_video Pass true if the call was a video call
     * @param connection_id Identifier of the connection used during the call
     */
    public async Ok discard_call (
        int32 call_id,
        bool is_disconnected,
        int32 duration,
        bool is_video,
        int64 connection_id
    ) throws TDLibError {
        try {

        var obj = new DiscardCall (
            call_id,
            is_disconnected,
            duration,
            is_video,
            connection_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (discard_call.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends a call rating
     * @param call_id Call identifier
     * @param rating Call rating; 1-5
     * @param comment An optional user comment if the rating is less than 5
     * @param problems List of the exact types of problems with the call,
     * specified by the user
     */
    public async Ok send_call_rating (
        int32 call_id,
        int32 rating,
        string comment,
        Gee.ArrayList<CallProblem?> problems
    ) throws TDLibError {
        try {

        var obj = new SendCallRating (
            call_id,
            rating,
            comment,
            problems
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_call_rating.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends debug information for a call to Telegram servers
     * @param call_id Call identifier
     * @param debug_information Debug information in application-specific
     * format
     */
    public async Ok send_call_debug_information (
        int32 call_id,
        string debug_information
    ) throws TDLibError {
        try {

        var obj = new SendCallDebugInformation (
            call_id,
            debug_information
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_call_debug_information.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends log file for a call to Telegram servers
     * @param call_id Call identifier
     * @param log_file Call log file. Only inputFileLocal and
     * inputFileGenerated are supported
     */
    public async Ok send_call_log (
        int32 call_id,
        InputFile log_file
    ) throws TDLibError {
        try {

        var obj = new SendCallLog (
            call_id,
            log_file
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_call_log.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of participant identifiers, on whose behalf a video
     * chat in the chat can be joined
     * @param chat_id Chat identifier
     */
    public async MessageSenders get_video_chat_available_participants (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetVideoChatAvailableParticipants (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_video_chat_available_participants.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MessageSenders) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes default participant identifier, on whose behalf a video chat
     * in the chat will be joined
     * @param chat_id Chat identifier
     * @param default_participant_id Default group call participant
     * identifier to join the video chats
     */
    public async Ok set_video_chat_default_participant (
        int64 chat_id,
        MessageSender default_participant_id
    ) throws TDLibError {
        try {

        var obj = new SetVideoChatDefaultParticipant (
            chat_id,
            default_participant_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_video_chat_default_participant.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Creates a video chat (a group call bound to a chat). Available only
     * for basic groups, supergroups and channels; requires
     * can_manage_video_chats administrator right
     * @param chat_id Identifier of a chat in which the video chat will be
     * created
     * @param title Group call title; if empty, chat title will be used
     * @param start_date Point in time (Unix timestamp) when the group call
     * is expected to be started by an administrator; 0 to start the video
     * chat immediately. The date must be at least 10 seconds and at most 8
     * days in the future
     * @param is_rtmp_stream Pass true to create an RTMP stream instead of an
     * ordinary video chat
     */
    public async GroupCallId create_video_chat (
        int64 chat_id,
        string title,
        int32 start_date,
        bool is_rtmp_stream
    ) throws TDLibError {
        try {

        var obj = new CreateVideoChat (
            chat_id,
            title,
            start_date,
            is_rtmp_stream
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_video_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (GroupCallId) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Creates a group call from a one-to-one call
     * @param call_id Call identifier
     */
    public async Ok create_group_call (
        int32 call_id
    ) throws TDLibError {
        try {

        var obj = new CreateGroupCall (
            call_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_group_call.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns RTMP URL for streaming to the chat; requires
     * can_manage_video_chats administrator right
     * @param chat_id Chat identifier
     */
    public async RtmpUrl get_video_chat_rtmp_url (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetVideoChatRtmpUrl (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_video_chat_rtmp_url.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (RtmpUrl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Replaces the current RTMP URL for streaming to the chat; requires
     * owner privileges
     * @param chat_id Chat identifier
     */
    public async RtmpUrl replace_video_chat_rtmp_url (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new ReplaceVideoChatRtmpUrl (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (replace_video_chat_rtmp_url.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (RtmpUrl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a group call
     * @param group_call_id Group call identifier
     */
    public async GroupCall get_group_call (
        int32 group_call_id
    ) throws TDLibError {
        try {

        var obj = new GetGroupCall (
            group_call_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_group_call.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (GroupCall) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Starts a scheduled group call
     * @param group_call_id Group call identifier
     */
    public async Ok start_scheduled_group_call (
        int32 group_call_id
    ) throws TDLibError {
        try {

        var obj = new StartScheduledGroupCall (
            group_call_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (start_scheduled_group_call.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether the current user will receive a notification when the
     * group call starts; scheduled group calls only
     * @param group_call_id Group call identifier
     * @param enabled_start_notification New value of the
     * enabled_start_notification setting
     */
    public async Ok toggle_group_call_enabled_start_notification (
        int32 group_call_id,
        bool enabled_start_notification
    ) throws TDLibError {
        try {

        var obj = new ToggleGroupCallEnabledStartNotification (
            group_call_id,
            enabled_start_notification
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_group_call_enabled_start_notification.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Joins an active group call. Returns join response payload for tgcalls
     * @param group_call_id Group call identifier
     * @param participant_id Identifier of a group call participant, which
     * will be used to join the call; pass null to join as self; video chats
     * only
     * @param audio_source_id Caller audio channel synchronization source
     * identifier; received from tgcalls
     * @param payload Group call join payload; received from tgcalls
     * @param is_muted Pass true to join the call with muted microphone
     * @param is_my_video_enabled Pass true if the user's video is enabled
     * @param invite_hash If non-empty, invite hash to be used to join the
     * group call without being muted by administrators
     */
    public async Text join_group_call (
        int32 group_call_id,
        MessageSender participant_id,
        int32 audio_source_id,
        string payload,
        bool is_muted,
        bool is_my_video_enabled,
        string invite_hash
    ) throws TDLibError {
        try {

        var obj = new JoinGroupCall (
            group_call_id,
            participant_id,
            audio_source_id,
            payload,
            is_muted,
            is_my_video_enabled,
            invite_hash
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (join_group_call.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Starts screen sharing in a joined group call. Returns join response
     * payload for tgcalls
     * @param group_call_id Group call identifier
     * @param audio_source_id Screen sharing audio channel synchronization
     * source identifier; received from tgcalls
     * @param payload Group call join payload; received from tgcalls
     */
    public async Text start_group_call_screen_sharing (
        int32 group_call_id,
        int32 audio_source_id,
        string payload
    ) throws TDLibError {
        try {

        var obj = new StartGroupCallScreenSharing (
            group_call_id,
            audio_source_id,
            payload
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (start_group_call_screen_sharing.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Pauses or unpauses screen sharing in a joined group call
     * @param group_call_id Group call identifier
     * @param is_paused Pass true to pause screen sharing; pass false to
     * unpause it
     */
    public async Ok toggle_group_call_screen_sharing_is_paused (
        int32 group_call_id,
        bool is_paused
    ) throws TDLibError {
        try {

        var obj = new ToggleGroupCallScreenSharingIsPaused (
            group_call_id,
            is_paused
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_group_call_screen_sharing_is_paused.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Ends screen sharing in a joined group call
     * @param group_call_id Group call identifier
     */
    public async Ok end_group_call_screen_sharing (
        int32 group_call_id
    ) throws TDLibError {
        try {

        var obj = new EndGroupCallScreenSharing (
            group_call_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (end_group_call_screen_sharing.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets group call title. Requires groupCall.can_be_managed group call
     * flag
     * @param group_call_id Group call identifier
     * @param title New group call title; 1-64 characters
     */
    public async Ok set_group_call_title (
        int32 group_call_id,
        string title
    ) throws TDLibError {
        try {

        var obj = new SetGroupCallTitle (
            group_call_id,
            title
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_group_call_title.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether new participants of a group call can be unmuted only
     * by administrators of the group call. Requires
     * groupCall.can_toggle_mute_new_participants group call flag
     * @param group_call_id Group call identifier
     * @param mute_new_participants New value of the mute_new_participants
     * setting
     */
    public async Ok toggle_group_call_mute_new_participants (
        int32 group_call_id,
        bool mute_new_participants
    ) throws TDLibError {
        try {

        var obj = new ToggleGroupCallMuteNewParticipants (
            group_call_id,
            mute_new_participants
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_group_call_mute_new_participants.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Invites users to an active group call. Sends a service message of type
     * messageInviteVideoChatParticipants for video chats
     * @param group_call_id Group call identifier
     * @param user_ids User identifiers. At most 10 users can be invited
     * simultaneously
     */
    public async Ok invite_group_call_participants (
        int32 group_call_id,
        Gee.ArrayList<int64?> user_ids
    ) throws TDLibError {
        try {

        var obj = new InviteGroupCallParticipants (
            group_call_id,
            user_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (invite_group_call_participants.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns invite link to a video chat in a public chat
     * @param group_call_id Group call identifier
     * @param can_self_unmute Pass true if the invite link needs to contain
     * an invite hash, passing which to {@link Client.join_group_call} would
     * allow the invited user to unmute themselves. Requires
     * groupCall.can_be_managed group call flag
     */
    public async HttpUrl get_group_call_invite_link (
        int32 group_call_id,
        bool can_self_unmute
    ) throws TDLibError {
        try {

        var obj = new GetGroupCallInviteLink (
            group_call_id,
            can_self_unmute
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_group_call_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (HttpUrl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Revokes invite link for a group call. Requires
     * groupCall.can_be_managed group call flag
     * @param group_call_id Group call identifier
     */
    public async Ok revoke_group_call_invite_link (
        int32 group_call_id
    ) throws TDLibError {
        try {

        var obj = new RevokeGroupCallInviteLink (
            group_call_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (revoke_group_call_invite_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Starts recording of an active group call. Requires
     * groupCall.can_be_managed group call flag
     * @param group_call_id Group call identifier
     * @param title Group call recording title; 0-64 characters
     * @param record_video Pass true to record a video file instead of an
     * audio file
     * @param use_portrait_orientation Pass true to use portrait orientation
     * for video instead of landscape one
     */
    public async Ok start_group_call_recording (
        int32 group_call_id,
        string title,
        bool record_video,
        bool use_portrait_orientation
    ) throws TDLibError {
        try {

        var obj = new StartGroupCallRecording (
            group_call_id,
            title,
            record_video,
            use_portrait_orientation
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (start_group_call_recording.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Ends recording of an active group call. Requires
     * groupCall.can_be_managed group call flag
     * @param group_call_id Group call identifier
     */
    public async Ok end_group_call_recording (
        int32 group_call_id
    ) throws TDLibError {
        try {

        var obj = new EndGroupCallRecording (
            group_call_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (end_group_call_recording.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether current user's video is paused
     * @param group_call_id Group call identifier
     * @param is_my_video_paused Pass true if the current user's video is
     * paused
     */
    public async Ok toggle_group_call_is_my_video_paused (
        int32 group_call_id,
        bool is_my_video_paused
    ) throws TDLibError {
        try {

        var obj = new ToggleGroupCallIsMyVideoPaused (
            group_call_id,
            is_my_video_paused
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_group_call_is_my_video_paused.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether current user's video is enabled
     * @param group_call_id Group call identifier
     * @param is_my_video_enabled Pass true if the current user's video is
     * enabled
     */
    public async Ok toggle_group_call_is_my_video_enabled (
        int32 group_call_id,
        bool is_my_video_enabled
    ) throws TDLibError {
        try {

        var obj = new ToggleGroupCallIsMyVideoEnabled (
            group_call_id,
            is_my_video_enabled
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_group_call_is_my_video_enabled.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs TDLib that speaking state of a participant of an active group
     * has changed
     * @param group_call_id Group call identifier
     * @param audio_source Group call participant's synchronization audio
     * source identifier, or 0 for the current user
     * @param is_speaking Pass true if the user is speaking
     */
    public async Ok set_group_call_participant_is_speaking (
        int32 group_call_id,
        int32 audio_source,
        bool is_speaking
    ) throws TDLibError {
        try {

        var obj = new SetGroupCallParticipantIsSpeaking (
            group_call_id,
            audio_source,
            is_speaking
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_group_call_participant_is_speaking.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether a participant of an active group call is muted,
     * unmuted, or allowed to unmute themselves
     * @param group_call_id Group call identifier
     * @param participant_id Participant identifier
     * @param is_muted Pass true to mute the user; pass false to unmute them
     */
    public async Ok toggle_group_call_participant_is_muted (
        int32 group_call_id,
        MessageSender participant_id,
        bool is_muted
    ) throws TDLibError {
        try {

        var obj = new ToggleGroupCallParticipantIsMuted (
            group_call_id,
            participant_id,
            is_muted
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_group_call_participant_is_muted.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes volume level of a participant of an active group call. If the
     * current user can manage the group call, then the participant's volume
     * level will be changed for all users with the default volume level
     * @param group_call_id Group call identifier
     * @param participant_id Participant identifier
     * @param volume_level New participant's volume level; 1-20000 in
     * hundreds of percents
     */
    public async Ok set_group_call_participant_volume_level (
        int32 group_call_id,
        MessageSender participant_id,
        int32 volume_level
    ) throws TDLibError {
        try {

        var obj = new SetGroupCallParticipantVolumeLevel (
            group_call_id,
            participant_id,
            volume_level
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_group_call_participant_volume_level.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether a group call participant hand is rased
     * @param group_call_id Group call identifier
     * @param participant_id Participant identifier
     * @param is_hand_raised Pass true if the user's hand needs to be raised.
     * Only self hand can be raised. Requires groupCall.can_be_managed group
     * call flag to lower other's hand
     */
    public async Ok toggle_group_call_participant_is_hand_raised (
        int32 group_call_id,
        MessageSender participant_id,
        bool is_hand_raised
    ) throws TDLibError {
        try {

        var obj = new ToggleGroupCallParticipantIsHandRaised (
            group_call_id,
            participant_id,
            is_hand_raised
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_group_call_participant_is_hand_raised.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Loads more participants of a group call. The loaded participants will
     * be received through updates. Use the field
     * groupCall.loaded_all_participants to check whether all participants
     * have already been loaded
     * @param group_call_id Group call identifier. The group call must be
     * previously received through {@link Client.get_group_call} and must be
     * joined or being joined
     * @param limit The maximum number of participants to load; up to 100
     */
    public async Ok load_group_call_participants (
        int32 group_call_id,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new LoadGroupCallParticipants (
            group_call_id,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (load_group_call_participants.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Leaves a group call
     * @param group_call_id Group call identifier
     */
    public async Ok leave_group_call (
        int32 group_call_id
    ) throws TDLibError {
        try {

        var obj = new LeaveGroupCall (
            group_call_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (leave_group_call.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Ends a group call. Requires groupCall.can_be_managed
     * @param group_call_id Group call identifier
     */
    public async Ok end_group_call (
        int32 group_call_id
    ) throws TDLibError {
        try {

        var obj = new EndGroupCall (
            group_call_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (end_group_call.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about available group call streams
     * @param group_call_id Group call identifier
     */
    public async GroupCallStreams get_group_call_streams (
        int32 group_call_id
    ) throws TDLibError {
        try {

        var obj = new GetGroupCallStreams (
            group_call_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_group_call_streams.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (GroupCallStreams) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a file with a segment of a group call stream in a modified OGG
     * format for audio or MPEG-4 format for video
     * @param group_call_id Group call identifier
     * @param time_offset Point in time when the stream segment begins; Unix
     * timestamp in milliseconds
     * @param scale Segment duration scale; 0-1. Segment's duration is
     * 1000/(2**scale) milliseconds
     * @param channel_id Identifier of an audio/video channel to get as
     * received from tgcalls
     * @param video_quality Video quality as received from tgcalls; pass null
     * to get the worst available quality
     */
    public async FilePart get_group_call_stream_segment (
        int32 group_call_id,
        int64 time_offset,
        int32 scale,
        int32 channel_id,
        GroupCallVideoQuality video_quality
    ) throws TDLibError {
        try {

        var obj = new GetGroupCallStreamSegment (
            group_call_id,
            time_offset,
            scale,
            channel_id,
            video_quality
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_group_call_stream_segment.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FilePart) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the block list of a message sender. Currently, only users and
     * supergroup chats can be blocked
     * @param sender_id Identifier of a message sender to block/unblock
     * @param block_list New block list for the message sender; pass null to
     * unblock the message sender
     */
    public async Ok set_message_sender_block_list (
        MessageSender sender_id,
        BlockList block_list
    ) throws TDLibError {
        try {

        var obj = new SetMessageSenderBlockList (
            sender_id,
            block_list
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_message_sender_block_list.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Blocks an original sender of a message in the Replies chat
     * @param message_id The identifier of an incoming message in the Replies
     * chat
     * @param delete_message Pass true to delete the message
     * @param delete_all_messages Pass true to delete all messages from the
     * same sender
     * @param report_spam Pass true to report the sender to the Telegram
     * moderators
     */
    public async Ok block_message_sender_from_replies (
        int64 message_id,
        bool delete_message,
        bool delete_all_messages,
        bool report_spam
    ) throws TDLibError {
        try {

        var obj = new BlockMessageSenderFromReplies (
            message_id,
            delete_message,
            delete_all_messages,
            report_spam
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (block_message_sender_from_replies.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns users and chats that were blocked by the current user
     * @param block_list Block list from which to return users
     * @param offset Number of users and chats to skip in the result; must be
     * non-negative
     * @param limit The maximum number of users and chats to return; up to
     * 100
     */
    public async MessageSenders get_blocked_message_senders (
        BlockList block_list,
        int32 offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetBlockedMessageSenders (
            block_list,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_blocked_message_senders.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MessageSenders) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a user to the contact list or edits an existing contact by their
     * user identifier
     * @param contact The contact to add or edit; phone number may be empty
     * and needs to be specified only if known, vCard is ignored
     * @param share_phone_number Pass true to share the current user's phone
     * number with the new contact. A corresponding rule to
     * userPrivacySettingShowPhoneNumber will be added if needed. Use the
     * field userFullInfo.need_phone_number_privacy_exception to check
     * whether the current user needs to be asked to share their phone number
     */
    public async Ok add_contact (
        Contact contact,
        bool share_phone_number
    ) throws TDLibError {
        try {

        var obj = new AddContact (
            contact,
            share_phone_number
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_contact.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds new contacts or edits existing contacts by their phone numbers;
     * contacts' user identifiers are ignored
     * @param contacts The list of contacts to import or edit; contacts'
     * vCard are ignored and are not imported
     */
    public async ImportedContacts import_contacts (
        Gee.ArrayList<Contact?> contacts
    ) throws TDLibError {
        try {

        var obj = new ImportContacts (
            contacts
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (import_contacts.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ImportedContacts) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns all contacts of the user
     */
    public async Users get_contacts () throws TDLibError {
        try {

        var obj = new GetContacts ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_contacts.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Users) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for the specified query in the first names, last names and
     * usernames of the known user contacts
     * @param query Query to search for; may be empty to return all contacts
     * @param limit The maximum number of users to be returned
     */
    public async Users search_contacts (
        string query,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new SearchContacts (
            query,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_contacts.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Users) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes users from the contact list
     * @param user_ids Identifiers of users to be deleted
     */
    public async Ok remove_contacts (
        Gee.ArrayList<int64?> user_ids
    ) throws TDLibError {
        try {

        var obj = new RemoveContacts (
            user_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_contacts.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the total number of imported contacts
     */
    public async Count get_imported_contact_count () throws TDLibError {
        try {

        var obj = new GetImportedContactCount ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_imported_contact_count.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Count) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes imported contacts using the list of contacts saved on the
     * device. Imports newly added contacts and, if at least the file
     * database is enabled, deletes recently deleted contacts.
     * Query result depends on the result of the previous query, so only one
     * query is possible at the same time
     * @param contacts The new list of contacts, contact's vCard are ignored
     * and are not imported
     */
    public async ImportedContacts change_imported_contacts (
        Gee.ArrayList<Contact?> contacts
    ) throws TDLibError {
        try {

        var obj = new ChangeImportedContacts (
            contacts
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (change_imported_contacts.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ImportedContacts) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Clears all imported contacts, contact list remains unchanged
     */
    public async Ok clear_imported_contacts () throws TDLibError {
        try {

        var obj = new ClearImportedContacts ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clear_imported_contacts.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the list of {@link Client.close} friends of the current user
     * @param user_ids User identifiers of {@link Client.close} friends; the
     * users must be contacts of the current user
     */
    public async Ok set_close_friends (
        Gee.ArrayList<int64?> user_ids
    ) throws TDLibError {
        try {

        var obj = new SetCloseFriends (
            user_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_close_friends.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns all {@link Client.close} friends of the current user
     */
    public async Users get_close_friends () throws TDLibError {
        try {

        var obj = new GetCloseFriends ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_close_friends.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Users) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes a personal profile photo of a contact user
     * @param user_id User identifier
     * @param photo Profile photo to set; pass null to delete the photo;
     * inputChatPhotoPrevious isn't supported in this function
     */
    public async Ok set_user_personal_profile_photo (
        int64 user_id,
        InputChatPhoto photo
    ) throws TDLibError {
        try {

        var obj = new SetUserPersonalProfilePhoto (
            user_id,
            photo
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_user_personal_profile_photo.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Suggests a profile photo to another regular user with common messages
     * @param user_id User identifier
     * @param photo Profile photo to suggest; inputChatPhotoPrevious isn't
     * supported in this function
     */
    public async Ok suggest_user_profile_photo (
        int64 user_id,
        InputChatPhoto photo
    ) throws TDLibError {
        try {

        var obj = new SuggestUserProfilePhoto (
            user_id,
            photo
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (suggest_user_profile_photo.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether the bot can manage emoji status of the current user
     * @param bot_user_id User identifier of the bot
     * @param can_manage_emoji_status Pass true if the bot is allowed to
     * change emoji status of the user; pass false otherwise
     */
    public async Ok toggle_bot_can_manage_emoji_status (
        int64 bot_user_id,
        bool can_manage_emoji_status
    ) throws TDLibError {
        try {

        var obj = new ToggleBotCanManageEmojiStatus (
            bot_user_id,
            can_manage_emoji_status
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_bot_can_manage_emoji_status.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the emoji status of a user; for bots only
     * @param user_id Identifier of the user
     * @param emoji_status New emoji status; pass null to switch to the
     * default badge
     */
    public async Ok set_user_emoji_status (
        int64 user_id,
        EmojiStatus emoji_status
    ) throws TDLibError {
        try {

        var obj = new SetUserEmojiStatus (
            user_id,
            emoji_status
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_user_emoji_status.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches a user by their phone number. Returns a 404 error if the user
     * can't be found
     * @param phone_number Phone number to search for
     * @param only_local Pass true to get only locally available information
     * without sending network requests
     */
    public async User search_user_by_phone_number (
        string phone_number,
        bool only_local
    ) throws TDLibError {
        try {

        var obj = new SearchUserByPhoneNumber (
            phone_number,
            only_local
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_user_by_phone_number.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (User) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Shares the phone number of the current user with a mutual contact.
     * Supposed to be called when the user clicks on
     * chatActionBarSharePhoneNumber
     * @param user_id Identifier of the user with whom to share the phone
     * number. The user must be a mutual contact
     */
    public async Ok share_phone_number (
        int64 user_id
    ) throws TDLibError {
        try {

        var obj = new SharePhoneNumber (
            user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (share_phone_number.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the profile photos of a user. Personal and public photo aren't
     * returned
     * @param user_id User identifier
     * @param offset The number of photos to skip; must be non-negative
     * @param limit The maximum number of photos to be returned; up to 100
     */
    public async ChatPhotos get_user_profile_photos (
        int64 user_id,
        int32 offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetUserProfilePhotos (
            user_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_user_profile_photos.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatPhotos) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns outline of a sticker; this is an offline request. Returns a
     * 404 error if the outline isn't known
     * @param sticker_file_id File identifier of the sticker
     * @param for_animated_emoji Pass true to get the outline scaled for
     * animated emoji
     * @param for_clicked_animated_emoji_message Pass true to get the outline
     * scaled for clicked animated emoji message
     */
    public async Outline get_sticker_outline (
        int32 sticker_file_id,
        bool for_animated_emoji,
        bool for_clicked_animated_emoji_message
    ) throws TDLibError {
        try {

        var obj = new GetStickerOutline (
            sticker_file_id,
            for_animated_emoji,
            for_clicked_animated_emoji_message
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_sticker_outline.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Outline) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns stickers from the installed sticker sets that correspond to
     * any of the given emoji or can be found by sticker-specific keywords.
     * If the query is non-empty, then favorite, recently used or trending
     * stickers may also be returned
     * @param sticker_type Type of the stickers to return
     * @param query Search query; a space-separated list of emojis or a
     * keyword prefix. If empty, returns all known installed stickers
     * @param limit The maximum number of stickers to be returned
     * @param chat_id Chat identifier for which to return stickers. Available
     * custom emoji stickers may be different for different chats
     */
    public async Stickers get_stickers (
        StickerType sticker_type,
        string query,
        int32 limit,
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetStickers (
            sticker_type,
            query,
            limit,
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_stickers.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Stickers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns unique emoji that correspond to stickers to be found by the
     * getStickers(sticker_type, query, 1000000, chat_id)
     * @param sticker_type Type of the stickers to search for
     * @param query Search query
     * @param chat_id Chat identifier for which to find stickers
     * @param return_only_main_emoji Pass true if only main emoji for each
     * found sticker must be included in the result
     */
    public async Emojis get_all_sticker_emojis (
        StickerType sticker_type,
        string query,
        int64 chat_id,
        bool return_only_main_emoji
    ) throws TDLibError {
        try {

        var obj = new GetAllStickerEmojis (
            sticker_type,
            query,
            chat_id,
            return_only_main_emoji
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_all_sticker_emojis.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Emojis) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for stickers from public sticker sets that correspond to any
     * of the given emoji
     * @param sticker_type Type of the stickers to return
     * @param emojis Space-separated list of emojis to search for
     * @param query Query to search for; may be empty to search for emoji
     * only
     * @param input_language_codes List of possible IETF language tags of the
     * user's input language; may be empty if unknown
     * @param offset The offset from which to return the stickers; must be
     * non-negative
     * @param limit The maximum number of stickers to be returned; 0-100
     */
    public async Stickers search_stickers (
        StickerType sticker_type,
        string emojis,
        string query,
        Gee.ArrayList<string?> input_language_codes,
        int32 offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new SearchStickers (
            sticker_type,
            emojis,
            query,
            input_language_codes,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_stickers.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Stickers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns greeting stickers from regular sticker sets that can be used
     * for the start page of other users
     */
    public async Stickers get_greeting_stickers () throws TDLibError {
        try {

        var obj = new GetGreetingStickers ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_greeting_stickers.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Stickers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns premium stickers from regular sticker sets
     * @param limit The maximum number of stickers to be returned; 0-100
     */
    public async Stickers get_premium_stickers (
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetPremiumStickers (
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_premium_stickers.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Stickers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a list of installed sticker sets
     * @param sticker_type Type of the sticker sets to return
     */
    public async StickerSets get_installed_sticker_sets (
        StickerType sticker_type
    ) throws TDLibError {
        try {

        var obj = new GetInstalledStickerSets (
            sticker_type
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_installed_sticker_sets.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StickerSets) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a list of archived sticker sets
     * @param sticker_type Type of the sticker sets to return
     * @param offset_sticker_set_id Identifier of the sticker set from which
     * to return the result; use 0 to get results from the beginning
     * @param limit The maximum number of sticker sets to return; up to 100
     */
    public async StickerSets get_archived_sticker_sets (
        StickerType sticker_type,
        int64 offset_sticker_set_id,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetArchivedStickerSets (
            sticker_type,
            offset_sticker_set_id,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_archived_sticker_sets.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StickerSets) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a list of trending sticker sets. For optimal performance, the
     * number of returned sticker sets is chosen by TDLib
     * @param sticker_type Type of the sticker sets to return
     * @param offset The offset from which to return the sticker sets; must
     * be non-negative
     * @param limit The maximum number of sticker sets to be returned; up to
     * 100. For optimal performance, the number of returned sticker sets is
     * chosen by TDLib and can be smaller than the specified limit, even if
     * the end of the list has not been reached
     */
    public async TrendingStickerSets get_trending_sticker_sets (
        StickerType sticker_type,
        int32 offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetTrendingStickerSets (
            sticker_type,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_trending_sticker_sets.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (TrendingStickerSets) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a list of sticker sets attached to a file, including regular,
     * mask, and emoji sticker sets. Currently, only animations, photos, and
     * videos can have attached sticker sets
     * @param file_id File identifier
     */
    public async StickerSets get_attached_sticker_sets (
        int32 file_id
    ) throws TDLibError {
        try {

        var obj = new GetAttachedStickerSets (
            file_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_attached_sticker_sets.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StickerSets) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a sticker set by its identifier
     * @param set_id Identifier of the sticker set
     */
    public async StickerSet get_sticker_set (
        int64 set_id
    ) throws TDLibError {
        try {

        var obj = new GetStickerSet (
            set_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_sticker_set.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StickerSet) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns name of a sticker set by its identifier
     * @param set_id Identifier of the sticker set
     */
    public async Text get_sticker_set_name (
        int64 set_id
    ) throws TDLibError {
        try {

        var obj = new GetStickerSetName (
            set_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_sticker_set_name.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for a sticker set by its name
     * @param name Name of the sticker set
     * @param ignore_cache Pass true to ignore local cache of sticker sets
     * and always send a network request
     */
    public async StickerSet search_sticker_set (
        string name,
        bool ignore_cache
    ) throws TDLibError {
        try {

        var obj = new SearchStickerSet (
            name,
            ignore_cache
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_sticker_set.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StickerSet) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for installed sticker sets by looking for specified query in
     * their title and name
     * @param sticker_type Type of the sticker sets to search for
     * @param query Query to search for
     * @param limit The maximum number of sticker sets to return
     */
    public async StickerSets search_installed_sticker_sets (
        StickerType sticker_type,
        string query,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new SearchInstalledStickerSets (
            sticker_type,
            query,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_installed_sticker_sets.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StickerSets) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for sticker sets by looking for specified query in their
     * title and name. Excludes installed sticker sets from the results
     * @param sticker_type Type of the sticker sets to return
     * @param query Query to search for
     */
    public async StickerSets search_sticker_sets (
        StickerType sticker_type,
        string query
    ) throws TDLibError {
        try {

        var obj = new SearchStickerSets (
            sticker_type,
            query
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_sticker_sets.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StickerSets) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Installs/uninstalls or activates/archives a sticker set
     * @param set_id Identifier of the sticker set
     * @param is_installed The new value of is_installed
     * @param is_archived The new value of is_archived. A sticker set can't
     * be installed and archived simultaneously
     */
    public async Ok change_sticker_set (
        int64 set_id,
        bool is_installed,
        bool is_archived
    ) throws TDLibError {
        try {

        var obj = new ChangeStickerSet (
            set_id,
            is_installed,
            is_archived
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (change_sticker_set.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs the server that some trending sticker sets have been viewed by
     * the user
     * @param sticker_set_ids Identifiers of viewed trending sticker sets
     */
    public async Ok view_trending_sticker_sets (
        Gee.ArrayList<int64?> sticker_set_ids
    ) throws TDLibError {
        try {

        var obj = new ViewTrendingStickerSets (
            sticker_set_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (view_trending_sticker_sets.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the order of installed sticker sets
     * @param sticker_type Type of the sticker sets to reorder
     * @param sticker_set_ids Identifiers of installed sticker sets in the
     * new correct order
     */
    public async Ok reorder_installed_sticker_sets (
        StickerType sticker_type,
        Gee.ArrayList<int64?> sticker_set_ids
    ) throws TDLibError {
        try {

        var obj = new ReorderInstalledStickerSets (
            sticker_type,
            sticker_set_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reorder_installed_sticker_sets.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a list of recently used stickers
     * @param is_attached Pass true to return stickers and masks that were
     * recently attached to photos or video files; pass false to return
     * recently sent stickers
     */
    public async Stickers get_recent_stickers (
        bool is_attached
    ) throws TDLibError {
        try {

        var obj = new GetRecentStickers (
            is_attached
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_recent_stickers.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Stickers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Manually adds a new sticker to the list of recently used stickers. The
     * new sticker is added to the top of the list. If the sticker was
     * already in the list, it is removed from the list first.
     * Only stickers belonging to a sticker set or in WEBP or WEBM format can
     * be added to this list. Emoji stickers can't be added to recent
     * stickers
     * @param is_attached Pass true to add the sticker to the list of
     * stickers recently attached to photo or video files; pass false to add
     * the sticker to the list of recently sent stickers
     * @param sticker Sticker file to add
     */
    public async Stickers add_recent_sticker (
        bool is_attached,
        InputFile sticker
    ) throws TDLibError {
        try {

        var obj = new AddRecentSticker (
            is_attached,
            sticker
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_recent_sticker.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Stickers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes a sticker from the list of recently used stickers
     * @param is_attached Pass true to remove the sticker from the list of
     * stickers recently attached to photo or video files; pass false to
     * remove the sticker from the list of recently sent stickers
     * @param sticker Sticker file to delete
     */
    public async Ok remove_recent_sticker (
        bool is_attached,
        InputFile sticker
    ) throws TDLibError {
        try {

        var obj = new RemoveRecentSticker (
            is_attached,
            sticker
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_recent_sticker.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Clears the list of recently used stickers
     * @param is_attached Pass true to clear the list of stickers recently
     * attached to photo or video files; pass false to clear the list of
     * recently sent stickers
     */
    public async Ok clear_recent_stickers (
        bool is_attached
    ) throws TDLibError {
        try {

        var obj = new ClearRecentStickers (
            is_attached
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clear_recent_stickers.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns favorite stickers
     */
    public async Stickers get_favorite_stickers () throws TDLibError {
        try {

        var obj = new GetFavoriteStickers ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_favorite_stickers.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Stickers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a new sticker to the list of favorite stickers. The new sticker
     * is added to the top of the list. If the sticker was already in the
     * list, it is removed from the list first.
     * Only stickers belonging to a sticker set or in WEBP or WEBM format can
     * be added to this list. Emoji stickers can't be added to favorite
     * stickers
     * @param sticker Sticker file to add
     */
    public async Ok add_favorite_sticker (
        InputFile sticker
    ) throws TDLibError {
        try {

        var obj = new AddFavoriteSticker (
            sticker
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_favorite_sticker.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes a sticker from the list of favorite stickers
     * @param sticker Sticker file to delete from the list
     */
    public async Ok remove_favorite_sticker (
        InputFile sticker
    ) throws TDLibError {
        try {

        var obj = new RemoveFavoriteSticker (
            sticker
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_favorite_sticker.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns emoji corresponding to a sticker. The list is only for
     * informational purposes, because a sticker is always sent with a fixed
     * emoji from the corresponding Sticker object
     * @param sticker Sticker file identifier
     */
    public async Emojis get_sticker_emojis (
        InputFile sticker
    ) throws TDLibError {
        try {

        var obj = new GetStickerEmojis (
            sticker
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_sticker_emojis.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Emojis) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for emojis by keywords. Supported only if the file database
     * is enabled. Order of results is unspecified
     * @param text Text to search for
     * @param input_language_codes List of possible IETF language tags of the
     * user's input language; may be empty if unknown
     */
    public async EmojiKeywords search_emojis (
        string text,
        Gee.ArrayList<string?> input_language_codes
    ) throws TDLibError {
        try {

        var obj = new SearchEmojis (
            text,
            input_language_codes
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_emojis.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (EmojiKeywords) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Return emojis matching the keyword. Supported only if the file
     * database is enabled. Order of results is unspecified
     * @param text Text to search for
     * @param input_language_codes List of possible IETF language tags of the
     * user's input language; may be empty if unknown
     */
    public async Emojis get_keyword_emojis (
        string text,
        Gee.ArrayList<string?> input_language_codes
    ) throws TDLibError {
        try {

        var obj = new GetKeywordEmojis (
            text,
            input_language_codes
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_keyword_emojis.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Emojis) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns available emoji categories
     * @param type_ Type of emoji categories to return; pass null to get
     * default emoji categories
     */
    public async EmojiCategories get_emoji_categories (
        EmojiCategoryType type_
    ) throws TDLibError {
        try {

        var obj = new GetEmojiCategories (
            type_
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_emoji_categories.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (EmojiCategories) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an animated emoji corresponding to a given emoji. Returns a
     * 404 error if the emoji has no animated emoji
     * @param emoji The emoji
     */
    public async AnimatedEmoji get_animated_emoji (
        string emoji
    ) throws TDLibError {
        try {

        var obj = new GetAnimatedEmoji (
            emoji
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_animated_emoji.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (AnimatedEmoji) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an HTTP URL which can be used to automatically log in to the
     * translation platform and suggest new emoji replacements. The URL will
     * be valid for 30 seconds after generation
     * @param language_code Language code for which the emoji replacements
     * will be suggested
     */
    public async HttpUrl get_emoji_suggestions_url (
        string language_code
    ) throws TDLibError {
        try {

        var obj = new GetEmojiSuggestionsUrl (
            language_code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_emoji_suggestions_url.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (HttpUrl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of custom emoji stickers by their identifiers.
     * Stickers are returned in arbitrary order. Only found stickers are
     * returned
     * @param custom_emoji_ids Identifiers of custom emoji stickers. At most
     * 200 custom emoji stickers can be received simultaneously
     */
    public async Stickers get_custom_emoji_stickers (
        Gee.ArrayList<int64?> custom_emoji_ids
    ) throws TDLibError {
        try {

        var obj = new GetCustomEmojiStickers (
            custom_emoji_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_custom_emoji_stickers.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Stickers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns default list of custom emoji stickers for placing on a chat
     * photo
     */
    public async Stickers get_default_chat_photo_custom_emoji_stickers () throws TDLibError {
        try {

        var obj = new GetDefaultChatPhotoCustomEmojiStickers ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_default_chat_photo_custom_emoji_stickers.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Stickers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns default list of custom emoji stickers for placing on a profile
     * photo
     */
    public async Stickers get_default_profile_photo_custom_emoji_stickers () throws TDLibError {
        try {

        var obj = new GetDefaultProfilePhotoCustomEmojiStickers ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_default_profile_photo_custom_emoji_stickers.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Stickers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns default list of custom emoji stickers for reply background
     */
    public async Stickers get_default_background_custom_emoji_stickers () throws TDLibError {
        try {

        var obj = new GetDefaultBackgroundCustomEmojiStickers ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_default_background_custom_emoji_stickers.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Stickers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns saved animations
     */
    public async Animations get_saved_animations () throws TDLibError {
        try {

        var obj = new GetSavedAnimations ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_saved_animations.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Animations) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Manually adds a new animation to the list of saved animations. The new
     * animation is added to the beginning of the list. If the animation was
     * already in the list, it is removed first.
     * Only non-secret video animations with MIME type "video/mp4" can be
     * added to the list
     * @param animation The animation file to be added. Only animations known
     * to the server (i.e., successfully sent via a message) can be added to
     * the list
     */
    public async Ok add_saved_animation (
        InputFile animation
    ) throws TDLibError {
        try {

        var obj = new AddSavedAnimation (
            animation
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_saved_animation.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes an animation from the list of saved animations
     * @param animation Animation file to be removed
     */
    public async Ok remove_saved_animation (
        InputFile animation
    ) throws TDLibError {
        try {

        var obj = new RemoveSavedAnimation (
            animation
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_saved_animation.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns up to 20 recently used inline bots in the order of their last
     * usage
     */
    public async Users get_recent_inline_bots () throws TDLibError {
        try {

        var obj = new GetRecentInlineBots ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_recent_inline_bots.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Users) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of bots owned by the current user
     */
    public async Users get_owned_bots () throws TDLibError {
        try {

        var obj = new GetOwnedBots ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_owned_bots.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Users) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for recently used hashtags by their prefix
     * @param prefix Hashtag prefix to search for
     * @param limit The maximum number of hashtags to be returned
     */
    public async Hashtags search_hashtags (
        string prefix,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new SearchHashtags (
            prefix,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_hashtags.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Hashtags) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes a hashtag from the list of recently used hashtags
     * @param hashtag Hashtag to delete
     */
    public async Ok remove_recent_hashtag (
        string hashtag
    ) throws TDLibError {
        try {

        var obj = new RemoveRecentHashtag (
            hashtag
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_recent_hashtag.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a link preview by the text of a message. Do not call this
     * function too often. Returns a 404 error if the text has no link
     * preview
     * @param text Message text with formatting
     * @param link_preview_options Options to be used for generation of the
     * link preview; pass null to use default link preview options
     */
    public async LinkPreview get_link_preview (
        FormattedText text,
        LinkPreviewOptions link_preview_options
    ) throws TDLibError {
        try {

        var obj = new GetLinkPreview (
            text,
            link_preview_options
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_link_preview.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (LinkPreview) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an instant view version of a web page if available. Returns a
     * 404 error if the web page has no instant view page
     * @param url The web page URL
     * @param force_full Pass true to get full instant view for the web page
     */
    public async WebPageInstantView get_web_page_instant_view (
        string url,
        bool force_full
    ) throws TDLibError {
        try {

        var obj = new GetWebPageInstantView (
            url,
            force_full
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_web_page_instant_view.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (WebPageInstantView) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes a profile photo for the current user
     * @param photo Profile photo to set
     * @param is_public Pass true to set a public photo, which will be
     * visible even the main photo is hidden by privacy settings
     */
    public async Ok set_profile_photo (
        InputChatPhoto photo,
        bool is_public
    ) throws TDLibError {
        try {

        var obj = new SetProfilePhoto (
            photo,
            is_public
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_profile_photo.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes a profile photo
     * @param profile_photo_id Identifier of the profile photo to delete
     */
    public async Ok delete_profile_photo (
        int64 profile_photo_id
    ) throws TDLibError {
        try {

        var obj = new DeleteProfilePhoto (
            profile_photo_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_profile_photo.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes accent color and background custom emoji for the current user;
     * for Telegram Premium users only
     * @param accent_color_id Identifier of the accent color to use
     * @param background_custom_emoji_id Identifier of a custom emoji to be
     * shown on the reply header and link preview background; 0 if none
     */
    public async Ok set_accent_color (
        int32 accent_color_id,
        int64 background_custom_emoji_id
    ) throws TDLibError {
        try {

        var obj = new SetAccentColor (
            accent_color_id,
            background_custom_emoji_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_accent_color.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes accent color and background custom emoji for profile of the
     * current user; for Telegram Premium users only
     * @param profile_accent_color_id Identifier of the accent color to use
     * for profile; pass -1 if none
     * @param profile_background_custom_emoji_id Identifier of a custom emoji
     * to be shown on the user's profile photo background; 0 if none
     */
    public async Ok set_profile_accent_color (
        int32 profile_accent_color_id,
        int64 profile_background_custom_emoji_id
    ) throws TDLibError {
        try {

        var obj = new SetProfileAccentColor (
            profile_accent_color_id,
            profile_background_custom_emoji_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_profile_accent_color.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the first and last name of the current user
     * @param first_name The new value of the first name for the current
     * user; 1-64 characters
     * @param last_name The new value of the optional last name for the
     * current user; 0-64 characters
     */
    public async Ok set_name (
        string first_name,
        string last_name
    ) throws TDLibError {
        try {

        var obj = new SetName (
            first_name,
            last_name
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_name.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the bio of the current user
     * @param bio The new value of the user bio;
     * 0-getOption("bio_length_max") characters without line feeds
     */
    public async Ok set_bio (
        string bio
    ) throws TDLibError {
        try {

        var obj = new SetBio (
            bio
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_bio.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the editable username of the current user
     * @param username The new value of the username. Use an empty string to
     * remove the username. The username can't be completely removed if there
     * is another active or disabled username
     */
    public async Ok set_username (
        string username
    ) throws TDLibError {
        try {

        var obj = new SetUsername (
            username
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_username.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes active state for a username of the current user. The editable
     * username can't be disabled. May return an error with a message
     * "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames
     * has been reached
     * @param username The username to change
     * @param is_active Pass true to activate the username; pass false to
     * disable it
     */
    public async Ok toggle_username_is_active (
        string username,
        bool is_active
    ) throws TDLibError {
        try {

        var obj = new ToggleUsernameIsActive (
            username,
            is_active
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_username_is_active.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes order of active usernames of the current user
     * @param usernames The new order of active usernames. All currently
     * active usernames must be specified
     */
    public async Ok reorder_active_usernames (
        Gee.ArrayList<string?> usernames
    ) throws TDLibError {
        try {

        var obj = new ReorderActiveUsernames (
            usernames
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reorder_active_usernames.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the birthdate of the current user
     * @param birthdate The new value of the current user's birthdate; pass
     * null to remove the birthdate
     */
    public async Ok set_birthdate (
        Birthdate birthdate
    ) throws TDLibError {
        try {

        var obj = new SetBirthdate (
            birthdate
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_birthdate.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the personal chat of the current user
     * @param chat_id Identifier of the new personal chat; pass 0 to remove
     * the chat. Use {@link Client.get_suitable_personal_chats} to get
     * suitable chats
     */
    public async Ok set_personal_chat (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new SetPersonalChat (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_personal_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the emoji status of the current user; for Telegram Premium
     * users only
     * @param emoji_status New emoji status; pass null to switch to the
     * default badge
     */
    public async Ok set_emoji_status (
        EmojiStatus emoji_status
    ) throws TDLibError {
        try {

        var obj = new SetEmojiStatus (
            emoji_status
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_emoji_status.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether the current user has sponsored messages enabled. The
     * setting has no effect for users without Telegram Premium for which
     * sponsored messages are always enabled
     * @param has_sponsored_messages_enabled Pass true to enable sponsored
     * messages for the current user; false to disable them
     */
    public async Ok toggle_has_sponsored_messages_enabled (
        bool has_sponsored_messages_enabled
    ) throws TDLibError {
        try {

        var obj = new ToggleHasSponsoredMessagesEnabled (
            has_sponsored_messages_enabled
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_has_sponsored_messages_enabled.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the business location of the current user. Requires Telegram
     * Business subscription
     * @param location The new location of the business; pass null to remove
     * the location
     */
    public async Ok set_business_location (
        BusinessLocation location
    ) throws TDLibError {
        try {

        var obj = new SetBusinessLocation (
            location
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_business_location.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the business opening hours of the current user. Requires
     * Telegram Business subscription
     * @param opening_hours The new opening hours of the business; pass null
     * to remove the opening hours; up to 28 time intervals can be specified
     */
    public async Ok set_business_opening_hours (
        BusinessOpeningHours opening_hours
    ) throws TDLibError {
        try {

        var obj = new SetBusinessOpeningHours (
            opening_hours
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_business_opening_hours.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the business greeting message settings of the current user.
     * Requires Telegram Business subscription
     * @param greeting_message_settings The new settings for the greeting
     * message of the business; pass null to disable the greeting message
     */
    public async Ok set_business_greeting_message_settings (
        BusinessGreetingMessageSettings greeting_message_settings
    ) throws TDLibError {
        try {

        var obj = new SetBusinessGreetingMessageSettings (
            greeting_message_settings
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_business_greeting_message_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the business away message settings of the current user.
     * Requires Telegram Business subscription
     * @param away_message_settings The new settings for the away message of
     * the business; pass null to disable the away message
     */
    public async Ok set_business_away_message_settings (
        BusinessAwayMessageSettings away_message_settings
    ) throws TDLibError {
        try {

        var obj = new SetBusinessAwayMessageSettings (
            away_message_settings
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_business_away_message_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the business start page of the current user. Requires Telegram
     * Business subscription
     * @param start_page The new start page of the business; pass null to
     * remove custom start page
     */
    public async Ok set_business_start_page (
        InputBusinessStartPage start_page
    ) throws TDLibError {
        try {

        var obj = new SetBusinessStartPage (
            start_page
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_business_start_page.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends a code to the specified phone number. Aborts previous phone
     * number verification if there was one. On success, returns information
     * about the sent code
     * @param phone_number The phone number, in international format
     * @param settings Settings for the authentication of the user's phone
     * number; pass null to use default settings
     * @param type_ Type of the request for which the code is sent
     */
    public async AuthenticationCodeInfo send_phone_number_code (
        string phone_number,
        PhoneNumberAuthenticationSettings settings,
        PhoneNumberCodeType type_
    ) throws TDLibError {
        try {

        var obj = new SendPhoneNumberCode (
            phone_number,
            settings,
            type_
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_phone_number_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (AuthenticationCodeInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends Firebase Authentication SMS to the specified phone number. Works
     * only when received a code of the type
     * authenticationCodeTypeFirebaseAndroid or
     * authenticationCodeTypeFirebaseIos
     * @param token Play Integrity API or SafetyNet Attestation API token for
     * the Android application, or secret from push notification for the iOS
     * application
     */
    public async Ok send_phone_number_firebase_sms (
        string token
    ) throws TDLibError {
        try {

        var obj = new SendPhoneNumberFirebaseSms (
            token
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_phone_number_firebase_sms.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Reports that authentication code wasn't delivered via SMS to the
     * specified phone number; for official mobile applications only
     * @param mobile_network_code Current mobile network code
     */
    public async Ok report_phone_number_code_missing (
        string mobile_network_code
    ) throws TDLibError {
        try {

        var obj = new ReportPhoneNumberCodeMissing (
            mobile_network_code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_phone_number_code_missing.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Resends the authentication code sent to a phone number. Works only if
     * the previously received authenticationCodeInfo next_code_type was not
     * null and the server-specified timeout has passed
     * @param reason Reason of code resending; pass null if unknown
     */
    public async AuthenticationCodeInfo resend_phone_number_code (
        ResendCodeReason reason
    ) throws TDLibError {
        try {

        var obj = new ResendPhoneNumberCode (
            reason
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (resend_phone_number_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (AuthenticationCodeInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Check the authentication code and completes the request for which the
     * code was sent if appropriate
     * @param code Authentication code to check
     */
    public async Ok check_phone_number_code (
        string code
    ) throws TDLibError {
        try {

        var obj = new CheckPhoneNumberCode (
            code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_phone_number_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the business bot that is connected to the current user
     * account. Returns a 404 error if there is no connected bot
     */
    public async BusinessConnectedBot get_business_connected_bot () throws TDLibError {
        try {

        var obj = new GetBusinessConnectedBot ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_business_connected_bot.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BusinessConnectedBot) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds or changes business bot that is connected to the current user
     * account
     * @param bot Connection settings for the bot
     */
    public async Ok set_business_connected_bot (
        BusinessConnectedBot bot
    ) throws TDLibError {
        try {

        var obj = new SetBusinessConnectedBot (
            bot
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_business_connected_bot.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes the business bot that is connected to the current user account
     * @param bot_user_id Unique user identifier for the bot
     */
    public async Ok delete_business_connected_bot (
        int64 bot_user_id
    ) throws TDLibError {
        try {

        var obj = new DeleteBusinessConnectedBot (
            bot_user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_business_connected_bot.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Pauses or resumes the connected business bot in a specific chat
     * @param chat_id Chat identifier
     * @param is_paused Pass true to pause the connected bot in the chat;
     * pass false to resume the bot
     */
    public async Ok toggle_business_connected_bot_chat_is_paused (
        int64 chat_id,
        bool is_paused
    ) throws TDLibError {
        try {

        var obj = new ToggleBusinessConnectedBotChatIsPaused (
            chat_id,
            is_paused
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_business_connected_bot_chat_is_paused.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes the connected business bot from a specific chat by adding the
     * chat to businessRecipients.excluded_chat_ids
     * @param chat_id Chat identifier
     */
    public async Ok remove_business_connected_bot_from_chat (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new RemoveBusinessConnectedBotFromChat (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_business_connected_bot_from_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns business chat links created for the current account
     */
    public async BusinessChatLinks get_business_chat_links () throws TDLibError {
        try {

        var obj = new GetBusinessChatLinks ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_business_chat_links.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BusinessChatLinks) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Creates a business chat link for the current account. Requires
     * Telegram Business subscription. There can be up to
     * getOption("business_chat_link_count_max") links created. Returns the
     * created link
     * @param link_info Information about the link to create
     */
    public async BusinessChatLink create_business_chat_link (
        InputBusinessChatLink link_info
    ) throws TDLibError {
        try {

        var obj = new CreateBusinessChatLink (
            link_info
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_business_chat_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BusinessChatLink) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits a business chat link of the current account. Requires Telegram
     * Business subscription. Returns the edited link
     * @param link The link to edit
     * @param link_info New description of the link
     */
    public async BusinessChatLink edit_business_chat_link (
        string link,
        InputBusinessChatLink link_info
    ) throws TDLibError {
        try {

        var obj = new EditBusinessChatLink (
            link,
            link_info
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_business_chat_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BusinessChatLink) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes a business chat link of the current account
     * @param link The link to delete
     */
    public async Ok delete_business_chat_link (
        string link
    ) throws TDLibError {
        try {

        var obj = new DeleteBusinessChatLink (
            link
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_business_chat_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a business chat link
     * @param link_name Name of the link
     */
    public async BusinessChatLinkInfo get_business_chat_link_info (
        string link_name
    ) throws TDLibError {
        try {

        var obj = new GetBusinessChatLinkInfo (
            link_name
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_business_chat_link_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BusinessChatLinkInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an HTTPS link, which can be used to get information about the
     * current user
     */
    public async UserLink get_user_link () throws TDLibError {
        try {

        var obj = new GetUserLink ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_user_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (UserLink) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches a user by a token from the user's link
     * @param token Token to search for
     */
    public async User search_user_by_token (
        string token
    ) throws TDLibError {
        try {

        var obj = new SearchUserByToken (
            token
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_user_by_token.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (User) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the list of commands supported by the bot for the given user
     * scope and language; for bots only
     * @param scope The scope to which the commands are relevant; pass null
     * to change commands in the default bot command scope
     * @param language_code A two-letter ISO 639-1 language code. If empty,
     * the commands will be applied to all users from the given scope, for
     * which language there are no dedicated commands
     * @param commands List of the bot's commands
     */
    public async Ok set_commands (
        BotCommandScope scope,
        string language_code,
        Gee.ArrayList<BotCommand?> commands
    ) throws TDLibError {
        try {

        var obj = new SetCommands (
            scope,
            language_code,
            commands
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_commands.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes commands supported by the bot for the given user scope and
     * language; for bots only
     * @param scope The scope to which the commands are relevant; pass null
     * to delete commands in the default bot command scope
     * @param language_code A two-letter ISO 639-1 language code or an empty
     * string
     */
    public async Ok delete_commands (
        BotCommandScope scope,
        string language_code
    ) throws TDLibError {
        try {

        var obj = new DeleteCommands (
            scope,
            language_code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_commands.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of commands supported by the bot for the given user
     * scope and language; for bots only
     * @param scope The scope to which the commands are relevant; pass null
     * to get commands in the default bot command scope
     * @param language_code A two-letter ISO 639-1 language code or an empty
     * string
     */
    public async BotCommands get_commands (
        BotCommandScope scope,
        string language_code
    ) throws TDLibError {
        try {

        var obj = new GetCommands (
            scope,
            language_code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_commands.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BotCommands) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets menu button for the given user or for all users; for bots only
     * @param user_id Identifier of the user or 0 to set menu button for all
     * users
     * @param menu_button New menu button
     */
    public async Ok set_menu_button (
        int64 user_id,
        BotMenuButton menu_button
    ) throws TDLibError {
        try {

        var obj = new SetMenuButton (
            user_id,
            menu_button
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_menu_button.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns menu button set by the bot for the given user; for bots only
     * @param user_id Identifier of the user or 0 to get the default menu
     * button
     */
    public async BotMenuButton get_menu_button (
        int64 user_id
    ) throws TDLibError {
        try {

        var obj = new GetMenuButton (
            user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_menu_button.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BotMenuButton) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets default administrator rights for adding the bot to basic group
     * and supergroup chats; for bots only
     * @param default_group_administrator_rights Default administrator rights
     * for adding the bot to basic group and supergroup chats; pass null to
     * remove default rights
     */
    public async Ok set_default_group_administrator_rights (
        ChatAdministratorRights default_group_administrator_rights
    ) throws TDLibError {
        try {

        var obj = new SetDefaultGroupAdministratorRights (
            default_group_administrator_rights
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_default_group_administrator_rights.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets default administrator rights for adding the bot to channel chats;
     * for bots only
     * @param default_channel_administrator_rights Default administrator
     * rights for adding the bot to channels; pass null to remove default
     * rights
     */
    public async Ok set_default_channel_administrator_rights (
        ChatAdministratorRights default_channel_administrator_rights
    ) throws TDLibError {
        try {

        var obj = new SetDefaultChannelAdministratorRights (
            default_channel_administrator_rights
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_default_channel_administrator_rights.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks whether the specified bot can send messages to the user.
     * Returns a 404 error if can't and the access can be granted by call to
     * {@link Client.allow_bot_to_send_messages}
     * @param bot_user_id Identifier of the target bot
     */
    public async Ok can_bot_send_messages (
        int64 bot_user_id
    ) throws TDLibError {
        try {

        var obj = new CanBotSendMessages (
            bot_user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (can_bot_send_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Allows the specified bot to send messages to the user
     * @param bot_user_id Identifier of the target bot
     */
    public async Ok allow_bot_to_send_messages (
        int64 bot_user_id
    ) throws TDLibError {
        try {

        var obj = new AllowBotToSendMessages (
            bot_user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (allow_bot_to_send_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends a custom request from a Web App
     * @param bot_user_id Identifier of the bot
     * @param method The method name
     * @param parameters JSON-serialized method parameters
     */
    public async CustomRequestResult send_web_app_custom_request (
        int64 bot_user_id,
        string method,
        string parameters
    ) throws TDLibError {
        try {

        var obj = new SendWebAppCustomRequest (
            bot_user_id,
            method,
            parameters
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_web_app_custom_request.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (CustomRequestResult) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of media previews of a bot
     * @param bot_user_id Identifier of the target bot. The bot must have the
     * main Web App
     */
    public async BotMediaPreviews get_bot_media_previews (
        int64 bot_user_id
    ) throws TDLibError {
        try {

        var obj = new GetBotMediaPreviews (
            bot_user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_bot_media_previews.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BotMediaPreviews) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of media previews for the given language and the list
     * of languages for which the bot has dedicated previews
     * @param bot_user_id Identifier of the target bot. The bot must be owned
     * and must have the main Web App
     * @param language_code A two-letter ISO 639-1 language code for which to
     * get previews. If empty, then default previews are returned
     */
    public async BotMediaPreviewInfo get_bot_media_preview_info (
        int64 bot_user_id,
        string language_code
    ) throws TDLibError {
        try {

        var obj = new GetBotMediaPreviewInfo (
            bot_user_id,
            language_code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_bot_media_preview_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BotMediaPreviewInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a new media preview to the beginning of the list of media
     * previews of a bot. Returns the added preview after addition is
     * completed server-side. The total number of previews must not exceed
     * getOption("bot_media_preview_count_max") for the given language
     * @param bot_user_id Identifier of the target bot. The bot must be owned
     * and must have the main Web App
     * @param language_code A two-letter ISO 639-1 language code for which
     * preview is added. If empty, then the preview will be shown to all
     * users for whose languages there are no dedicated previews. If
     * non-empty, then there must be an official language pack of the same
     * name, which is returned by {@link Client.get_localization_target_info}
     * @param content Content of the added preview
     */
    public async BotMediaPreview add_bot_media_preview (
        int64 bot_user_id,
        string language_code,
        InputStoryContent content
    ) throws TDLibError {
        try {

        var obj = new AddBotMediaPreview (
            bot_user_id,
            language_code,
            content
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_bot_media_preview.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BotMediaPreview) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Replaces media preview in the list of media previews of a bot. Returns
     * the new preview after edit is completed server-side
     * @param bot_user_id Identifier of the target bot. The bot must be owned
     * and must have the main Web App
     * @param language_code Language code of the media preview to edit
     * @param file_id File identifier of the media to replace
     * @param content Content of the new preview
     */
    public async BotMediaPreview edit_bot_media_preview (
        int64 bot_user_id,
        string language_code,
        int32 file_id,
        InputStoryContent content
    ) throws TDLibError {
        try {

        var obj = new EditBotMediaPreview (
            bot_user_id,
            language_code,
            file_id,
            content
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_bot_media_preview.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BotMediaPreview) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes order of media previews in the list of media previews of a bot
     * @param bot_user_id Identifier of the target bot. The bot must be owned
     * and must have the main Web App
     * @param language_code Language code of the media previews to reorder
     * @param file_ids File identifiers of the media in the new order
     */
    public async Ok reorder_bot_media_previews (
        int64 bot_user_id,
        string language_code,
        Gee.ArrayList<int32?> file_ids
    ) throws TDLibError {
        try {

        var obj = new ReorderBotMediaPreviews (
            bot_user_id,
            language_code,
            file_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reorder_bot_media_previews.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Delete media previews from the list of media previews of a bot
     * @param bot_user_id Identifier of the target bot. The bot must be owned
     * and must have the main Web App
     * @param language_code Language code of the media previews to delete
     * @param file_ids File identifiers of the media to delete
     */
    public async Ok delete_bot_media_previews (
        int64 bot_user_id,
        string language_code,
        Gee.ArrayList<int32?> file_ids
    ) throws TDLibError {
        try {

        var obj = new DeleteBotMediaPreviews (
            bot_user_id,
            language_code,
            file_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_bot_media_previews.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the name of a bot. Can be called only if
     * userTypeBot.can_be_edited == true
     * @param bot_user_id Identifier of the target bot
     * @param language_code A two-letter ISO 639-1 language code. If empty,
     * the name will be shown to all users for whose languages there is no
     * dedicated name
     * @param name New bot's name on the specified language; 0-64 characters;
     * must be non-empty if language code is empty
     */
    public async Ok set_bot_name (
        int64 bot_user_id,
        string language_code,
        string name
    ) throws TDLibError {
        try {

        var obj = new SetBotName (
            bot_user_id,
            language_code,
            name
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_bot_name.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the name of a bot in the given language. Can be called only if
     * userTypeBot.can_be_edited == true
     * @param bot_user_id Identifier of the target bot
     * @param language_code A two-letter ISO 639-1 language code or an empty
     * string
     */
    public async Text get_bot_name (
        int64 bot_user_id,
        string language_code
    ) throws TDLibError {
        try {

        var obj = new GetBotName (
            bot_user_id,
            language_code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_bot_name.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes a profile photo for a bot
     * @param bot_user_id Identifier of the target bot
     * @param photo Profile photo to set; pass null to delete the chat photo
     */
    public async Ok set_bot_profile_photo (
        int64 bot_user_id,
        InputChatPhoto photo
    ) throws TDLibError {
        try {

        var obj = new SetBotProfilePhoto (
            bot_user_id,
            photo
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_bot_profile_photo.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes active state for a username of a bot. The editable username
     * can't be disabled. May return an error with a message
     * "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames
     * has been reached. Can be called only if userTypeBot.can_be_edited ==
     * true
     * @param bot_user_id Identifier of the target bot
     * @param username The username to change
     * @param is_active Pass true to activate the username; pass false to
     * disable it
     */
    public async Ok toggle_bot_username_is_active (
        int64 bot_user_id,
        string username,
        bool is_active
    ) throws TDLibError {
        try {

        var obj = new ToggleBotUsernameIsActive (
            bot_user_id,
            username,
            is_active
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_bot_username_is_active.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes order of active usernames of a bot. Can be called only if
     * userTypeBot.can_be_edited == true
     * @param bot_user_id Identifier of the target bot
     * @param usernames The new order of active usernames. All currently
     * active usernames must be specified
     */
    public async Ok reorder_bot_active_usernames (
        int64 bot_user_id,
        Gee.ArrayList<string?> usernames
    ) throws TDLibError {
        try {

        var obj = new ReorderBotActiveUsernames (
            bot_user_id,
            usernames
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reorder_bot_active_usernames.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the text shown in the chat with a bot if the chat is empty. Can
     * be called only if userTypeBot.can_be_edited == true
     * @param bot_user_id Identifier of the target bot
     * @param language_code A two-letter ISO 639-1 language code. If empty,
     * the description will be shown to all users for whose languages there
     * is no dedicated description
     * @param description New bot's description on the specified language
     */
    public async Ok set_bot_info_description (
        int64 bot_user_id,
        string language_code,
        string description
    ) throws TDLibError {
        try {

        var obj = new SetBotInfoDescription (
            bot_user_id,
            language_code,
            description
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_bot_info_description.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the text shown in the chat with a bot if the chat is empty in
     * the given language. Can be called only if userTypeBot.can_be_edited ==
     * true
     * @param bot_user_id Identifier of the target bot
     * @param language_code A two-letter ISO 639-1 language code or an empty
     * string
     */
    public async Text get_bot_info_description (
        int64 bot_user_id,
        string language_code
    ) throws TDLibError {
        try {

        var obj = new GetBotInfoDescription (
            bot_user_id,
            language_code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_bot_info_description.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the text shown on a bot's profile page and sent together with the
     * link when users share the bot. Can be called only if
     * userTypeBot.can_be_edited == true
     * @param bot_user_id Identifier of the target bot
     * @param language_code A two-letter ISO 639-1 language code. If empty,
     * the short description will be shown to all users for whose languages
     * there is no dedicated description
     * @param short_description New bot's short description on the specified
     * language
     */
    public async Ok set_bot_info_short_description (
        int64 bot_user_id,
        string language_code,
        string short_description
    ) throws TDLibError {
        try {

        var obj = new SetBotInfoShortDescription (
            bot_user_id,
            language_code,
            short_description
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_bot_info_short_description.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the text shown on a bot's profile page and sent together with
     * the link when users share the bot in the given language. Can be called
     * only if userTypeBot.can_be_edited == true
     * @param bot_user_id Identifier of the target bot
     * @param language_code A two-letter ISO 639-1 language code or an empty
     * string
     */
    public async Text get_bot_info_short_description (
        int64 bot_user_id,
        string language_code
    ) throws TDLibError {
        try {

        var obj = new GetBotInfoShortDescription (
            bot_user_id,
            language_code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_bot_info_short_description.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the verification status of a user or a chat by an owned bot
     * @param bot_user_id Identifier of the owned bot, which will verify the
     * user or the chat
     * @param verified_id Identifier of the user or the supergroup or channel
     * chat, which will be verified by the bot
     * @param custom_description Custom description of verification reason;
     * 0-getOption("bot_verification_custom_description_length_max"). If
     * empty, then "was verified by organization "organization_name"" will be
     * used as description. Can be specified only if the bot is allowed to
     * provide custom description
     */
    public async Ok set_message_sender_bot_verification (
        int64 bot_user_id,
        MessageSender verified_id,
        string custom_description
    ) throws TDLibError {
        try {

        var obj = new SetMessageSenderBotVerification (
            bot_user_id,
            verified_id,
            custom_description
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_message_sender_bot_verification.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes the verification status of a user or a chat by an owned bot
     * @param bot_user_id Identifier of the owned bot, which verified the
     * user or the chat
     * @param verified_id Identifier of the user or the supergroup or channel
     * chat, which verification is removed
     */
    public async Ok remove_message_sender_bot_verification (
        int64 bot_user_id,
        MessageSender verified_id
    ) throws TDLibError {
        try {

        var obj = new RemoveMessageSenderBotVerification (
            bot_user_id,
            verified_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_message_sender_bot_verification.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns all active sessions of the current user
     */
    public async Sessions get_active_sessions () throws TDLibError {
        try {

        var obj = new GetActiveSessions ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_active_sessions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Sessions) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Terminates a session of the current user
     * @param session_id Session identifier
     */
    public async Ok terminate_session (
        int64 session_id
    ) throws TDLibError {
        try {

        var obj = new TerminateSession (
            session_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (terminate_session.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Terminates all other sessions of the current user
     */
    public async Ok terminate_all_other_sessions () throws TDLibError {
        try {

        var obj = new TerminateAllOtherSessions ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (terminate_all_other_sessions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Confirms an unconfirmed session of the current user from another
     * device
     * @param session_id Session identifier
     */
    public async Ok confirm_session (
        int64 session_id
    ) throws TDLibError {
        try {

        var obj = new ConfirmSession (
            session_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (confirm_session.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether a session can accept incoming calls
     * @param session_id Session identifier
     * @param can_accept_calls Pass true to allow accepting incoming calls by
     * the session; pass false otherwise
     */
    public async Ok toggle_session_can_accept_calls (
        int64 session_id,
        bool can_accept_calls
    ) throws TDLibError {
        try {

        var obj = new ToggleSessionCanAcceptCalls (
            session_id,
            can_accept_calls
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_session_can_accept_calls.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether a session can accept incoming secret chats
     * @param session_id Session identifier
     * @param can_accept_secret_chats Pass true to allow accepting secret
     * chats by the session; pass false otherwise
     */
    public async Ok toggle_session_can_accept_secret_chats (
        int64 session_id,
        bool can_accept_secret_chats
    ) throws TDLibError {
        try {

        var obj = new ToggleSessionCanAcceptSecretChats (
            session_id,
            can_accept_secret_chats
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_session_can_accept_secret_chats.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the period of inactivity after which sessions will
     * automatically be terminated
     * @param inactive_session_ttl_days New number of days of inactivity
     * before sessions will be automatically terminated; 1-366 days
     */
    public async Ok set_inactive_session_ttl (
        int32 inactive_session_ttl_days
    ) throws TDLibError {
        try {

        var obj = new SetInactiveSessionTtl (
            inactive_session_ttl_days
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_inactive_session_ttl.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns all website where the current user used Telegram to log in
     */
    public async ConnectedWebsites get_connected_websites () throws TDLibError {
        try {

        var obj = new GetConnectedWebsites ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_connected_websites.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ConnectedWebsites) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Disconnects website from the current user's Telegram account
     * @param website_id Website identifier
     */
    public async Ok disconnect_website (
        int64 website_id
    ) throws TDLibError {
        try {

        var obj = new DisconnectWebsite (
            website_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (disconnect_website.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Disconnects all websites from the current user's Telegram account
     */
    public async Ok disconnect_all_websites () throws TDLibError {
        try {

        var obj = new DisconnectAllWebsites ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (disconnect_all_websites.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the editable username of a supergroup or channel, requires
     * owner privileges in the supergroup or channel
     * @param supergroup_id Identifier of the supergroup or channel
     * @param username New value of the username. Use an empty string to
     * remove the username. The username can't be completely removed if there
     * is another active or disabled username
     */
    public async Ok set_supergroup_username (
        int64 supergroup_id,
        string username
    ) throws TDLibError {
        try {

        var obj = new SetSupergroupUsername (
            supergroup_id,
            username
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_supergroup_username.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes active state for a username of a supergroup or channel,
     * requires owner privileges in the supergroup or channel. The editable
     * username can't be disabled.
     * May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the
     * maximum number of active usernames has been reached
     * @param supergroup_id Identifier of the supergroup or channel
     * @param username The username to change
     * @param is_active Pass true to activate the username; pass false to
     * disable it
     */
    public async Ok toggle_supergroup_username_is_active (
        int64 supergroup_id,
        string username,
        bool is_active
    ) throws TDLibError {
        try {

        var obj = new ToggleSupergroupUsernameIsActive (
            supergroup_id,
            username,
            is_active
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_username_is_active.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Disables all active non-editable usernames of a supergroup or channel,
     * requires owner privileges in the supergroup or channel
     * @param supergroup_id Identifier of the supergroup or channel
     */
    public async Ok disable_all_supergroup_usernames (
        int64 supergroup_id
    ) throws TDLibError {
        try {

        var obj = new DisableAllSupergroupUsernames (
            supergroup_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (disable_all_supergroup_usernames.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes order of active usernames of a supergroup or channel, requires
     * owner privileges in the supergroup or channel
     * @param supergroup_id Identifier of the supergroup or channel
     * @param usernames The new order of active usernames. All currently
     * active usernames must be specified
     */
    public async Ok reorder_supergroup_active_usernames (
        int64 supergroup_id,
        Gee.ArrayList<string?> usernames
    ) throws TDLibError {
        try {

        var obj = new ReorderSupergroupActiveUsernames (
            supergroup_id,
            usernames
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reorder_supergroup_active_usernames.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the sticker set of a supergroup; requires can_change_info
     * administrator right
     * @param supergroup_id Identifier of the supergroup
     * @param sticker_set_id New value of the supergroup sticker set
     * identifier. Use 0 to remove the supergroup sticker set
     */
    public async Ok set_supergroup_sticker_set (
        int64 supergroup_id,
        int64 sticker_set_id
    ) throws TDLibError {
        try {

        var obj = new SetSupergroupStickerSet (
            supergroup_id,
            sticker_set_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_supergroup_sticker_set.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the custom emoji sticker set of a supergroup; requires
     * can_change_info administrator right. The chat must have at least
     * chatBoostFeatures.min_custom_emoji_sticker_set_boost_level boost level
     * to pass the corresponding color
     * @param supergroup_id Identifier of the supergroup
     * @param custom_emoji_sticker_set_id New value of the custom emoji
     * sticker set identifier for the supergroup. Use 0 to remove the custom
     * emoji sticker set in the supergroup
     */
    public async Ok set_supergroup_custom_emoji_sticker_set (
        int64 supergroup_id,
        int64 custom_emoji_sticker_set_id
    ) throws TDLibError {
        try {

        var obj = new SetSupergroupCustomEmojiStickerSet (
            supergroup_id,
            custom_emoji_sticker_set_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_supergroup_custom_emoji_sticker_set.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the number of times the supergroup must be boosted by a user
     * to ignore slow mode and chat permission restrictions; requires
     * can_restrict_members administrator right
     * @param supergroup_id Identifier of the supergroup
     * @param unrestrict_boost_count New value of the unrestrict_boost_count
     * supergroup setting; 0-8. Use 0 to remove the setting
     */
    public async Ok set_supergroup_unrestrict_boost_count (
        int64 supergroup_id,
        int32 unrestrict_boost_count
    ) throws TDLibError {
        try {

        var obj = new SetSupergroupUnrestrictBoostCount (
            supergroup_id,
            unrestrict_boost_count
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_supergroup_unrestrict_boost_count.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether sender signature or link to the account is added to
     * sent messages in a channel; requires can_change_info member right
     * @param supergroup_id Identifier of the channel
     * @param sign_messages New value of sign_messages
     * @param show_message_sender New value of show_message_sender
     */
    public async Ok toggle_supergroup_sign_messages (
        int64 supergroup_id,
        bool sign_messages,
        bool show_message_sender
    ) throws TDLibError {
        try {

        var obj = new ToggleSupergroupSignMessages (
            supergroup_id,
            sign_messages,
            show_message_sender
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_sign_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether joining is mandatory to send messages to a discussion
     * supergroup; requires can_restrict_members administrator right
     * @param supergroup_id Identifier of the supergroup that isn't a
     * broadcast group
     * @param join_to_send_messages New value of join_to_send_messages
     */
    public async Ok toggle_supergroup_join_to_send_messages (
        int64 supergroup_id,
        bool join_to_send_messages
    ) throws TDLibError {
        try {

        var obj = new ToggleSupergroupJoinToSendMessages (
            supergroup_id,
            join_to_send_messages
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_join_to_send_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether all users directly joining the supergroup need to be
     * approved by supergroup administrators; requires can_restrict_members
     * administrator right
     * @param supergroup_id Identifier of the supergroup that isn't a
     * broadcast group
     * @param join_by_request New value of join_by_request
     */
    public async Ok toggle_supergroup_join_by_request (
        int64 supergroup_id,
        bool join_by_request
    ) throws TDLibError {
        try {

        var obj = new ToggleSupergroupJoinByRequest (
            supergroup_id,
            join_by_request
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_join_by_request.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether the message history of a supergroup is available to
     * new members; requires can_change_info member right
     * @param supergroup_id The identifier of the supergroup
     * @param is_all_history_available The new value of
     * is_all_history_available
     */
    public async Ok toggle_supergroup_is_all_history_available (
        int64 supergroup_id,
        bool is_all_history_available
    ) throws TDLibError {
        try {

        var obj = new ToggleSupergroupIsAllHistoryAvailable (
            supergroup_id,
            is_all_history_available
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_is_all_history_available.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether sponsored messages are shown in the channel chat;
     * requires owner privileges in the channel. The chat must have at least
     * chatBoostFeatures.min_sponsored_message_disable_boost_level boost
     * level to disable sponsored messages
     * @param supergroup_id The identifier of the channel
     * @param can_have_sponsored_messages The new value of
     * can_have_sponsored_messages
     */
    public async Ok toggle_supergroup_can_have_sponsored_messages (
        int64 supergroup_id,
        bool can_have_sponsored_messages
    ) throws TDLibError {
        try {

        var obj = new ToggleSupergroupCanHaveSponsoredMessages (
            supergroup_id,
            can_have_sponsored_messages
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_can_have_sponsored_messages.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether non-administrators can receive only administrators and
     * bots using {@link Client.get_supergroup_members} or
     * {@link Client.search_chat_members} Can be called only if
     * supergroupFullInfo.can_hide_members == true
     * @param supergroup_id Identifier of the supergroup
     * @param has_hidden_members New value of has_hidden_members
     */
    public async Ok toggle_supergroup_has_hidden_members (
        int64 supergroup_id,
        bool has_hidden_members
    ) throws TDLibError {
        try {

        var obj = new ToggleSupergroupHasHiddenMembers (
            supergroup_id,
            has_hidden_members
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_has_hidden_members.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether aggressive anti-spam checks are enabled in the
     * supergroup. Can be called only if
     * supergroupFullInfo.can_toggle_aggressive_anti_spam == true
     * @param supergroup_id The identifier of the supergroup, which isn't a
     * broadcast group
     * @param has_aggressive_anti_spam_enabled The new value of
     * has_aggressive_anti_spam_enabled
     */
    public async Ok toggle_supergroup_has_aggressive_anti_spam_enabled (
        int64 supergroup_id,
        bool has_aggressive_anti_spam_enabled
    ) throws TDLibError {
        try {

        var obj = new ToggleSupergroupHasAggressiveAntiSpamEnabled (
            supergroup_id,
            has_aggressive_anti_spam_enabled
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_has_aggressive_anti_spam_enabled.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether the supergroup is a forum; requires owner privileges
     * in the supergroup. Discussion supergroups can't be converted to forums
     * @param supergroup_id Identifier of the supergroup
     * @param is_forum New value of is_forum
     */
    public async Ok toggle_supergroup_is_forum (
        int64 supergroup_id,
        bool is_forum
    ) throws TDLibError {
        try {

        var obj = new ToggleSupergroupIsForum (
            supergroup_id,
            is_forum
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_is_forum.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Upgrades supergroup to a broadcast group; requires owner privileges in
     * the supergroup
     * @param supergroup_id Identifier of the supergroup
     */
    public async Ok toggle_supergroup_is_broadcast_group (
        int64 supergroup_id
    ) throws TDLibError {
        try {

        var obj = new ToggleSupergroupIsBroadcastGroup (
            supergroup_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_supergroup_is_broadcast_group.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Reports messages in a supergroup as spam; requires administrator
     * rights in the supergroup
     * @param supergroup_id Supergroup identifier
     * @param message_ids Identifiers of messages to report. Use
     * messageProperties.can_report_supergroup_spam to check whether the
     * message can be reported
     */
    public async Ok report_supergroup_spam (
        int64 supergroup_id,
        Gee.ArrayList<int64?> message_ids
    ) throws TDLibError {
        try {

        var obj = new ReportSupergroupSpam (
            supergroup_id,
            message_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_supergroup_spam.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Reports a false deletion of a message by aggressive anti-spam checks;
     * requires administrator rights in the supergroup. Can be called only
     * for messages from chatEventMessageDeleted with
     * can_report_anti_spam_false_positive == true
     * @param supergroup_id Supergroup identifier
     * @param message_id Identifier of the erroneously deleted message from
     * chatEventMessageDeleted
     */
    public async Ok report_supergroup_anti_spam_false_positive (
        int64 supergroup_id,
        int64 message_id
    ) throws TDLibError {
        try {

        var obj = new ReportSupergroupAntiSpamFalsePositive (
            supergroup_id,
            message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_supergroup_anti_spam_false_positive.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about members or banned users in a supergroup or
     * channel. Can be used only if supergroupFullInfo.can_get_members ==
     * true; additionally, administrator privileges may be required for some
     * filters
     * @param supergroup_id Identifier of the supergroup or channel
     * @param filter The type of users to return; pass null to use
     * supergroupMembersFilterRecent
     * @param offset Number of users to skip
     * @param limit The maximum number of users to be returned; up to 200
     */
    public async ChatMembers get_supergroup_members (
        int64 supergroup_id,
        SupergroupMembersFilter filter,
        int32 offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetSupergroupMembers (
            supergroup_id,
            filter,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_supergroup_members.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatMembers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Closes a secret chat, effectively transferring its state to
     * secretChatStateClosed
     * @param secret_chat_id Secret chat identifier
     */
    public async Ok close_secret_chat (
        int32 secret_chat_id
    ) throws TDLibError {
        try {

        var obj = new CloseSecretChat (
            secret_chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (close_secret_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a list of service actions taken by chat members and
     * administrators in the last 48 hours. Available only for supergroups
     * and channels. Requires administrator rights. Returns results in
     * reverse chronological order (i.e., in order of decreasing event_id)
     * @param chat_id Chat identifier
     * @param query Search query by which to filter events
     * @param from_event_id Identifier of an event from which to return
     * results. Use 0 to get results from the latest events
     * @param limit The maximum number of events to return; up to 100
     * @param filters The types of events to return; pass null to get chat
     * events of all types
     * @param user_ids User identifiers by which to filter events. By
     * default, events relating to all users will be returned
     */
    public async ChatEvents get_chat_event_log (
        int64 chat_id,
        string query,
        int64 from_event_id,
        int32 limit,
        ChatEventLogFilters filters,
        Gee.ArrayList<int64?> user_ids
    ) throws TDLibError {
        try {

        var obj = new GetChatEventLog (
            chat_id,
            query,
            from_event_id,
            limit,
            filters,
            user_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_event_log.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatEvents) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of supported time zones
     */
    public async TimeZones get_time_zones () throws TDLibError {
        try {

        var obj = new GetTimeZones ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_time_zones.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (TimeZones) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an invoice payment form. This method must be called when the
     * user presses inline button of the type inlineKeyboardButtonTypeBuy, or
     * wants to buy access to media in a messagePaidMedia message
     * @param input_invoice The invoice
     * @param theme Preferred payment form theme; pass null to use the
     * default theme
     */
    public async PaymentForm get_payment_form (
        InputInvoice input_invoice,
        ThemeParameters theme
    ) throws TDLibError {
        try {

        var obj = new GetPaymentForm (
            input_invoice,
            theme
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_payment_form.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PaymentForm) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Validates the order information provided by a user and returns the
     * available shipping options for a flexible invoice
     * @param input_invoice The invoice
     * @param order_info The order information, provided by the user; pass
     * null if empty
     * @param allow_save Pass true to save the order information
     */
    public async ValidatedOrderInfo validate_order_info (
        InputInvoice input_invoice,
        OrderInfo order_info,
        bool allow_save
    ) throws TDLibError {
        try {

        var obj = new ValidateOrderInfo (
            input_invoice,
            order_info,
            allow_save
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (validate_order_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ValidatedOrderInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends a filled-out payment form to the bot for final verification
     * @param input_invoice The invoice
     * @param payment_form_id Payment form identifier returned by
     * {@link Client.get_payment_form}
     * @param order_info_id Identifier returned by
     * {@link Client.validate_order_info} or an empty string
     * @param shipping_option_id Identifier of a chosen shipping option, if
     * applicable
     * @param credentials The credentials chosen by user for payment; pass
     * null for a payment in Telegram Stars
     * @param tip_amount Chosen by the user amount of tip in the smallest
     * units of the currency
     */
    public async PaymentResult send_payment_form (
        InputInvoice input_invoice,
        int64 payment_form_id,
        string order_info_id,
        string shipping_option_id,
        InputCredentials credentials,
        int64 tip_amount
    ) throws TDLibError {
        try {

        var obj = new SendPaymentForm (
            input_invoice,
            payment_form_id,
            order_info_id,
            shipping_option_id,
            credentials,
            tip_amount
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_payment_form.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PaymentResult) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a successful payment
     * @param chat_id Chat identifier of the messagePaymentSuccessful message
     * @param message_id Message identifier
     */
    public async PaymentReceipt get_payment_receipt (
        int64 chat_id,
        int64 message_id
    ) throws TDLibError {
        try {

        var obj = new GetPaymentReceipt (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_payment_receipt.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PaymentReceipt) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns saved order information. Returns a 404 error if there is no
     * saved order information
     */
    public async OrderInfo get_saved_order_info () throws TDLibError {
        try {

        var obj = new GetSavedOrderInfo ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_saved_order_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (OrderInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes saved order information
     */
    public async Ok delete_saved_order_info () throws TDLibError {
        try {

        var obj = new DeleteSavedOrderInfo ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_saved_order_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes saved credentials for all payment provider bots
     */
    public async Ok delete_saved_credentials () throws TDLibError {
        try {

        var obj = new DeleteSavedCredentials ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_saved_credentials.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns gifts that can be sent to other users and channel chats
     */
    public async Gifts get_available_gifts () throws TDLibError {
        try {

        var obj = new GetAvailableGifts ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_available_gifts.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Gifts) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends a gift to another user or channel chat. May return an error with
     * a message "STARGIFT_USAGE_LIMITED" if the gift was sold out
     * @param gift_id Identifier of the gift to send
     * @param owner_id Identifier of the user or the channel chat that will
     * receive the gift
     * @param text Text to show along with the gift;
     * 0-getOption("gift_text_length_max") characters. Only Bold, Italic,
     * Underline, Strikethrough, Spoiler, and CustomEmoji entities are
     * allowed
     * @param is_private Pass true to show gift text and sender only to the
     * gift receiver; otherwise, everyone will be able to see them
     * @param pay_for_upgrade Pass true to additionally pay for the gift
     * upgrade and allow the receiver to upgrade it for free
     */
    public async Ok send_gift (
        int64 gift_id,
        MessageSender owner_id,
        FormattedText text,
        bool is_private,
        bool pay_for_upgrade
    ) throws TDLibError {
        try {

        var obj = new SendGift (
            gift_id,
            owner_id,
            text,
            is_private,
            pay_for_upgrade
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_gift.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sells a gift for Telegram Stars
     * @param received_gift_id Identifier of the gift
     */
    public async Ok sell_gift (
        string received_gift_id
    ) throws TDLibError {
        try {

        var obj = new SellGift (
            received_gift_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (sell_gift.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether a gift is shown on the current user's or the channel's
     * profile page; requires can_post_messages administrator right in the
     * chat
     * @param received_gift_id Identifier of the gift
     * @param is_saved Pass true to display the gift on the user's or the
     * channel's profile page; pass false to remove it from the profile page
     */
    public async Ok toggle_gift_is_saved (
        string received_gift_id,
        bool is_saved
    ) throws TDLibError {
        try {

        var obj = new ToggleGiftIsSaved (
            received_gift_id,
            is_saved
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_gift_is_saved.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Toggles whether notifications for new gifts received by a channel chat
     * are sent to the current user; requires can_post_messages administrator
     * right in the chat
     * @param chat_id Identifier of the channel chat
     * @param are_enabled Pass true to enable notifications about new gifts
     * owned by the channel chat; pass false to disable the notifications
     */
    public async Ok toggle_chat_gift_notifications (
        int64 chat_id,
        bool are_enabled
    ) throws TDLibError {
        try {

        var obj = new ToggleChatGiftNotifications (
            chat_id,
            are_enabled
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (toggle_chat_gift_notifications.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns examples of possible upgraded gifts for a regular gift
     * @param gift_id Identifier of the gift
     */
    public async GiftUpgradePreview get_gift_upgrade_preview (
        int64 gift_id
    ) throws TDLibError {
        try {

        var obj = new GetGiftUpgradePreview (
            gift_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_gift_upgrade_preview.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (GiftUpgradePreview) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Upgrades a regular gift
     * @param received_gift_id Identifier of the gift
     * @param keep_original_details Pass true to keep the original gift text,
     * sender and receiver in the upgraded gift
     * @param star_count The amount of Telegram Stars required to pay for the
     * upgrade. It the gift has prepaid_upgrade_star_count > 0, then pass 0,
     * otherwise, pass gift.upgrade_star_count
     */
    public async UpgradeGiftResult upgrade_gift (
        string received_gift_id,
        bool keep_original_details,
        int64 star_count
    ) throws TDLibError {
        try {

        var obj = new UpgradeGift (
            received_gift_id,
            keep_original_details,
            star_count
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (upgrade_gift.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (UpgradeGiftResult) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends an upgraded gift to another user or a channel chat
     * @param received_gift_id Identifier of the gift
     * @param new_owner_id Identifier of the user or the channel chat that
     * will receive the gift
     * @param star_count The amount of Telegram Stars required to pay for the
     * transfer
     */
    public async Ok transfer_gift (
        string received_gift_id,
        MessageSender new_owner_id,
        int64 star_count
    ) throws TDLibError {
        try {

        var obj = new TransferGift (
            received_gift_id,
            new_owner_id,
            star_count
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (transfer_gift.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns gifts received by the given user or chat
     * @param owner_id Identifier of the gift receiver
     * @param exclude_unsaved Pass true to exclude gifts that aren't saved to
     * the chat's profile page. Always true for gifts received by other users
     * and channel chats without can_post_messages administrator right
     * @param exclude_saved Pass true to exclude gifts that are saved to the
     * chat's profile page. Always false for gifts received by other users
     * and channel chats without can_post_messages administrator right
     * @param exclude_unlimited Pass true to exclude gifts that can be
     * purchased unlimited number of times
     * @param exclude_limited Pass true to exclude gifts that can be
     * purchased limited number of times
     * @param exclude_upgraded Pass true to exclude upgraded gifts
     * @param sort_by_price Pass true to sort results by gift price instead
     * of send date
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of gifts to be returned; must be
     * positive and can't be greater than 100. For optimal performance, the
     * number of returned objects is chosen by TDLib and can be smaller than
     * the specified limit
     */
    public async ReceivedGifts get_received_gifts (
        MessageSender owner_id,
        bool exclude_unsaved,
        bool exclude_saved,
        bool exclude_unlimited,
        bool exclude_limited,
        bool exclude_upgraded,
        bool sort_by_price,
        string offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetReceivedGifts (
            owner_id,
            exclude_unsaved,
            exclude_saved,
            exclude_unlimited,
            exclude_limited,
            exclude_upgraded,
            sort_by_price,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_received_gifts.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ReceivedGifts) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a received gift
     * @param received_gift_id Identifier of the gift
     */
    public async ReceivedGift get_received_gift (
        string received_gift_id
    ) throws TDLibError {
        try {

        var obj = new GetReceivedGift (
            received_gift_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_received_gift.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ReceivedGift) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about an upgraded gift by its name
     * @param name Unique name of the upgraded gift
     */
    public async UpgradedGift get_upgraded_gift (
        string name
    ) throws TDLibError {
        try {

        var obj = new GetUpgradedGift (
            name
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_upgraded_gift.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (UpgradedGift) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a URL for upgraded gift withdrawal in the TON blockchain as an
     * NFT; requires owner privileges for gifts owned by a chat
     * @param received_gift_id Identifier of the gift
     * @param password The 2-step verification password of the current user
     */
    public async HttpUrl get_upgraded_gift_withdrawal_url (
        string received_gift_id,
        string password
    ) throws TDLibError {
        try {

        var obj = new GetUpgradedGiftWithdrawalUrl (
            received_gift_id,
            password
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_upgraded_gift_withdrawal_url.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (HttpUrl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Creates a link for the given invoice; for bots only
     * @param business_connection_id Unique identifier of business connection
     * on behalf of which to send the request
     * @param invoice Information about the invoice of the type
     * inputMessageInvoice
     */
    public async HttpUrl create_invoice_link (
        string business_connection_id,
        InputMessageContent invoice
    ) throws TDLibError {
        try {

        var obj = new CreateInvoiceLink (
            business_connection_id,
            invoice
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_invoice_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (HttpUrl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Refunds a previously done payment in Telegram Stars; for bots only
     * @param user_id Identifier of the user that did the payment
     * @param telegram_payment_charge_id Telegram payment identifier
     */
    public async Ok refund_star_payment (
        int64 user_id,
        string telegram_payment_charge_id
    ) throws TDLibError {
        try {

        var obj = new RefundStarPayment (
            user_id,
            telegram_payment_charge_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (refund_star_payment.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a user that can be contacted to get support
     */
    public async User get_support_user () throws TDLibError {
        try {

        var obj = new GetSupportUser ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_support_user.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (User) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Constructs a persistent HTTP URL for a background
     * @param name Background name
     * @param type_ Background type; backgroundTypeChatTheme isn't supported
     */
    public async HttpUrl get_background_url (
        string name,
        BackgroundType type_
    ) throws TDLibError {
        try {

        var obj = new GetBackgroundUrl (
            name,
            type_
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_background_url.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (HttpUrl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches for a background by its name
     * @param name The name of the background
     */
    public async Background search_background (
        string name
    ) throws TDLibError {
        try {

        var obj = new SearchBackground (
            name
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_background.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Background) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets default background for chats; adds the background to the list of
     * installed backgrounds
     * @param background The input background to use; pass null to create a
     * new filled background
     * @param type_ Background type; pass null to use the default type of the
     * remote background; backgroundTypeChatTheme isn't supported
     * @param for_dark_theme Pass true if the background is set for a dark
     * theme
     */
    public async Background set_default_background (
        InputBackground background,
        BackgroundType type_,
        bool for_dark_theme
    ) throws TDLibError {
        try {

        var obj = new SetDefaultBackground (
            background,
            type_,
            for_dark_theme
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_default_background.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Background) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes default background for chats
     * @param for_dark_theme Pass true if the background is deleted for a
     * dark theme
     */
    public async Ok delete_default_background (
        bool for_dark_theme
    ) throws TDLibError {
        try {

        var obj = new DeleteDefaultBackground (
            for_dark_theme
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_default_background.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns backgrounds installed by the user
     * @param for_dark_theme Pass true to order returned backgrounds for a
     * dark theme
     */
    public async Backgrounds get_installed_backgrounds (
        bool for_dark_theme
    ) throws TDLibError {
        try {

        var obj = new GetInstalledBackgrounds (
            for_dark_theme
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_installed_backgrounds.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Backgrounds) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes background from the list of installed backgrounds
     * @param background_id The background identifier
     */
    public async Ok remove_installed_background (
        int64 background_id
    ) throws TDLibError {
        try {

        var obj = new RemoveInstalledBackground (
            background_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_installed_background.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Resets list of installed backgrounds to its default value
     */
    public async Ok reset_installed_backgrounds () throws TDLibError {
        try {

        var obj = new ResetInstalledBackgrounds ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reset_installed_backgrounds.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about the current localization target. This is an
     * offline request if only_local is true. Can be called before
     * authorization
     * @param only_local Pass true to get only locally available information
     * without sending network requests
     */
    public async LocalizationTargetInfo get_localization_target_info (
        bool only_local
    ) throws TDLibError {
        try {

        var obj = new GetLocalizationTargetInfo (
            only_local
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_localization_target_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (LocalizationTargetInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a language pack. Returned language pack
     * identifier may be different from a provided one. Can be called before
     * authorization
     * @param language_pack_id Language pack identifier
     */
    public async LanguagePackInfo get_language_pack_info (
        string language_pack_id
    ) throws TDLibError {
        try {

        var obj = new GetLanguagePackInfo (
            language_pack_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_language_pack_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (LanguagePackInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns strings from a language pack in the current localization
     * target by their keys. Can be called before authorization
     * @param language_pack_id Language pack identifier of the strings to be
     * returned
     * @param keys Language pack keys of the strings to be returned; leave
     * empty to request all available strings
     */
    public async LanguagePackStrings get_language_pack_strings (
        string language_pack_id,
        Gee.ArrayList<string?> keys
    ) throws TDLibError {
        try {

        var obj = new GetLanguagePackStrings (
            language_pack_id,
            keys
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_language_pack_strings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (LanguagePackStrings) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Fetches the latest versions of all strings from a language pack in the
     * current localization target from the server.
     * This method doesn't need to be called explicitly for the current
     * used/base language packs. Can be called before authorization
     * @param language_pack_id Language pack identifier
     */
    public async Ok synchronize_language_pack (
        string language_pack_id
    ) throws TDLibError {
        try {

        var obj = new SynchronizeLanguagePack (
            language_pack_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (synchronize_language_pack.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a custom server language pack to the list of installed language
     * packs in current localization target. Can be called before
     * authorization
     * @param language_pack_id Identifier of a language pack to be added
     */
    public async Ok add_custom_server_language_pack (
        string language_pack_id
    ) throws TDLibError {
        try {

        var obj = new AddCustomServerLanguagePack (
            language_pack_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_custom_server_language_pack.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds or changes a custom local language pack to the current
     * localization target
     * @param info Information about the language pack. Language pack
     * identifier must start with 'X', consist only of English letters,
     * digits and hyphens, and must not exceed 64 characters. Can be called
     * before authorization
     * @param strings Strings of the new language pack
     */
    public async Ok set_custom_language_pack (
        LanguagePackInfo info,
        Gee.ArrayList<LanguagePackString?> strings
    ) throws TDLibError {
        try {

        var obj = new SetCustomLanguagePack (
            info,
            strings
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_custom_language_pack.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits information about a custom local language pack in the current
     * localization target. Can be called before authorization
     * @param info New information about the custom local language pack
     */
    public async Ok edit_custom_language_pack_info (
        LanguagePackInfo info
    ) throws TDLibError {
        try {

        var obj = new EditCustomLanguagePackInfo (
            info
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_custom_language_pack_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds, edits or deletes a string in a custom local language pack. Can
     * be called before authorization
     * @param language_pack_id Identifier of a previously added custom local
     * language pack in the current localization target
     * @param new_string New language pack string
     */
    public async Ok set_custom_language_pack_string (
        string language_pack_id,
        LanguagePackString new_string
    ) throws TDLibError {
        try {

        var obj = new SetCustomLanguagePackString (
            language_pack_id,
            new_string
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_custom_language_pack_string.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes all information about a language pack in the current
     * localization target. The language pack which is currently in use
     * (including base language pack) or is being synchronized can't be
     * deleted.
     * Can be called before authorization
     * @param language_pack_id Identifier of the language pack to delete
     */
    public async Ok delete_language_pack (
        string language_pack_id
    ) throws TDLibError {
        try {

        var obj = new DeleteLanguagePack (
            language_pack_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_language_pack.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Registers the currently used device for receiving push notifications.
     * Returns a globally unique identifier of the push notification
     * subscription
     * @param device_token Device token
     * @param other_user_ids List of user identifiers of other users
     * currently using the application
     */
    public async PushReceiverId register_device (
        DeviceToken device_token,
        Gee.ArrayList<int64?> other_user_ids
    ) throws TDLibError {
        try {

        var obj = new RegisterDevice (
            device_token,
            other_user_ids
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (register_device.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PushReceiverId) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Handles a push notification. Returns error with code 406 if the push
     * notification is not supported and connection to the server is required
     * to fetch new data. Can be called before authorization
     * @param payload JSON-encoded push notification payload with all fields
     * sent by the server, and "google.sent_time" and
     * "google.notification.sound" fields added
     */
    public async Ok process_push_notification (
        string payload
    ) throws TDLibError {
        try {

        var obj = new ProcessPushNotification (
            payload
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (process_push_notification.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a globally unique push notification subscription identifier
     * for identification of an account, which has received a push
     * notification. Can be called synchronously
     * @param payload JSON-encoded push notification payload
     */
    public PushReceiverId get_push_receiver_id_sync (
        string payload
    ) throws TDLibError {
        try {

        var obj = new GetPushReceiverId (
            payload
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PushReceiverId) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a globally unique push notification subscription identifier
     * for identification of an account, which has received a push
     * notification. Can be called synchronously
     * @param payload JSON-encoded push notification payload
     */
    public async PushReceiverId get_push_receiver_id (
        string payload
    ) throws TDLibError {
        try {

        var obj = new GetPushReceiverId (
            payload
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_push_receiver_id.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PushReceiverId) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns t.me URLs recently visited by a newly registered user
     * @param referrer Google Play referrer to identify the user
     */
    public async TMeUrls get_recently_visited_t_me_urls (
        string referrer
    ) throws TDLibError {
        try {

        var obj = new GetRecentlyVisitedTMeUrls (
            referrer
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_recently_visited_t_me_urls.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (TMeUrls) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes user privacy settings
     * @param setting The privacy setting
     * @param rules The new privacy rules
     */
    public async Ok set_user_privacy_setting_rules (
        UserPrivacySetting setting,
        UserPrivacySettingRules rules
    ) throws TDLibError {
        try {

        var obj = new SetUserPrivacySettingRules (
            setting,
            rules
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_user_privacy_setting_rules.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the current privacy settings
     * @param setting The privacy setting
     */
    public async UserPrivacySettingRules get_user_privacy_setting_rules (
        UserPrivacySetting setting
    ) throws TDLibError {
        try {

        var obj = new GetUserPrivacySettingRules (
            setting
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_user_privacy_setting_rules.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (UserPrivacySettingRules) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes privacy settings for message read date
     * @param settings New settings
     */
    public async Ok set_read_date_privacy_settings (
        ReadDatePrivacySettings settings
    ) throws TDLibError {
        try {

        var obj = new SetReadDatePrivacySettings (
            settings
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_read_date_privacy_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns privacy settings for message read date
     */
    public async ReadDatePrivacySettings get_read_date_privacy_settings () throws TDLibError {
        try {

        var obj = new GetReadDatePrivacySettings ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_read_date_privacy_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ReadDatePrivacySettings) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes privacy settings for new chat creation; can be used only if
     * getOption("can_set_new_chat_privacy_settings")
     * @param settings New settings
     */
    public async Ok set_new_chat_privacy_settings (
        NewChatPrivacySettings settings
    ) throws TDLibError {
        try {

        var obj = new SetNewChatPrivacySettings (
            settings
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_new_chat_privacy_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns privacy settings for new chat creation
     */
    public async NewChatPrivacySettings get_new_chat_privacy_settings () throws TDLibError {
        try {

        var obj = new GetNewChatPrivacySettings ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_new_chat_privacy_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (NewChatPrivacySettings) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Check whether the current user can message another user or try to
     * create a chat with them
     * @param user_id Identifier of the other user
     * @param only_local Pass true to get only locally available information
     * without sending network requests
     */
    public async CanSendMessageToUserResult can_send_message_to_user (
        int64 user_id,
        bool only_local
    ) throws TDLibError {
        try {

        var obj = new CanSendMessageToUser (
            user_id,
            only_local
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (can_send_message_to_user.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (CanSendMessageToUserResult) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the value of an option by its name. (Check the list of
     * available options on [[https://core.telegram.org/tdlib/options]].) Can
     * be called before authorization. Can be called synchronously for
     * options "version" and "commit_hash"
     * @param name The name of the option
     */
    public OptionValue get_option_sync (
        string name
    ) throws TDLibError {
        try {

        var obj = new GetOption (
            name
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (OptionValue) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the value of an option by its name. (Check the list of
     * available options on [[https://core.telegram.org/tdlib/options]].) Can
     * be called before authorization. Can be called synchronously for
     * options "version" and "commit_hash"
     * @param name The name of the option
     */
    public async OptionValue get_option (
        string name
    ) throws TDLibError {
        try {

        var obj = new GetOption (
            name
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_option.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (OptionValue) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the value of an option. (Check the list of available options on
     * [[https://core.telegram.org/tdlib/options]].) Only writable options
     * can be set. Can be called before authorization
     * @param name The name of the option
     * @param value The new value of the option; pass null to reset option
     * value to a default value
     */
    public async Ok set_option (
        string name,
        OptionValue value
    ) throws TDLibError {
        try {

        var obj = new SetOption (
            name,
            value
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_option.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the period of inactivity after which the account of the
     * current user will automatically be deleted
     * @param ttl New account TTL
     */
    public async Ok set_account_ttl (
        AccountTtl ttl
    ) throws TDLibError {
        try {

        var obj = new SetAccountTtl (
            ttl
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_account_ttl.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the period of inactivity after which the account of the
     * current user will automatically be deleted
     */
    public async AccountTtl get_account_ttl () throws TDLibError {
        try {

        var obj = new GetAccountTtl ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_account_ttl.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (AccountTtl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes the account of the current user, deleting all information
     * associated with the user from the server. The phone number of the
     * account can be used to create a new account.
     * Can be called before authorization when the current authorization
     * state is authorizationStateWaitPassword
     * @param reason The reason why the account was deleted; optional
     * @param password The 2-step verification password of the current user.
     * If the current user isn't authorized, then an empty string can be
     * passed and account deletion can be canceled within one week
     */
    public async Ok delete_account (
        string reason,
        string password
    ) throws TDLibError {
        try {

        var obj = new DeleteAccount (
            reason,
            password
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_account.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the default message auto-delete time for new chats
     * @param message_auto_delete_time New default message auto-delete time;
     * must be from 0 up to 365 * 86400 and be divisible by 86400. If 0, then
     * messages aren't deleted automatically
     */
    public async Ok set_default_message_auto_delete_time (
        MessageAutoDeleteTime message_auto_delete_time
    ) throws TDLibError {
        try {

        var obj = new SetDefaultMessageAutoDeleteTime (
            message_auto_delete_time
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_default_message_auto_delete_time.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns default message auto-delete time setting for new chats
     */
    public async MessageAutoDeleteTime get_default_message_auto_delete_time () throws TDLibError {
        try {

        var obj = new GetDefaultMessageAutoDeleteTime ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_default_message_auto_delete_time.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MessageAutoDeleteTime) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes a chat action bar without any other action
     * @param chat_id Chat identifier
     */
    public async Ok remove_chat_action_bar (
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new RemoveChatActionBar (
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_chat_action_bar.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Reports a chat to the Telegram moderators. A chat can be reported only
     * from the chat action bar, or if chat.can_be_reported
     * @param chat_id Chat identifier
     * @param option_id Option identifier chosen by the user; leave empty for
     * the initial request
     * @param message_ids Identifiers of reported messages. Use
     * messageProperties.can_report_chat to check whether the message can be
     * reported
     * @param text Additional report details if asked by the server; 0-1024
     * characters; leave empty for the initial request
     */
    public async ReportChatResult report_chat (
        int64 chat_id,
        Bytes option_id,
        Gee.ArrayList<int64?> message_ids,
        string text
    ) throws TDLibError {
        try {

        var obj = new ReportChat (
            chat_id,
            option_id,
            message_ids,
            text
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_chat.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ReportChatResult) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Reports a chat photo to the Telegram moderators. A chat photo can be
     * reported only if chat.can_be_reported
     * @param chat_id Chat identifier
     * @param file_id Identifier of the photo to report. Only full photos
     * from chatPhoto can be reported
     * @param reason The reason for reporting the chat photo
     * @param text Additional report details; 0-1024 characters
     */
    public async Ok report_chat_photo (
        int64 chat_id,
        int32 file_id,
        ReportReason reason,
        string text
    ) throws TDLibError {
        try {

        var obj = new ReportChatPhoto (
            chat_id,
            file_id,
            reason,
            text
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_chat_photo.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Reports reactions set on a message to the Telegram moderators.
     * Reactions on a message can be reported only if
     * messageProperties.can_report_reactions
     * @param chat_id Chat identifier
     * @param message_id Message identifier
     * @param sender_id Identifier of the sender, which added the reaction
     */
    public async Ok report_message_reactions (
        int64 chat_id,
        int64 message_id,
        MessageSender sender_id
    ) throws TDLibError {
        try {

        var obj = new ReportMessageReactions (
            chat_id,
            message_id,
            sender_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (report_message_reactions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns detailed revenue statistics about a chat. Currently, this
     * method can be used only
     * for channels if supergroupFullInfo.can_get_revenue_statistics == true
     * or bots if userFullInfo.bot_info.can_get_revenue_statistics == true
     * @param chat_id Chat identifier
     * @param is_dark Pass true if a dark theme is used by the application
     */
    public async ChatRevenueStatistics get_chat_revenue_statistics (
        int64 chat_id,
        bool is_dark
    ) throws TDLibError {
        try {

        var obj = new GetChatRevenueStatistics (
            chat_id,
            is_dark
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_revenue_statistics.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatRevenueStatistics) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a URL for chat revenue withdrawal; requires owner privileges
     * in the channel chat or the bot. Currently, this method can be used
     * only
     * if getOption("can_withdraw_chat_revenue") for channels with
     * supergroupFullInfo.can_get_revenue_statistics == true or bots with
     * userFullInfo.bot_info.can_get_revenue_statistics == true
     * @param chat_id Chat identifier
     * @param password The 2-step verification password of the current user
     */
    public async HttpUrl get_chat_revenue_withdrawal_url (
        int64 chat_id,
        string password
    ) throws TDLibError {
        try {

        var obj = new GetChatRevenueWithdrawalUrl (
            chat_id,
            password
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_revenue_withdrawal_url.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (HttpUrl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of revenue transactions for a chat. Currently, this
     * method can be used only
     * for channels if supergroupFullInfo.can_get_revenue_statistics == true
     * or bots if userFullInfo.bot_info.can_get_revenue_statistics == true
     * @param chat_id Chat identifier
     * @param offset Number of transactions to skip
     * @param limit The maximum number of transactions to be returned; up to
     * 200
     */
    public async ChatRevenueTransactions get_chat_revenue_transactions (
        int64 chat_id,
        int32 offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetChatRevenueTransactions (
            chat_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_revenue_transactions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatRevenueTransactions) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns detailed Telegram Star revenue statistics
     * @param owner_id Identifier of the owner of the Telegram Stars; can be
     * identifier of an owned bot, or identifier of a channel chat with
     * supergroupFullInfo.can_get_star_revenue_statistics == true
     * @param is_dark Pass true if a dark theme is used by the application
     */
    public async StarRevenueStatistics get_star_revenue_statistics (
        MessageSender owner_id,
        bool is_dark
    ) throws TDLibError {
        try {

        var obj = new GetStarRevenueStatistics (
            owner_id,
            is_dark
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_star_revenue_statistics.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StarRevenueStatistics) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a URL for Telegram Star withdrawal
     * @param owner_id Identifier of the owner of the Telegram Stars; can be
     * identifier of an owned bot, or identifier of an owned channel chat
     * @param star_count The number of Telegram Stars to withdraw. Must be at
     * least getOption("star_withdrawal_count_min")
     * @param password The 2-step verification password of the current user
     */
    public async HttpUrl get_star_withdrawal_url (
        MessageSender owner_id,
        int64 star_count,
        string password
    ) throws TDLibError {
        try {

        var obj = new GetStarWithdrawalUrl (
            owner_id,
            star_count,
            password
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_star_withdrawal_url.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (HttpUrl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a URL for a Telegram Ad platform account that can be used to
     * set up advertisements for the chat paid in the owned Telegram Stars
     * @param owner_id Identifier of the owner of the Telegram Stars; can be
     * identifier of an owned bot, or identifier of an owned channel chat
     */
    public async HttpUrl get_star_ad_account_url (
        MessageSender owner_id
    ) throws TDLibError {
        try {

        var obj = new GetStarAdAccountUrl (
            owner_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_star_ad_account_url.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (HttpUrl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns detailed statistics about a chat. Currently, this method can
     * be used only for supergroups and channels. Can be used only if
     * supergroupFullInfo.can_get_statistics == true
     * @param chat_id Chat identifier
     * @param is_dark Pass true if a dark theme is used by the application
     */
    public async ChatStatistics get_chat_statistics (
        int64 chat_id,
        bool is_dark
    ) throws TDLibError {
        try {

        var obj = new GetChatStatistics (
            chat_id,
            is_dark
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_chat_statistics.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ChatStatistics) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns detailed statistics about a message. Can be used only if
     * messageProperties.can_get_statistics == true
     * @param chat_id Chat identifier
     * @param message_id Message identifier
     * @param is_dark Pass true if a dark theme is used by the application
     */
    public async MessageStatistics get_message_statistics (
        int64 chat_id,
        int64 message_id,
        bool is_dark
    ) throws TDLibError {
        try {

        var obj = new GetMessageStatistics (
            chat_id,
            message_id,
            is_dark
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_statistics.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (MessageStatistics) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns forwarded copies of a channel message to different public
     * channels and public reposts as a story. Can be used only if
     * messageProperties.can_get_statistics == true. For optimal performance,
     * the number of returned messages and stories is chosen by TDLib
     * @param chat_id Chat identifier of the message
     * @param message_id Message identifier
     * @param offset Offset of the first entry to return as received from the
     * previous request; use empty string to get the first chunk of results
     * @param limit The maximum number of messages and stories to be
     * returned; must be positive and can't be greater than 100. For optimal
     * performance, the number of returned objects is chosen by TDLib and can
     * be smaller than the specified limit
     */
    public async PublicForwards get_message_public_forwards (
        int64 chat_id,
        int64 message_id,
        string offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetMessagePublicForwards (
            chat_id,
            message_id,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_message_public_forwards.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PublicForwards) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns detailed statistics about a story. Can be used only if
     * story.can_get_statistics == true
     * @param chat_id Chat identifier
     * @param story_id Story identifier
     * @param is_dark Pass true if a dark theme is used by the application
     */
    public async StoryStatistics get_story_statistics (
        int64 chat_id,
        int32 story_id,
        bool is_dark
    ) throws TDLibError {
        try {

        var obj = new GetStoryStatistics (
            chat_id,
            story_id,
            is_dark
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_story_statistics.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StoryStatistics) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Loads an asynchronous or a zoomed in statistical graph
     * @param chat_id Chat identifier
     * @param token The token for graph loading
     * @param x X-value for zoomed in graph or 0 otherwise
     */
    public async StatisticalGraph get_statistical_graph (
        int64 chat_id,
        string token,
        int64 x
    ) throws TDLibError {
        try {

        var obj = new GetStatisticalGraph (
            chat_id,
            token,
            x
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_statistical_graph.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StatisticalGraph) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns storage usage statistics. Can be called before authorization
     * @param chat_limit The maximum number of chats with the largest storage
     * usage for which separate statistics need to be returned. All other
     * chats will be grouped in entries with chat_id == 0. If the chat info
     * database is not used, the chat_limit is ignored and is always set to 0
     */
    public async StorageStatistics get_storage_statistics (
        int32 chat_limit
    ) throws TDLibError {
        try {

        var obj = new GetStorageStatistics (
            chat_limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_storage_statistics.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StorageStatistics) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Quickly returns approximate storage usage statistics. Can be called
     * before authorization
     */
    public async StorageStatisticsFast get_storage_statistics_fast () throws TDLibError {
        try {

        var obj = new GetStorageStatisticsFast ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_storage_statistics_fast.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StorageStatisticsFast) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns database statistics
     */
    public async DatabaseStatistics get_database_statistics () throws TDLibError {
        try {

        var obj = new GetDatabaseStatistics ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_database_statistics.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (DatabaseStatistics) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Optimizes storage usage, i.e. deletes some files and returns new
     * storage usage statistics. Secret thumbnails can't be deleted
     * @param size Limit on the total size of files after deletion, in bytes.
     * Pass -1 to use the default limit
     * @param ttl Limit on the time that has passed since the last time a
     * file was accessed (or creation time for some filesystems). Pass -1 to
     * use the default limit
     * @param count Limit on the total number of files after deletion. Pass
     * -1 to use the default limit
     * @param immunity_delay The amount of time after the creation of a file
     * during which it can't be deleted, in seconds. Pass -1 to use the
     * default value
     * @param file_types If non-empty, only files with the given types are
     * considered. By default, all types except thumbnails, profile photos,
     * stickers and wallpapers are deleted
     * @param chat_ids If non-empty, only files from the given chats are
     * considered. Use 0 as chat identifier to delete files not belonging to
     * any chat (e.g., profile photos)
     * @param exclude_chat_ids If non-empty, files from the given chats are
     * excluded. Use 0 as chat identifier to exclude all files not belonging
     * to any chat (e.g., profile photos)
     * @param return_deleted_file_statistics Pass true if statistics about
     * the files that were deleted must be returned instead of the whole
     * storage usage statistics. Affects only returned statistics
     * @param chat_limit Same as in {@link Client.get_storage_statistics}
     * Affects only returned statistics
     */
    public async StorageStatistics optimize_storage (
        int64 size,
        int32 ttl,
        int32 count,
        int32 immunity_delay,
        Gee.ArrayList<FileType?> file_types,
        Gee.ArrayList<int64?> chat_ids,
        Gee.ArrayList<int64?> exclude_chat_ids,
        bool return_deleted_file_statistics,
        int32 chat_limit
    ) throws TDLibError {
        try {

        var obj = new OptimizeStorage (
            size,
            ttl,
            count,
            immunity_delay,
            file_types,
            chat_ids,
            exclude_chat_ids,
            return_deleted_file_statistics,
            chat_limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (optimize_storage.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StorageStatistics) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the current network type. Can be called before authorization.
     * Calling this method forces all network connections to reopen,
     * mitigating the delay in switching between different networks,
     * so it must be called whenever the network is changed, even if the
     * network type remains the same. Network type is used to check whether
     * the library can use the network at all and also for collecting
     * detailed network data usage statistics
     * @param type_ The new network type; pass null to set network type to
     * networkTypeOther
     */
    public async Ok set_network_type (
        NetworkType type_
    ) throws TDLibError {
        try {

        var obj = new SetNetworkType (
            type_
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_network_type.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns network data usage statistics. Can be called before
     * authorization
     * @param only_current Pass true to get statistics only for the current
     * library launch
     */
    public async NetworkStatistics get_network_statistics (
        bool only_current
    ) throws TDLibError {
        try {

        var obj = new GetNetworkStatistics (
            only_current
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_network_statistics.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (NetworkStatistics) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds the specified data to data usage statistics. Can be called before
     * authorization
     * @param entry The network statistics entry with the data to be added to
     * statistics
     */
    public async Ok add_network_statistics (
        NetworkStatisticsEntry entry
    ) throws TDLibError {
        try {

        var obj = new AddNetworkStatistics (
            entry
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_network_statistics.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Resets all network data usage statistics to zero. Can be called before
     * authorization
     */
    public async Ok reset_network_statistics () throws TDLibError {
        try {

        var obj = new ResetNetworkStatistics ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reset_network_statistics.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns auto-download settings presets for the current user
     */
    public async AutoDownloadSettingsPresets get_auto_download_settings_presets () throws TDLibError {
        try {

        var obj = new GetAutoDownloadSettingsPresets ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_auto_download_settings_presets.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (AutoDownloadSettingsPresets) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets auto-download settings
     * @param settings New user auto-download settings
     * @param type_ Type of the network for which the new settings are
     * relevant
     */
    public async Ok set_auto_download_settings (
        AutoDownloadSettings settings,
        NetworkType type_
    ) throws TDLibError {
        try {

        var obj = new SetAutoDownloadSettings (
            settings,
            type_
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_auto_download_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns autosave settings for the current user
     */
    public async AutosaveSettings get_autosave_settings () throws TDLibError {
        try {

        var obj = new GetAutosaveSettings ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_autosave_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (AutosaveSettings) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets autosave settings for the given scope. The method is guaranteed
     * to work only after at least one call to
     * {@link Client.get_autosave_settings}
     * @param scope Autosave settings scope
     * @param settings New autosave settings for the scope; pass null to set
     * autosave settings to default
     */
    public async Ok set_autosave_settings (
        AutosaveSettingsScope scope,
        ScopeAutosaveSettings settings
    ) throws TDLibError {
        try {

        var obj = new SetAutosaveSettings (
            scope,
            settings
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_autosave_settings.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Clears the list of all autosave settings exceptions. The method is
     * guaranteed to work only after at least one call to
     * {@link Client.get_autosave_settings}
     */
    public async Ok clear_autosave_settings_exceptions () throws TDLibError {
        try {

        var obj = new ClearAutosaveSettingsExceptions ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (clear_autosave_settings_exceptions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a bank card
     * @param bank_card_number The bank card number
     */
    public async BankCardInfo get_bank_card_info (
        string bank_card_number
    ) throws TDLibError {
        try {

        var obj = new GetBankCardInfo (
            bank_card_number
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_bank_card_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BankCardInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns one of the available Telegram Passport elements
     * @param type_ Telegram Passport element type
     * @param password The 2-step verification password of the current user
     */
    public async PassportElement get_passport_element (
        PassportElementType type_,
        string password
    ) throws TDLibError {
        try {

        var obj = new GetPassportElement (
            type_,
            password
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_passport_element.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PassportElement) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns all available Telegram Passport elements
     * @param password The 2-step verification password of the current user
     */
    public async PassportElements get_all_passport_elements (
        string password
    ) throws TDLibError {
        try {

        var obj = new GetAllPassportElements (
            password
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_all_passport_elements.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PassportElements) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds an element to the user's Telegram Passport. May return an error
     * with a message "PHONE_VERIFICATION_NEEDED" or
     * "EMAIL_VERIFICATION_NEEDED" if the chosen phone number or the chosen
     * email address must be verified first
     * @param element Input Telegram Passport element
     * @param password The 2-step verification password of the current user
     */
    public async PassportElement set_passport_element (
        InputPassportElement element,
        string password
    ) throws TDLibError {
        try {

        var obj = new SetPassportElement (
            element,
            password
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_passport_element.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PassportElement) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Deletes a Telegram Passport element
     * @param type_ Element type
     */
    public async Ok delete_passport_element (
        PassportElementType type_
    ) throws TDLibError {
        try {

        var obj = new DeletePassportElement (
            type_
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_passport_element.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs the user that some of the elements in their Telegram Passport
     * contain errors; for bots only. The user will not be able to resend the
     * elements, until the errors are fixed
     * @param user_id User identifier
     * @param errors The errors
     */
    public async Ok set_passport_element_errors (
        int64 user_id,
        Gee.ArrayList<InputPassportElementError?> errors
    ) throws TDLibError {
        try {

        var obj = new SetPassportElementErrors (
            user_id,
            errors
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_passport_element_errors.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an IETF language tag of the language preferred in the country,
     * which must be used to fill native fields in Telegram Passport personal
     * details. Returns a 404 error if unknown
     * @param country_code A two-letter ISO 3166-1 alpha-2 country code
     */
    public async Text get_preferred_country_language (
        string country_code
    ) throws TDLibError {
        try {

        var obj = new GetPreferredCountryLanguage (
            country_code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_preferred_country_language.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends a code to verify an email address to be added to a user's
     * Telegram Passport
     * @param email_address Email address
     */
    public async EmailAddressAuthenticationCodeInfo send_email_address_verification_code (
        string email_address
    ) throws TDLibError {
        try {

        var obj = new SendEmailAddressVerificationCode (
            email_address
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_email_address_verification_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (EmailAddressAuthenticationCodeInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Resends the code to verify an email address to be added to a user's
     * Telegram Passport
     */
    public async EmailAddressAuthenticationCodeInfo resend_email_address_verification_code () throws TDLibError {
        try {

        var obj = new ResendEmailAddressVerificationCode ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (resend_email_address_verification_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (EmailAddressAuthenticationCodeInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks the email address verification code for Telegram Passport
     * @param code Verification code to check
     */
    public async Ok check_email_address_verification_code (
        string code
    ) throws TDLibError {
        try {

        var obj = new CheckEmailAddressVerificationCode (
            code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_email_address_verification_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a Telegram Passport authorization form for sharing data with a
     * service
     * @param bot_user_id User identifier of the service's bot
     * @param scope Telegram Passport element types requested by the service
     * @param public_key Service's public key
     * @param nonce Unique request identifier provided by the service
     */
    public async PassportAuthorizationForm get_passport_authorization_form (
        int64 bot_user_id,
        string scope,
        string public_key,
        string nonce
    ) throws TDLibError {
        try {

        var obj = new GetPassportAuthorizationForm (
            bot_user_id,
            scope,
            public_key,
            nonce
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_passport_authorization_form.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PassportAuthorizationForm) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns already available Telegram Passport elements suitable for
     * completing a Telegram Passport authorization form. Result can be
     * received only once for each authorization form
     * @param authorization_form_id Authorization form identifier
     * @param password The 2-step verification password of the current user
     */
    public async PassportElementsWithErrors get_passport_authorization_form_available_elements (
        int32 authorization_form_id,
        string password
    ) throws TDLibError {
        try {

        var obj = new GetPassportAuthorizationFormAvailableElements (
            authorization_form_id,
            password
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_passport_authorization_form_available_elements.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PassportElementsWithErrors) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends a Telegram Passport authorization form, effectively sharing data
     * with the service. This method must be called after
     * {@link Client.get_passport_authorization_form_available_elements} if
     * some previously available elements are going to be reused
     * @param authorization_form_id Authorization form identifier
     * @param types Types of Telegram Passport elements chosen by user to
     * complete the authorization form
     */
    public async Ok send_passport_authorization_form (
        int32 authorization_form_id,
        Gee.ArrayList<PassportElementType?> types
    ) throws TDLibError {
        try {

        var obj = new SendPassportAuthorizationForm (
            authorization_form_id,
            types
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_passport_authorization_form.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs the server about the number of pending bot updates if they
     * haven't been processed for a long time; for bots only
     * @param pending_update_count The number of pending updates
     * @param error_message The last error message
     */
    public async Ok set_bot_updates_status (
        int32 pending_update_count,
        string error_message
    ) throws TDLibError {
        try {

        var obj = new SetBotUpdatesStatus (
            pending_update_count,
            error_message
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_bot_updates_status.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Uploads a file with a sticker; returns the uploaded file
     * @param user_id Sticker file owner; ignored for regular users
     * @param sticker_format Sticker format
     * @param sticker File file to upload; must fit in a 512x512 square. For
     * WEBP stickers the file must be in WEBP or PNG format, which will be
     * converted to WEBP server-side. See
     * [[https://core.telegram.org/animated_stickers#technical-requirements]]
     * for technical requirements
     */
    public async File upload_sticker_file (
        int64 user_id,
        StickerFormat sticker_format,
        InputFile sticker
    ) throws TDLibError {
        try {

        var obj = new UploadStickerFile (
            user_id,
            sticker_format,
            sticker
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (upload_sticker_file.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (File) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns a suggested name for a new sticker set with a given title
     * @param title Sticker set title; 1-64 characters
     */
    public async Text get_suggested_sticker_set_name (
        string title
    ) throws TDLibError {
        try {

        var obj = new GetSuggestedStickerSetName (
            title
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_suggested_sticker_set_name.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks whether a name can be used for a new sticker set
     * @param name Name to be checked
     */
    public async CheckStickerSetNameResult check_sticker_set_name (
        string name
    ) throws TDLibError {
        try {

        var obj = new CheckStickerSetName (
            name
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_sticker_set_name.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (CheckStickerSetNameResult) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Creates a new sticker set. Returns the newly created sticker set
     * @param user_id Sticker set owner; ignored for regular users
     * @param title Sticker set title; 1-64 characters
     * @param name Sticker set name. Can contain only English letters, digits
     * and underscores. Must end with *"_by_<bot username>"*
     * (*<bot_username>* is case insensitive) for bots; 0-64 characters. If
     * empty, then the name returned by
     * {@link Client.get_suggested_sticker_set_name} will be used
     * automatically
     * @param sticker_type Type of the stickers in the set
     * @param needs_repainting Pass true if stickers in the sticker set must
     * be repainted; for custom emoji sticker sets only
     * @param stickers List of stickers to be added to the set; 1-200
     * stickers for custom emoji sticker sets, and 1-120 stickers otherwise.
     * For TGS stickers, {@link Client.upload_sticker_file} must be used
     * before the sticker is shown
     * @param source Source of the sticker set; may be empty if unknown
     */
    public async StickerSet create_new_sticker_set (
        int64 user_id,
        string title,
        string name,
        StickerType sticker_type,
        bool needs_repainting,
        Gee.ArrayList<InputSticker?> stickers,
        string source
    ) throws TDLibError {
        try {

        var obj = new CreateNewStickerSet (
            user_id,
            title,
            name,
            sticker_type,
            needs_repainting,
            stickers,
            source
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (create_new_sticker_set.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StickerSet) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a new sticker to a set
     * @param user_id Sticker set owner; ignored for regular users
     * @param name Sticker set name. The sticker set must be owned by the
     * current user, and contain less than 200 stickers for custom emoji
     * sticker sets and less than 120 otherwise
     * @param sticker Sticker to add to the set
     */
    public async Ok add_sticker_to_set (
        int64 user_id,
        string name,
        InputSticker sticker
    ) throws TDLibError {
        try {

        var obj = new AddStickerToSet (
            user_id,
            name,
            sticker
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_sticker_to_set.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Replaces existing sticker in a set. The function is equivalent to
     * {@link Client.remove_sticker_from_set} then
     * {@link Client.add_sticker_to_set} then
     * {@link Client.set_sticker_position_in_set}
     * @param user_id Sticker set owner; ignored for regular users
     * @param name Sticker set name. The sticker set must be owned by the
     * current user
     * @param old_sticker Sticker to remove from the set
     * @param new_sticker Sticker to add to the set
     */
    public async Ok replace_sticker_in_set (
        int64 user_id,
        string name,
        InputFile old_sticker,
        InputSticker new_sticker
    ) throws TDLibError {
        try {

        var obj = new ReplaceStickerInSet (
            user_id,
            name,
            old_sticker,
            new_sticker
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (replace_sticker_in_set.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets a sticker set thumbnail
     * @param user_id Sticker set owner; ignored for regular users
     * @param name Sticker set name. The sticker set must be owned by the
     * current user
     * @param thumbnail Thumbnail to set; pass null to remove the sticker set
     * thumbnail
     * @param format Format of the thumbnail; pass null if thumbnail is
     * removed
     */
    public async Ok set_sticker_set_thumbnail (
        int64 user_id,
        string name,
        InputFile thumbnail,
        StickerFormat format
    ) throws TDLibError {
        try {

        var obj = new SetStickerSetThumbnail (
            user_id,
            name,
            thumbnail,
            format
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_sticker_set_thumbnail.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets a custom emoji sticker set thumbnail
     * @param name Sticker set name. The sticker set must be owned by the
     * current user
     * @param custom_emoji_id Identifier of the custom emoji from the sticker
     * set, which will be set as sticker set thumbnail; pass 0 to remove the
     * sticker set thumbnail
     */
    public async Ok set_custom_emoji_sticker_set_thumbnail (
        string name,
        int64 custom_emoji_id
    ) throws TDLibError {
        try {

        var obj = new SetCustomEmojiStickerSetThumbnail (
            name,
            custom_emoji_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_custom_emoji_sticker_set_thumbnail.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets a sticker set title
     * @param name Sticker set name. The sticker set must be owned by the
     * current user
     * @param title New sticker set title
     */
    public async Ok set_sticker_set_title (
        string name,
        string title
    ) throws TDLibError {
        try {

        var obj = new SetStickerSetTitle (
            name,
            title
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_sticker_set_title.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Completely deletes a sticker set
     * @param name Sticker set name. The sticker set must be owned by the
     * current user
     */
    public async Ok delete_sticker_set (
        string name
    ) throws TDLibError {
        try {

        var obj = new DeleteStickerSet (
            name
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (delete_sticker_set.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the position of a sticker in the set to which it belongs. The
     * sticker set must be owned by the current user
     * @param sticker Sticker
     * @param position New position of the sticker in the set, 0-based
     */
    public async Ok set_sticker_position_in_set (
        InputFile sticker,
        int32 position
    ) throws TDLibError {
        try {

        var obj = new SetStickerPositionInSet (
            sticker,
            position
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_sticker_position_in_set.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes a sticker from the set to which it belongs. The sticker set
     * must be owned by the current user
     * @param sticker Sticker to remove from the set
     */
    public async Ok remove_sticker_from_set (
        InputFile sticker
    ) throws TDLibError {
        try {

        var obj = new RemoveStickerFromSet (
            sticker
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_sticker_from_set.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the list of emojis corresponding to a sticker. The sticker
     * must belong to a regular or custom emoji sticker set that is owned by
     * the current user
     * @param sticker Sticker
     * @param emojis New string with 1-20 emoji corresponding to the sticker
     */
    public async Ok set_sticker_emojis (
        InputFile sticker,
        string emojis
    ) throws TDLibError {
        try {

        var obj = new SetStickerEmojis (
            sticker,
            emojis
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_sticker_emojis.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the list of keywords of a sticker. The sticker must belong to
     * a regular or custom emoji sticker set that is owned by the current
     * user
     * @param sticker Sticker
     * @param keywords List of up to 20 keywords with total length up to 64
     * characters, which can be used to find the sticker
     */
    public async Ok set_sticker_keywords (
        InputFile sticker,
        Gee.ArrayList<string?> keywords
    ) throws TDLibError {
        try {

        var obj = new SetStickerKeywords (
            sticker,
            keywords
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_sticker_keywords.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes the mask position of a mask sticker. The sticker must belong
     * to a mask sticker set that is owned by the current user
     * @param sticker Sticker
     * @param mask_position Position where the mask is placed; pass null to
     * remove mask position
     */
    public async Ok set_sticker_mask_position (
        InputFile sticker,
        MaskPosition mask_position
    ) throws TDLibError {
        try {

        var obj = new SetStickerMaskPosition (
            sticker,
            mask_position
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_sticker_mask_position.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns sticker sets owned by the current user
     * @param offset_sticker_set_id Identifier of the sticker set from which
     * to return owned sticker sets; use 0 to get results from the beginning
     * @param limit The maximum number of sticker sets to be returned; must
     * be positive and can't be greater than 100. For optimal performance,
     * the number of returned objects is chosen by TDLib and can be smaller
     * than the specified limit
     */
    public async StickerSets get_owned_sticker_sets (
        int64 offset_sticker_set_id,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetOwnedStickerSets (
            offset_sticker_set_id,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_owned_sticker_sets.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StickerSets) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a file with a map thumbnail in PNG format.
     * Only map thumbnail files with size less than 1MB can be downloaded
     * @param location Location of the map center
     * @param zoom Map zoom level; 13-20
     * @param width Map width in pixels before applying scale; 16-1024
     * @param height Map height in pixels before applying scale; 16-1024
     * @param scale Map scale; 1-3
     * @param chat_id Identifier of a chat in which the thumbnail will be
     * shown. Use 0 if unknown
     */
    public async File get_map_thumbnail_file (
        Location location,
        int32 zoom,
        int32 width,
        int32 height,
        int32 scale,
        int64 chat_id
    ) throws TDLibError {
        try {

        var obj = new GetMapThumbnailFile (
            location,
            zoom,
            width,
            height,
            scale,
            chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_map_thumbnail_file.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (File) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a limit, increased for Premium users.
     * Returns a 404 error if the limit is unknown
     * @param limit_type Type of the limit
     */
    public async PremiumLimit get_premium_limit (
        PremiumLimitType limit_type
    ) throws TDLibError {
        try {

        var obj = new GetPremiumLimit (
            limit_type
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_premium_limit.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PremiumLimit) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about features, available to Premium users
     * @param source Source of the request; pass null if the method is called
     * from some non-standard source
     */
    public async PremiumFeatures get_premium_features (
        PremiumSource source
    ) throws TDLibError {
        try {

        var obj = new GetPremiumFeatures (
            source
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_premium_features.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PremiumFeatures) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns examples of premium stickers for demonstration purposes
     */
    public async Stickers get_premium_sticker_examples () throws TDLibError {
        try {

        var obj = new GetPremiumStickerExamples ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_premium_sticker_examples.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Stickers) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the sticker to be used as representation of the Telegram
     * Premium subscription
     * @param month_count Number of months the Telegram Premium subscription
     * will be active
     */
    public async Sticker get_premium_info_sticker (
        int32 month_count
    ) throws TDLibError {
        try {

        var obj = new GetPremiumInfoSticker (
            month_count
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_premium_info_sticker.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Sticker) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs TDLib that the user viewed detailed information about a
     * Premium feature on the Premium features screen
     * @param feature The viewed premium feature
     */
    public async Ok view_premium_feature (
        PremiumFeature feature
    ) throws TDLibError {
        try {

        var obj = new ViewPremiumFeature (
            feature
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (view_premium_feature.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs TDLib that the user clicked Premium subscription button on the
     * Premium features screen
     */
    public async Ok click_premium_subscription_button () throws TDLibError {
        try {

        var obj = new ClickPremiumSubscriptionButton ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (click_premium_subscription_button.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns state of Telegram Premium subscription and promotion videos
     * for Premium features
     */
    public async PremiumState get_premium_state () throws TDLibError {
        try {

        var obj = new GetPremiumState ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_premium_state.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PremiumState) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns available options for Telegram Premium gift code or Telegram
     * Premium giveaway creation
     * @param boosted_chat_id Identifier of the supergroup or channel chat,
     * which will be automatically boosted by receivers of the gift codes and
     * which is administered by the user; 0 if none
     */
    public async PremiumGiftCodePaymentOptions get_premium_gift_code_payment_options (
        int64 boosted_chat_id
    ) throws TDLibError {
        try {

        var obj = new GetPremiumGiftCodePaymentOptions (
            boosted_chat_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_premium_gift_code_payment_options.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PremiumGiftCodePaymentOptions) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Return information about a Telegram Premium gift code
     * @param code The code to check
     */
    public async PremiumGiftCodeInfo check_premium_gift_code (
        string code
    ) throws TDLibError {
        try {

        var obj = new CheckPremiumGiftCode (
            code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (check_premium_gift_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PremiumGiftCodeInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Applies a Telegram Premium gift code
     * @param code The code to apply
     */
    public async Ok apply_premium_gift_code (
        string code
    ) throws TDLibError {
        try {

        var obj = new ApplyPremiumGiftCode (
            code
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (apply_premium_gift_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Launches a prepaid giveaway
     * @param giveaway_id Unique identifier of the prepaid giveaway
     * @param parameters Giveaway parameters
     * @param winner_count The number of users to receive giveaway prize
     * @param star_count The number of Telegram Stars to be distributed
     * through the giveaway; pass 0 for Telegram Premium giveaways
     */
    public async Ok launch_prepaid_giveaway (
        int64 giveaway_id,
        GiveawayParameters parameters,
        int32 winner_count,
        int64 star_count
    ) throws TDLibError {
        try {

        var obj = new LaunchPrepaidGiveaway (
            giveaway_id,
            parameters,
            winner_count,
            star_count
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (launch_prepaid_giveaway.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a giveaway
     * @param chat_id Identifier of the channel chat which started the
     * giveaway
     * @param message_id Identifier of the giveaway or a giveaway winners
     * message in the chat
     */
    public async GiveawayInfo get_giveaway_info (
        int64 chat_id,
        int64 message_id
    ) throws TDLibError {
        try {

        var obj = new GetGiveawayInfo (
            chat_id,
            message_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_giveaway_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (GiveawayInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns available options for Telegram Stars purchase
     */
    public async StarPaymentOptions get_star_payment_options () throws TDLibError {
        try {

        var obj = new GetStarPaymentOptions ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_star_payment_options.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StarPaymentOptions) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns available options for Telegram Stars gifting
     * @param user_id Identifier of the user that will receive Telegram
     * Stars; pass 0 to get options for an unspecified user
     */
    public async StarPaymentOptions get_star_gift_payment_options (
        int64 user_id
    ) throws TDLibError {
        try {

        var obj = new GetStarGiftPaymentOptions (
            user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_star_gift_payment_options.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StarPaymentOptions) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns available options for Telegram Star giveaway creation
     */
    public async StarGiveawayPaymentOptions get_star_giveaway_payment_options () throws TDLibError {
        try {

        var obj = new GetStarGiveawayPaymentOptions ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_star_giveaway_payment_options.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StarGiveawayPaymentOptions) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of Telegram Star transactions for the specified owner
     * @param owner_id Identifier of the owner of the Telegram Stars; can be
     * the identifier of the current user, identifier of an owned bot, or
     * identifier of a channel chat with
     * supergroupFullInfo.can_get_star_revenue_statistics == true
     * @param subscription_id If non-empty, only transactions related to the
     * Star Subscription will be returned
     * @param direction Direction of the transactions to receive; pass null
     * to get all transactions
     * @param offset Offset of the first transaction to return as received
     * from the previous request; use empty string to get the first chunk of
     * results
     * @param limit The maximum number of transactions to return
     */
    public async StarTransactions get_star_transactions (
        MessageSender owner_id,
        string subscription_id,
        StarTransactionDirection direction,
        string offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetStarTransactions (
            owner_id,
            subscription_id,
            direction,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_star_transactions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StarTransactions) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of Telegram Star subscriptions for the current user
     * @param only_expiring Pass true to receive only expiring subscriptions
     * for which there are no enough Telegram Stars to extend
     * @param offset Offset of the first subscription to return as received
     * from the previous request; use empty string to get the first chunk of
     * results
     */
    public async StarSubscriptions get_star_subscriptions (
        bool only_expiring,
        string offset
    ) throws TDLibError {
        try {

        var obj = new GetStarSubscriptions (
            only_expiring,
            offset
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_star_subscriptions.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (StarSubscriptions) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Checks whether an in-store purchase is possible. Must be called before
     * any in-store purchase
     * @param purpose Transaction purpose
     */
    public async Ok can_purchase_from_store (
        StorePaymentPurpose purpose
    ) throws TDLibError {
        try {

        var obj = new CanPurchaseFromStore (
            purpose
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (can_purchase_from_store.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs server about a purchase through App Store. For official
     * applications only
     * @param receipt App Store receipt
     * @param purpose Transaction purpose
     */
    public async Ok assign_app_store_transaction (
        Bytes receipt,
        StorePaymentPurpose purpose
    ) throws TDLibError {
        try {

        var obj = new AssignAppStoreTransaction (
            receipt,
            purpose
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (assign_app_store_transaction.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Informs server about a purchase through Google Play. For official
     * applications only
     * @param package_name Application package name
     * @param store_product_id Identifier of the purchased store product
     * @param purchase_token Google Play purchase token
     * @param purpose Transaction purpose
     */
    public async Ok assign_google_play_transaction (
        string package_name,
        string store_product_id,
        string purchase_token,
        StorePaymentPurpose purpose
    ) throws TDLibError {
        try {

        var obj = new AssignGooglePlayTransaction (
            package_name,
            store_product_id,
            purchase_token,
            purpose
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (assign_google_play_transaction.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Cancels or re-enables Telegram Star subscription
     * @param subscription_id Identifier of the subscription to change
     * @param is_canceled New value of is_canceled
     */
    public async Ok edit_star_subscription (
        string subscription_id,
        bool is_canceled
    ) throws TDLibError {
        try {

        var obj = new EditStarSubscription (
            subscription_id,
            is_canceled
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_star_subscription.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Cancels or re-enables Telegram Star subscription for a user; for bots
     * only
     * @param user_id User identifier
     * @param telegram_payment_charge_id Telegram payment identifier of the
     * subscription
     * @param is_canceled Pass true to cancel the subscription; pass false to
     * allow the user to enable it
     */
    public async Ok edit_user_star_subscription (
        int64 user_id,
        string telegram_payment_charge_id,
        bool is_canceled
    ) throws TDLibError {
        try {

        var obj = new EditUserStarSubscription (
            user_id,
            telegram_payment_charge_id,
            is_canceled
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_user_star_subscription.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Reuses an active Telegram Star subscription to a channel chat and
     * joins the chat again
     * @param subscription_id Identifier of the subscription
     */
    public async Ok reuse_star_subscription (
        string subscription_id
    ) throws TDLibError {
        try {

        var obj = new ReuseStarSubscription (
            subscription_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (reuse_star_subscription.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Changes affiliate program for a bot
     * @param chat_id Identifier of the chat with an owned bot for which
     * affiliate program is changed
     * @param parameters Parameters of the affiliate program; pass null to
     * {@link Client.close} the currently active program. If there is an
     * active program, then commission and program duration can only be
     * increased. If the active program is scheduled to be closed, then it
     * can't be changed anymore
     */
    public async Ok set_chat_affiliate_program (
        int64 chat_id,
        AffiliateProgramParameters parameters
    ) throws TDLibError {
        try {

        var obj = new SetChatAffiliateProgram (
            chat_id,
            parameters
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_chat_affiliate_program.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches a chat with an affiliate program. Returns the chat if found
     * and the program is active
     * @param username Username of the chat
     * @param referrer The referrer from an
     * internalLinkTypeChatAffiliateProgram link
     */
    public async Chat search_chat_affiliate_program (
        string username,
        string referrer
    ) throws TDLibError {
        try {

        var obj = new SearchChatAffiliateProgram (
            username,
            referrer
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_chat_affiliate_program.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Chat) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches affiliate programs that can be connected to the given
     * affiliate
     * @param affiliate The affiliate for which affiliate programs are
     * searched for
     * @param sort_order Sort order for the results
     * @param offset Offset of the first affiliate program to return as
     * received from the previous request; use empty string to get the first
     * chunk of results
     * @param limit The maximum number of affiliate programs to return
     */
    public async FoundAffiliatePrograms search_affiliate_programs (
        AffiliateType affiliate,
        AffiliateProgramSortOrder sort_order,
        string offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new SearchAffiliatePrograms (
            affiliate,
            sort_order,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_affiliate_programs.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundAffiliatePrograms) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Connects an affiliate program to the given affiliate. Returns
     * information about the connected affiliate program
     * @param affiliate The affiliate to which the affiliate program will be
     * connected
     * @param bot_user_id Identifier of the bot, which affiliate program is
     * connected
     */
    public async ConnectedAffiliateProgram connect_affiliate_program (
        AffiliateType affiliate,
        int64 bot_user_id
    ) throws TDLibError {
        try {

        var obj = new ConnectAffiliateProgram (
            affiliate,
            bot_user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (connect_affiliate_program.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ConnectedAffiliateProgram) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Disconnects an affiliate program from the given affiliate and
     * immediately deactivates its referral link. Returns updated information
     * about the disconnected affiliate program
     * @param affiliate The affiliate to which the affiliate program is
     * connected
     * @param url The referral link of the affiliate program
     */
    public async ConnectedAffiliateProgram disconnect_affiliate_program (
        AffiliateType affiliate,
        string url
    ) throws TDLibError {
        try {

        var obj = new DisconnectAffiliateProgram (
            affiliate,
            url
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (disconnect_affiliate_program.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ConnectedAffiliateProgram) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an affiliate program that were connected to the given
     * affiliate by identifier of the bot that created the program
     * @param affiliate The affiliate to which the affiliate program will be
     * connected
     * @param bot_user_id Identifier of the bot that created the program
     */
    public async ConnectedAffiliateProgram get_connected_affiliate_program (
        AffiliateType affiliate,
        int64 bot_user_id
    ) throws TDLibError {
        try {

        var obj = new GetConnectedAffiliateProgram (
            affiliate,
            bot_user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_connected_affiliate_program.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ConnectedAffiliateProgram) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns affiliate programs that were connected to the given affiliate
     * @param affiliate The affiliate to which the affiliate program were
     * connected
     * @param offset Offset of the first affiliate program to return as
     * received from the previous request; use empty string to get the first
     * chunk of results
     * @param limit The maximum number of affiliate programs to return
     */
    public async ConnectedAffiliatePrograms get_connected_affiliate_programs (
        AffiliateType affiliate,
        string offset,
        int32 limit
    ) throws TDLibError {
        try {

        var obj = new GetConnectedAffiliatePrograms (
            affiliate,
            offset,
            limit
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_connected_affiliate_programs.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (ConnectedAffiliatePrograms) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about features, available to Business users
     * @param source Source of the request; pass null if the method is called
     * from settings or some non-standard source
     */
    public async BusinessFeatures get_business_features (
        BusinessFeature source
    ) throws TDLibError {
        try {

        var obj = new GetBusinessFeatures (
            source
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_business_features.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (BusinessFeatures) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Accepts Telegram terms of services
     * @param terms_of_service_id Terms of service identifier
     */
    public async Ok accept_terms_of_service (
        string terms_of_service_id
    ) throws TDLibError {
        try {

        var obj = new AcceptTermsOfService (
            terms_of_service_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (accept_terms_of_service.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches specified query by word prefixes in the provided strings.
     * Returns 0-based positions of strings that matched. Can be called
     * synchronously
     * @param strings The strings to search in for the query
     * @param query Query to search for
     * @param limit The maximum number of objects to return
     * @param return_none_for_empty_query Pass true to receive no results for
     * an empty query
     */
    public FoundPositions search_strings_by_prefix_sync (
        Gee.ArrayList<string?> strings,
        string query,
        int32 limit,
        bool return_none_for_empty_query
    ) throws TDLibError {
        try {

        var obj = new SearchStringsByPrefix (
            strings,
            query,
            limit,
            return_none_for_empty_query
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundPositions) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Searches specified query by word prefixes in the provided strings.
     * Returns 0-based positions of strings that matched. Can be called
     * synchronously
     * @param strings The strings to search in for the query
     * @param query Query to search for
     * @param limit The maximum number of objects to return
     * @param return_none_for_empty_query Pass true to receive no results for
     * an empty query
     */
    public async FoundPositions search_strings_by_prefix (
        Gee.ArrayList<string?> strings,
        string query,
        int32 limit,
        bool return_none_for_empty_query
    ) throws TDLibError {
        try {

        var obj = new SearchStringsByPrefix (
            strings,
            query,
            limit,
            return_none_for_empty_query
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (search_strings_by_prefix.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (FoundPositions) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends a custom request; for bots only
     * @param method The method name
     * @param parameters JSON-serialized method parameters
     */
    public async CustomRequestResult send_custom_request (
        string method,
        string parameters
    ) throws TDLibError {
        try {

        var obj = new SendCustomRequest (
            method,
            parameters
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (send_custom_request.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (CustomRequestResult) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Answers a custom query; for bots only
     * @param custom_query_id Identifier of a custom query
     * @param data JSON-serialized answer to the query
     */
    public async Ok answer_custom_query (
        int64 custom_query_id,
        string data
    ) throws TDLibError {
        try {

        var obj = new AnswerCustomQuery (
            custom_query_id,
            data
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (answer_custom_query.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Succeeds after a specified amount of time has passed. Can be called
     * before initialization
     * @param seconds Number of seconds before the function returns
     */
    public async Ok set_alarm (
        double seconds
    ) throws TDLibError {
        try {

        var obj = new SetAlarm (
            seconds
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_alarm.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about existing countries. Can be called before
     * authorization
     */
    public async Countries get_countries () throws TDLibError {
        try {

        var obj = new GetCountries ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_countries.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Countries) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Uses the current IP address to find the current country. Returns
     * two-letter ISO 3166-1 alpha-2 country code. Can be called before
     * authorization
     */
    public async Text get_country_code () throws TDLibError {
        try {

        var obj = new GetCountryCode ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_country_code.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a phone number by its prefix. Can be called
     * before authorization
     * @param phone_number_prefix The phone number prefix
     */
    public async PhoneNumberInfo get_phone_number_info (
        string phone_number_prefix
    ) throws TDLibError {
        try {

        var obj = new GetPhoneNumberInfo (
            phone_number_prefix
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_phone_number_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PhoneNumberInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a phone number by its prefix synchronously.
     * {@link Client.get_countries} must be called at least once after
     * changing localization to the specified language if properly localized
     * country information is expected. Can be called synchronously
     * @param language_code A two-letter ISO 639-1 language code for country
     * information localization
     * @param phone_number_prefix The phone number prefix
     */
    public PhoneNumberInfo get_phone_number_info_sync_sync (
        string language_code,
        string phone_number_prefix
    ) throws TDLibError {
        try {

        var obj = new GetPhoneNumberInfoSync (
            language_code,
            phone_number_prefix
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PhoneNumberInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a phone number by its prefix synchronously.
     * {@link Client.get_countries} must be called at least once after
     * changing localization to the specified language if properly localized
     * country information is expected. Can be called synchronously
     * @param language_code A two-letter ISO 639-1 language code for country
     * information localization
     * @param phone_number_prefix The phone number prefix
     */
    public async PhoneNumberInfo get_phone_number_info_sync (
        string language_code,
        string phone_number_prefix
    ) throws TDLibError {
        try {

        var obj = new GetPhoneNumberInfoSync (
            language_code,
            phone_number_prefix
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_phone_number_info_sync.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (PhoneNumberInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a given collectible item that was purchased
     * at [[https://fragment.com]]
     * @param type_ Type of the collectible item. The item must be used by a
     * user and must be visible to the current user
     */
    public async CollectibleItemInfo get_collectible_item_info (
        CollectibleItemType type_
    ) throws TDLibError {
        try {

        var obj = new GetCollectibleItemInfo (
            type_
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_collectible_item_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (CollectibleItemInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about a [[tg://]] deep link. Use
     * "[[tg://need_update_for_some_feature"]] or
     * "tg:some_unsupported_feature" for testing. Returns a 404 error for
     * unknown links. Can be called before authorization
     * @param link The link
     */
    public async DeepLinkInfo get_deep_link_info (
        string link
    ) throws TDLibError {
        try {

        var obj = new GetDeepLinkInfo (
            link
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_deep_link_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (DeepLinkInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns application config, provided by the server. Can be called
     * before authorization
     */
    public async JsonValue get_application_config () throws TDLibError {
        try {

        var obj = new GetApplicationConfig ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_application_config.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (JsonValue) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Saves application log event on the server. Can be called before
     * authorization
     * @param type_ Event type
     * @param chat_id Optional chat identifier, associated with the event
     * @param data The log event data
     */
    public async Ok save_application_log_event (
        string type_,
        int64 chat_id,
        JsonValue data
    ) throws TDLibError {
        try {

        var obj = new SaveApplicationLogEvent (
            type_,
            chat_id,
            data
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (save_application_log_event.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the link for downloading official Telegram application to be
     * used when the current user invites friends to Telegram
     */
    public async HttpUrl get_application_download_link () throws TDLibError {
        try {

        var obj = new GetApplicationDownloadLink ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_application_download_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (HttpUrl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a proxy server for network requests. Can be called before
     * authorization
     * @param server Proxy server domain or IP address
     * @param port Proxy server port
     * @param enable Pass true to immediately enable the proxy
     * @param type_ Proxy type
     */
    public async Proxy add_proxy (
        string server,
        int32 port,
        bool enable,
        ProxyType type_
    ) throws TDLibError {
        try {

        var obj = new AddProxy (
            server,
            port,
            enable,
            type_
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_proxy.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Proxy) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Edits an existing proxy server for network requests. Can be called
     * before authorization
     * @param proxy_id Proxy identifier
     * @param server Proxy server domain or IP address
     * @param port Proxy server port
     * @param enable Pass true to immediately enable the proxy
     * @param type_ Proxy type
     */
    public async Proxy edit_proxy (
        int32 proxy_id,
        string server,
        int32 port,
        bool enable,
        ProxyType type_
    ) throws TDLibError {
        try {

        var obj = new EditProxy (
            proxy_id,
            server,
            port,
            enable,
            type_
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (edit_proxy.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Proxy) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Enables a proxy. Only one proxy can be enabled at a time. Can be
     * called before authorization
     * @param proxy_id Proxy identifier
     */
    public async Ok enable_proxy (
        int32 proxy_id
    ) throws TDLibError {
        try {

        var obj = new EnableProxy (
            proxy_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (enable_proxy.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Disables the currently enabled proxy. Can be called before
     * authorization
     */
    public async Ok disable_proxy () throws TDLibError {
        try {

        var obj = new DisableProxy ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (disable_proxy.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Removes a proxy server. Can be called before authorization
     * @param proxy_id Proxy identifier
     */
    public async Ok remove_proxy (
        int32 proxy_id
    ) throws TDLibError {
        try {

        var obj = new RemoveProxy (
            proxy_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (remove_proxy.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of proxies that are currently set up. Can be called
     * before authorization
     */
    public async Proxies get_proxies () throws TDLibError {
        try {

        var obj = new GetProxies ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_proxies.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Proxies) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns an HTTPS link, which can be used to add a proxy. Available
     * only for SOCKS5 and MTProto proxies. Can be called before
     * authorization
     * @param proxy_id Proxy identifier
     */
    public async HttpUrl get_proxy_link (
        int32 proxy_id
    ) throws TDLibError {
        try {

        var obj = new GetProxyLink (
            proxy_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_proxy_link.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (HttpUrl) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Computes time needed to receive a response from a Telegram server
     * through a proxy. Can be called before authorization
     * @param proxy_id Proxy identifier. Use 0 to ping a Telegram server
     * without a proxy
     */
    public async Seconds ping_proxy (
        int32 proxy_id
    ) throws TDLibError {
        try {

        var obj = new PingProxy (
            proxy_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (ping_proxy.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Seconds) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets new log stream for internal logging of TDLib. Can be called
     * synchronously
     * @param log_stream New log stream
     */
    public Ok set_log_stream_sync (
        LogStream log_stream
    ) throws TDLibError {
        try {

        var obj = new SetLogStream (
            log_stream
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets new log stream for internal logging of TDLib. Can be called
     * synchronously
     * @param log_stream New log stream
     */
    public async Ok set_log_stream (
        LogStream log_stream
    ) throws TDLibError {
        try {

        var obj = new SetLogStream (
            log_stream
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_log_stream.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about currently used log stream for internal
     * logging of TDLib. Can be called synchronously
     */
    public LogStream get_log_stream_sync () throws TDLibError {
        try {

        var obj = new GetLogStream ();

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (LogStream) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns information about currently used log stream for internal
     * logging of TDLib. Can be called synchronously
     */
    public async LogStream get_log_stream () throws TDLibError {
        try {

        var obj = new GetLogStream ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_log_stream.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (LogStream) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the verbosity level of the internal logging of TDLib. Can be
     * called synchronously
     * @param new_verbosity_level New value of the verbosity level for
     * logging. Value 0 corresponds to fatal errors, value 1 corresponds to
     * errors, value 2 corresponds to warnings and debug warnings, value 3
     * corresponds to informational, value 4 corresponds to debug, value 5
     * corresponds to verbose debug, value greater than 5 and up to 1023 can
     * be used to enable even more logging
     */
    public Ok set_log_verbosity_level_sync (
        int32 new_verbosity_level
    ) throws TDLibError {
        try {

        var obj = new SetLogVerbosityLevel (
            new_verbosity_level
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the verbosity level of the internal logging of TDLib. Can be
     * called synchronously
     * @param new_verbosity_level New value of the verbosity level for
     * logging. Value 0 corresponds to fatal errors, value 1 corresponds to
     * errors, value 2 corresponds to warnings and debug warnings, value 3
     * corresponds to informational, value 4 corresponds to debug, value 5
     * corresponds to verbose debug, value greater than 5 and up to 1023 can
     * be used to enable even more logging
     */
    public async Ok set_log_verbosity_level (
        int32 new_verbosity_level
    ) throws TDLibError {
        try {

        var obj = new SetLogVerbosityLevel (
            new_verbosity_level
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_log_verbosity_level.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns current verbosity level of the internal logging of TDLib. Can
     * be called synchronously
     */
    public LogVerbosityLevel get_log_verbosity_level_sync () throws TDLibError {
        try {

        var obj = new GetLogVerbosityLevel ();

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (LogVerbosityLevel) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns current verbosity level of the internal logging of TDLib. Can
     * be called synchronously
     */
    public async LogVerbosityLevel get_log_verbosity_level () throws TDLibError {
        try {

        var obj = new GetLogVerbosityLevel ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_log_verbosity_level.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (LogVerbosityLevel) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of available TDLib internal log tags, for example,
     * ["actor", "binlog", "connections", "notifications", "proxy"]. Can be
     * called synchronously
     */
    public LogTags get_log_tags_sync () throws TDLibError {
        try {

        var obj = new GetLogTags ();

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (LogTags) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the list of available TDLib internal log tags, for example,
     * ["actor", "binlog", "connections", "notifications", "proxy"]. Can be
     * called synchronously
     */
    public async LogTags get_log_tags () throws TDLibError {
        try {

        var obj = new GetLogTags ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_log_tags.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (LogTags) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the verbosity level for a specified TDLib internal log tag. Can
     * be called synchronously
     * @param tag Logging tag to change verbosity level
     * @param new_verbosity_level New verbosity level; 1-1024
     */
    public Ok set_log_tag_verbosity_level_sync (
        string tag,
        int32 new_verbosity_level
    ) throws TDLibError {
        try {

        var obj = new SetLogTagVerbosityLevel (
            tag,
            new_verbosity_level
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets the verbosity level for a specified TDLib internal log tag. Can
     * be called synchronously
     * @param tag Logging tag to change verbosity level
     * @param new_verbosity_level New verbosity level; 1-1024
     */
    public async Ok set_log_tag_verbosity_level (
        string tag,
        int32 new_verbosity_level
    ) throws TDLibError {
        try {

        var obj = new SetLogTagVerbosityLevel (
            tag,
            new_verbosity_level
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_log_tag_verbosity_level.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns current verbosity level for a specified TDLib internal log
     * tag. Can be called synchronously
     * @param tag Logging tag to change verbosity level
     */
    public LogVerbosityLevel get_log_tag_verbosity_level_sync (
        string tag
    ) throws TDLibError {
        try {

        var obj = new GetLogTagVerbosityLevel (
            tag
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (LogVerbosityLevel) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns current verbosity level for a specified TDLib internal log
     * tag. Can be called synchronously
     * @param tag Logging tag to change verbosity level
     */
    public async LogVerbosityLevel get_log_tag_verbosity_level (
        string tag
    ) throws TDLibError {
        try {

        var obj = new GetLogTagVerbosityLevel (
            tag
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_log_tag_verbosity_level.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (LogVerbosityLevel) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a message to TDLib internal log. Can be called synchronously
     * @param verbosity_level The minimum verbosity level needed for the
     * message to be logged; 0-1023
     * @param text Text of a message to log
     */
    public Ok add_log_message_sync (
        int32 verbosity_level,
        string text
    ) throws TDLibError {
        try {

        var obj = new AddLogMessage (
            verbosity_level,
            text
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Adds a message to TDLib internal log. Can be called synchronously
     * @param verbosity_level The minimum verbosity level needed for the
     * message to be logged; 0-1023
     * @param text Text of a message to log
     */
    public async Ok add_log_message (
        int32 verbosity_level,
        string text
    ) throws TDLibError {
        try {

        var obj = new AddLogMessage (
            verbosity_level,
            text
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (add_log_message.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns support information for the given user; for Telegram support
     * only
     * @param user_id User identifier
     */
    public async UserSupportInfo get_user_support_info (
        int64 user_id
    ) throws TDLibError {
        try {

        var obj = new GetUserSupportInfo (
            user_id
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_user_support_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (UserSupportInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sets support information for the given user; for Telegram support only
     * @param user_id User identifier
     * @param message New information message
     */
    public async UserSupportInfo set_user_support_info (
        int64 user_id,
        FormattedText message
    ) throws TDLibError {
        try {

        var obj = new SetUserSupportInfo (
            user_id,
            message
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (set_user_support_info.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (UserSupportInfo) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns localized name of the Telegram support user; for Telegram
     * support only
     */
    public async Text get_support_name () throws TDLibError {
        try {

        var obj = new GetSupportName ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (get_support_name.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Text) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Does nothing; for testing only. This is an offline method. Can be
     * called before authorization
     */
    public async Ok test_call_empty () throws TDLibError {
        try {

        var obj = new TestCallEmpty ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_call_empty.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the received string; for testing only. This is an offline
     * method. Can be called before authorization
     * @param x String to return
     */
    public async TestString test_call_string (
        string x
    ) throws TDLibError {
        try {

        var obj = new TestCallString (
            x
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_call_string.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (TestString) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the received bytes; for testing only. This is an offline
     * method. Can be called before authorization
     * @param x Bytes to return
     */
    public async TestBytes test_call_bytes (
        Bytes x
    ) throws TDLibError {
        try {

        var obj = new TestCallBytes (
            x
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_call_bytes.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (TestBytes) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the received vector of numbers; for testing only. This is an
     * offline method. Can be called before authorization
     * @param x Vector of numbers to return
     */
    public async TestVectorInt test_call_vector_int (
        Gee.ArrayList<int32?> x
    ) throws TDLibError {
        try {

        var obj = new TestCallVectorInt (
            x
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_call_vector_int.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (TestVectorInt) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the received vector of objects containing a number; for
     * testing only. This is an offline method. Can be called before
     * authorization
     * @param x Vector of objects to return
     */
    public async TestVectorIntObject test_call_vector_int_object (
        Gee.ArrayList<TestInt?> x
    ) throws TDLibError {
        try {

        var obj = new TestCallVectorIntObject (
            x
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_call_vector_int_object.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (TestVectorIntObject) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the received vector of strings; for testing only. This is an
     * offline method. Can be called before authorization
     * @param x Vector of strings to return
     */
    public async TestVectorString test_call_vector_string (
        Gee.ArrayList<string?> x
    ) throws TDLibError {
        try {

        var obj = new TestCallVectorString (
            x
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_call_vector_string.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (TestVectorString) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the received vector of objects containing a string; for
     * testing only. This is an offline method. Can be called before
     * authorization
     * @param x Vector of objects to return
     */
    public async TestVectorStringObject test_call_vector_string_object (
        Gee.ArrayList<TestString?> x
    ) throws TDLibError {
        try {

        var obj = new TestCallVectorStringObject (
            x
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_call_vector_string_object.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (TestVectorStringObject) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the squared received number; for testing only. This is an
     * offline method. Can be called before authorization
     * @param x Number to square
     */
    public async TestInt test_square_int (
        int32 x
    ) throws TDLibError {
        try {

        var obj = new TestSquareInt (
            x
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_square_int.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (TestInt) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends a simple network request to the Telegram servers; for testing
     * only. Can be called before authorization
     */
    public async Ok test_network () throws TDLibError {
        try {

        var obj = new TestNetwork ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_network.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Sends a simple network request to the Telegram servers via proxy; for
     * testing only. Can be called before authorization
     * @param server Proxy server domain or IP address
     * @param port Proxy server port
     * @param type_ Proxy type
     * @param dc_id Identifier of a datacenter with which to test connection
     * @param timeout The maximum overall timeout for the request
     */
    public async Ok test_proxy (
        string server,
        int32 port,
        ProxyType type_,
        int32 dc_id,
        double timeout
    ) throws TDLibError {
        try {

        var obj = new TestProxy (
            server,
            port,
            type_,
            dc_id,
            timeout
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_proxy.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Forces an updates.getDifference call to the Telegram servers; for
     * testing only
     */
    public async Ok test_get_difference () throws TDLibError {
        try {

        var obj = new TestGetDifference ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_get_difference.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Ok) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Does nothing and ensures that the Update object is used; for testing
     * only. This is an offline method. Can be called before authorization
     */
    public async Update test_use_update () throws TDLibError {
        try {

        var obj = new TestUseUpdate ();
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_use_update.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Update) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the specified error and ensures that the Error object is used;
     * for testing only. Can be called synchronously
     * @param error The error to be returned
     */
    public Error test_return_error_sync (
        Error error
    ) throws TDLibError {
        try {

        var obj = new TestReturnError (
            error
        );

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("execute %s", json_string);

        string json_response = TDJsonApi.execute (json_string);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Error) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }

    /**
     * Returns the specified error and ensures that the Error object is used;
     * for testing only. Can be called synchronously
     * @param error The error to be returned
     */
    public async Error test_return_error (
        Error error
    ) throws TDLibError {
        try {

        var obj = new TestReturnError (
            error
        );
        string json_response = "";

        string json_string = TDJsoner.serialize (obj, Case.SNAKE);

        GLib.debug ("send %d %s", client_id, json_string);

        ulong conid = request_manager.recieved.connect ((request_extra, response) => {
            if (request_extra == obj.tdlib_extra) {
                json_response = response;
                Idle.add (test_return_error.callback);
            }
        });
        TDJsonApi.send (client_id, json_string);

        yield;
        SignalHandler.disconnect (request_manager, conid);

        var jsoner = new TDJsoner (json_response, { "@type" }, Case.SNAKE);
        string tdlib_type = jsoner.deserialize_value ().get_string ();

        if (tdlib_type == "error") {
            jsoner = new TDJsoner (json_response, { "message" }, Case.SNAKE);
            throw new TDLibError.COMMON (jsoner.deserialize_value ().get_string ());
        }

        jsoner = new TDJsoner (json_response, null, Case.SNAKE);
        return (Error) jsoner.deserialize_object (null);

        } catch (JsonError e) {
            throw new TDLibError.COMMON ("Error while parsing json");
        }
    }
}
